#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re
from datetime import datetime, timezone, timedelta
from typing import Optional, List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter, CommandObject
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.exceptions import TelegramBadRequest, TelegramRetryAfter

try:
    from openai import OpenAI
except Exception:
    OpenAI = None  # type: ignore

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

def insert_returning_id(sql:str, params:tuple|list|None=None)->int:
    """Execute INSERT ... RETURNING id and return the id safely (no race)."""
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql + " RETURNING id", params or ())
            row = cur.fetchone()
        conn.commit()
    return int(row["id"] if isinstance(row, dict) else row[0])

# ---------- Schema ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT
        )"""
    ]
    for ddl in ddls: q_exec(ddl)
ensure_schema()

# ---------- UI ----------
BTN_NEWQUIZ="ğŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_ADDQ="â• Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„"; BTN_LISTQUIZ="ğŸ“š Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EDITQUIZ="ğŸ› ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_DELQUIZ="ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø±"
BTN_BUNDLES="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©"; BTN_MERGE="ğŸ”— Ø¯Ù…Ø¬ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EXPORT="ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_IMPORT="ğŸ“¥ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙØ¹Ø©"
BTN_PUBLISH="ğŸš€ Ù†Ø´Ø± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_WIPE_ALL="ğŸ§¹ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_SCORE="ğŸ† Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬"; BTN_BACK_HOME="â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©"; BTN_BACK_STEP="â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø®Ù„Ù"
BTN_BRIEF="âœ‰ï¸ Ø²Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ"

def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_EDITQUIZ)],
        [KeyboardButton(text=BTN_DELQUIZ), KeyboardButton(text=BTN_BRIEF)],
        [KeyboardButton(text=BTN_WIPE_ALL), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_BUNDLES)],
        [KeyboardButton(text=BTN_MERGE), KeyboardButton(text=BTN_EXPORT)],
        [KeyboardButton(text=BTN_IMPORT)]
    ]
    return ReplyKeyboardMarkup(
        keyboard=rows,
        resize_keyboard=True,
        is_persistent=True,
        input_field_placeholder="Ø§Ø®ØªØ± Ø£Ù…Ø±Ù‹Ø§ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± ğŸ‘‡"
    )

ALL_BTN_TEXTS = {
    BTN_BACK_HOME, BTN_BACK_STEP, BTN_NEWQUIZ, BTN_ADDQ, BTN_LISTQUIZ, BTN_EDITQUIZ,
    BTN_DELQUIZ, BTN_BRIEF, BTN_WIPE_ALL, BTN_SCORE, BTN_PUBLISH, BTN_BUNDLES,
    BTN_MERGE, BTN_EXPORT, BTN_IMPORT
}

def done_button_kb(tag: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"done:{tag}")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª", callback_data=f"skip:{tag}")
    kb.adjust(2); return kb.as_markup()

def inline_confirm_kb(tag:str):
    kb=InlineKeyboardBuilder()
    kb.button(text="âœ… ØªØ£ÙƒÙŠØ¯", callback_data=f"{tag}:yes")
    kb.button(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=f"{tag}:no")
    kb.adjust(2); return kb.as_markup()

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID
async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±/Ø§Ù„Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", reply_markup=owner_kb()); return False
    return True
def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"

# --- Callback guard for NON-owner only ---
@dp.callback_query(
    F.from_user.id != OWNER_ID,
    F.data.regexp(r"^(addq|editq|delq|delqconfirm|briefdur|attach_mode|done:|skip:|wipe:)")
)
async def admin_cb_guard(cb: CallbackQuery):
    await cb.answer("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", show_alert=True)

# ---------- States ----------
class BuildStates(StatesGroup):
    waiting_title=State()
    waiting_pick_quiz_for_addq=State()
    waiting_q_block=State()
    waiting_q_attachments=State()
    waiting_correct_index=State()
    waiting_pick_for_edit=State()
    waiting_new_title=State()
    waiting_pick_for_delete=State()

class WipeStates(StatesGroup):
    waiting_confirm=State()

class BriefStates(StatesGroup):
    waiting_prompt=State()
    waiting_duration=State()
    waiting_custom=State()

# ---------- Parsers ----------
_option_line_re = re.compile(
    r"""^\s*(
        (\d+)[\)\.\-]\s*       # 1) or 1. or 1-
       |([A-Za-z])[)\.\-]\s*   # A) or a) etc.
       |[\-\*\â€¢]\s*            # - bullet or * or â€¢
    )?(?P<txt>.+?)\s*(?P<mark>(âœ…|\(\*\)|\*\)|\*\s*$))?\s*$""",
    re.X | re.U
)

def parse_q_block(text:str)->Tuple[str, List[Tuple[str,bool]]]:
    lines=[l for l in (text.replace("\r","").split("\n")) if l.strip()]
    if not lines: raise ValueError("Ù†Øµ ÙØ§Ø±Øº.")
    qline=lines[0].strip()
    opts=[]
    for l in lines[1:]:
        m=_option_line_re.match(l)
        if not m: continue
        t=m.group("txt").strip()
        if not t: continue
        is_correct=bool(m.group("mark"))
        opts.append((t,is_correct))
    if len(opts)<2 or len(opts)>10:
        raise ValueError("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ 2 Ø¥Ù„Ù‰ 10 Ø®ÙŠØ§Ø±Ø§Øª Ø¶Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
    return qline, opts

# ---------- Attachments helpers ----------
async def save_attachment(question_id:int, kind:str, file_id:str, pos:int):
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
           (question_id,kind,file_id,pos))

# ---------- /start & back ----------
@dp.message(Command("start"))
async def start(msg:Message):
    if is_owner(msg.from_user.id):
        await msg.answer("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¬Ø§Ù‡Ø²Ø© â€” Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:", reply_markup=owner_kb())
    else:
        await msg.answer("Ø£Ù‡Ù„Ø§Ù‹! Ù‡Ø°Ø§ Ø¨ÙˆØª Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¹Ù„Ù….")

@dp.message(F.text==BTN_BACK_HOME)
async def back_home(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("ØªÙ… Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©.", reply_markup=owner_kb())

@dp.message(F.text==BTN_BACK_STEP)
async def back_step(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("Ø±Ø¬Ø¹Ù†Ø§ Ø®Ø·ÙˆØ© (ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·).", reply_markup=owner_kb())

# ---------- Create quiz ----------
@dp.message(F.text==BTN_NEWQUIZ)
async def new_quiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_title)
    await msg.answer("Ø£Ø±Ø³Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:")

@dp.message(BuildStates.waiting_title, F.text)
async def save_quiz_title(msg:Message, state:FSMContext):
    title = msg.text.strip()
    qid = insert_returning_id(
        "INSERT INTO quizzes(title,created_by,created_at) VALUES (%s,%s,%s)",
        (title, msg.from_user.id, _now().isoformat())
    )
    await state.clear()
    await msg.answer(f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± (ID {qid}).", reply_markup=owner_kb())

# ---------- List quizzes ----------
@dp.message(F.text==BTN_LISTQUIZ)
async def list_quizzes(msg:Message):
    if not await ensure_owner(msg): return
    rows = q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.\nØ£Ù†Ø´Ø¦ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ø£ÙˆÙ„Ø§Ù‹.", reply_markup=owner_kb())
    txt = "ğŸ“š <b>Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª</b>:\n" + "\n".join([f"â€¢ {r['id']}: {html.escape(r['title'])}" for r in rows[:100]])
    await msg.answer(txt, reply_markup=owner_kb())

# ---------- Edit quiz title ----------
@dp.message(F.text==BTN_EDITQUIZ)
async def editquiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"âœï¸ {r['id']} â€” {r['title']}", callback_data=f"editq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_for_edit)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_for_edit, F.data.startswith("editq:"))
async def pick_for_edit(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(edit_id=qid)
    await state.set_state(BuildStates.waiting_new_title)
    await cb.message.answer("Ø£Ø±Ø³Ù„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯:")
    await cb.answer()

@dp.message(BuildStates.waiting_new_title, F.text)
async def apply_edit(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_id")
    q_exec("UPDATE quizzes SET title=%s WHERE id=%s", (msg.text.strip(), qid))
    await state.clear()
    await msg.answer("âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†.", reply_markup=owner_kb())

# ---------- Delete quiz (with per-quiz confirm) ----------
@dp.message(F.text==BTN_DELQUIZ)
async def delquiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"ğŸ—‘ï¸ {r['id']} â€” {r['title']}", callback_data=f"delq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_for_delete)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„Ù„Ø­Ø°Ù:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_for_delete, F.data.startswith("delq:"))
async def delq_confirm(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    kb=inline_confirm_kb(f"delqconfirm:{qid}")
    await cb.message.answer(f"âš ï¸ ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ID {qid}ØŸ", reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.regexp(r"^delqconfirm:(\d+):(yes|no)$"))
async def delq_apply(cb:CallbackQuery):
    _, rest = cb.data.split("delqconfirm:")
    qid, decision = rest.split(":")
    qid=int(qid)
    if decision=="no":
        await cb.message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡ âœ…", reply_markup=owner_kb()); return await cb.answer()
    # cascade delete
    q_exec("DELETE FROM options WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)", (qid,))
    q_exec("DELETE FROM question_attachments WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)", (qid,))
    q_exec("DELETE FROM questions WHERE quiz_id=%s", (qid,))
    q_exec("DELETE FROM sent_polls WHERE quiz_id=%s", (qid,))
    q_exec("DELETE FROM quizzes WHERE id=%s", (qid,))
    await cb.message.answer("ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Add Question (one-shot) ----------
@dp.message(F.text==BTN_ADDQ)
async def addq_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.\nØ£Ù†Ø´Ø¦ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ø£ÙˆÙ„Ø§Ù‹.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:30]:
        kb.button(text=f"âœ… {r['id']} â€” {r['title']}", callback_data=f"addq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_quiz_for_addq)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_quiz_for_addq, F.data.startswith("addq:"))
async def addq_pick(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(quiz_id=qid)
    await state.set_state(BuildStates.waiting_q_block)
    await cb.message.answer(
        "Ø£Ø±Ø³Ù„ <b>Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©</b>:\n"
        "Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø³Ø¤Ø§Ù„ØŒ Ø«Ù… ÙƒÙ„ Ø®ÙŠØ§Ø± Ø¨Ø³Ø·Ø± Ø¬Ø¯ÙŠØ¯ (2..10).\n"
        "Ù…Ø«Ø§Ù„:\n"
        "Ù…Ø§ Ø¹Ø§ØµÙ…Ø© Ø£Ù„Ù…Ø§Ù†ÙŠØ§ØŸ\n1) Ù‡Ø§Ù…Ø¨ÙˆØ±Øº\n2) Ø¨Ø±Ù„ÙŠÙ† âœ…\n3) Ù…ÙŠÙˆÙ†Ø®\n\n"
        "ÙŠÙ…ÙƒÙ†Ùƒ ÙˆØ¶Ø¹ âœ… Ø£Ùˆ (*) Ø¹Ù„Ù‰ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­."
    )
    await cb.answer()

@dp.message(BuildStates.waiting_q_block, F.text)
async def got_q_block(msg:Message, state:FSMContext):
    try:
        sel=(await state.get_data()); quiz_id=sel["quiz_id"]
        qtext, opts = parse_q_block(msg.text)
        new_q = insert_returning_id(
            "INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
            (quiz_id, qtext, _now().isoformat())
        )
        correct=None
        for i,(t,is_ok) in enumerate(opts):
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (new_q,i,t,1 if is_ok else 0))
            if is_ok: correct=i
        await state.update_data(question_id=new_q, next_att_pos=0, opt_count=len(opts), needs_correct=(correct is None))
        await state.set_state(BuildStates.waiting_q_attachments)
        await msg.answer("âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ§Ù„Ø®ÙŠØ§Ø±Ø§Øª.\nØ£Ø±Ø³Ù„ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª (ØµÙˆØ±/ÙÙˆÙŠØ³/Ø£ÙˆØ¯ÙŠÙˆ). Ø«Ù… Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ… Ø£Ùˆ âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª.", reply_markup=done_button_kb("qatt"))
    except Exception as e:
        await msg.answer(f"âš ï¸ Ù„Ù… Ø£ÙÙ‡Ù… Ø§Ù„Ø±Ø³Ø§Ù„Ø©: <code>{html.escape(str(e))}</code>")

@dp.message(BuildStates.waiting_q_attachments, F.photo)
async def qatt_photo(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("next_att_pos",0))
    await save_attachment(qid,"photo",msg.photo[-1].file_id,pos)
    await state.update_data(next_att_pos=pos+1)

@dp.message(BuildStates.waiting_q_attachments, F.voice)
async def qatt_voice(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("next_att_pos",0))
    await save_attachment(qid,"voice",msg.voice.file_id,pos)
    await state.update_data(next_att_pos=pos+1)

@dp.message(BuildStates.waiting_q_attachments, F.audio)
async def qatt_audio(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("next_att_pos",0))
    await save_attachment(qid,"audio",msg.audio.file_id,pos)
    await state.update_data(next_att_pos=pos+1)

@dp.callback_query(F.data.in_({"done:qatt","skip:qatt"}))
async def after_atts(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    if not d.get("needs_correct", True):
        await state.clear(); await cb.message.answer("ğŸ¯ ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„.", reply_markup=owner_kb()); return await cb.answer()
    await state.set_state(BuildStates.waiting_correct_index)
    await cb.message.answer(f"Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ (1..{int(d['opt_count'])}):")
    await cb.answer()

@dp.message(BuildStates.waiting_correct_index, F.text.regexp(r"^\d+$"))
async def set_correct(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d["question_id"]); cnt=int(d.get("opt_count",0))
    i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚.")
    q_exec("UPDATE options SET is_correct=0 WHERE question_id=%s",(qid,))
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear(); await msg.answer("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ.", reply_markup=owner_kb())

# ---------- Brief (prompt -> duration -> announce) ----------
def get_open_window(chat_id:int):
    row=q_one("SELECT id,closes_at,prompt_text,ann_message_id FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(chat_id,))
    if not row: return None
    # Defensive: if expired, close it here.
    try:
        closes = datetime.fromisoformat(row["closes_at"])
    except Exception:
        closes = _now()
    if closes <= _now():
        q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s",(row["id"],)); return None
    return row

def open_window(chat_id:int, owner:int, minutes:int, prompt:str)->Tuple[int,datetime]:
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))
    opened=_now(); closes=opened+timedelta(minutes=minutes)
    bid = insert_returning_id(
        """INSERT INTO brief_windows(origin_chat_id,opened_by,opened_at,closes_at,is_open,prompt_text)
              VALUES (%s,%s,%s,%s,1,%s)""",
        (chat_id,owner,opened.isoformat(),closes.isoformat(),prompt)
    )
    return bid, closes

def close_window(chat_id:int): q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))

def dur_buttons_for_brief(has_open: bool):
    kb=InlineKeyboardBuilder()
    for m in (15,30,60): kb.button(text=f"â±ï¸ {m} Ø¯Ù‚ÙŠÙ‚Ø©", callback_data=f"briefdur:{m}")
    kb.button(text="â±ï¸ Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ", callback_data="briefdur:custom")
    if has_open: kb.button(text="â›” Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„", callback_data="briefdur:stop")
    kb.adjust(2); return kb.as_markup()

@dp.message(Command("brief"))
@dp.message(F.text==BTN_BRIEF)
async def brief_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await state.set_state(BriefStates.waiting_prompt)
    await msg.answer("âœï¸ Ø£Ø±Ø³Ù„ Ù†Øµ Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ/Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ (B1 DTZ):")

@dp.message(BriefStates.waiting_prompt, F.text)
async def brief_got_prompt(msg:Message, state:FSMContext):
    prompt=msg.text.strip()
    await state.update_data(prompt=prompt)
    await state.set_state(BriefStates.waiting_duration)
    await msg.answer("âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ø³Ø¤Ø§Ù„.\nØ§Ø®ØªØ± Ù…Ø¯Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„:", reply_markup=dur_buttons_for_brief(has_open=bool(get_open_window(msg.chat.id))))

@dp.callback_query(F.data.startswith("briefdur:"))
async def brief_set_duration(cb:CallbackQuery, state:FSMContext):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    act=cb.data.split(":")[1]
    data=await state.get_data(); prompt=data.get("prompt","")
    if act=="stop":
        close_window(cb.message.chat.id); await cb.message.answer("â›” ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª.", reply_markup=owner_kb()); return await cb.answer()
    if act=="custom":
        await state.set_state(BriefStates.waiting_custom); await cb.message.answer("Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚ (Ù…Ø«Ø§Ù„: 45)"); return await cb.answer()
    minutes=int(act); bid, closes = open_window(cb.message.chat.id, cb.from_user.id, minutes, prompt)
    mins_left = max(0, int((closes - _now()).total_seconds() // 60))
    txt=(f"ğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
         f"â±ï¸ ÙŠÙ†ØªÙ‡ÙŠ Ø®Ù„Ø§Ù„: <b>{mins_left}Ø¯</b>\n"
         f"Ø£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ù‡Ù†Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.")
    m=await cb.message.answer(txt, reply_markup=owner_kb())
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear(); await cb.answer()

@dp.message(BriefStates.waiting_custom, F.text.regexp(r"^\d{1,3}$"))
async def brief_custom_duration(msg:Message, state:FSMContext):
    minutes=int(msg.text); prompt=(await state.get_data()).get("prompt","")
    bid,closes=open_window(msg.chat.id,msg.from_user.id,minutes,prompt)
    mins_left = max(0, int((closes - _now()).total_seconds() // 60))
    m=await msg.answer(
        f"ğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
        f"â±ï¸ ÙŠÙ†ØªÙ‡ÙŠ Ø®Ù„Ø§Ù„: <b>{mins_left}Ø¯</b>\n"
        f"Ø£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ù‡Ù†Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.", reply_markup=owner_kb()
    )
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear()

# ---------- Collect brief submissions (with simple grading) ----------
client=None
if OPENAI_API_KEY and OpenAI:
    try: client=OpenAI(api_key=OPENAI_API_KEY)
    except Exception: client=None

async def ai_grade(text: str) -> Tuple[int, str, Dict]:
    if not client:
        base = min(20, max(0, len(text) // 35))
        lvl = "Unter A2" if base<=6 else ("A2" if base<=14 else "B1")
        return base, lvl, {"note": "fallback heuristic (no OPENAI_API_KEY)"}
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            temperature=0.3,
            messages=[
                {"role":"system","content":"You are a certified Goethe/DTZ examiner. Grade B1 Schreiben (Brief/E-Mail) on a 0â€“20 scale and return JSON {\"score\":<int>,\"feedback\":\"<Arabic short>\"}."},
                {"role":"user","content":text},
            ],
            response_format={"type":"json_object"},
        )
        raw = resp.choices[0].message.content or "{}"
        data={}
        try: data=json.loads(raw)
        except Exception: pass
        score = int(max(0, min(20, int(data.get("score", 0)))))
        lvl = "Unter A2" if score<=6 else ("A2" if score<=14 else "B1")
        return score, lvl, data
    except Exception as e:
        base = min(20, max(0, len(text) // 40))
        lvl = "Unter A2" if base<=6 else ("A2" if base<=14 else "B1")
        return base, lvl, {"error": str(e)}

@dp.message(
    StateFilter(None),
    F.text,
    ~F.text.in_(ALL_BTN_TEXTS),
    ~F.text.startswith("/")
)
async def collect_briefs(msg:Message):
    win=q_one("SELECT id FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(msg.chat.id,))
    if not win: 
        return  # Ù„Ø§ ØªÙ„ØªÙ‚Ø· Ø±Ø³Ø§Ø¦Ù„ Ù…Ø§ Ù„Ù… ØªÙƒÙ† Ù†Ø§ÙØ°Ø© Ø¨Ø±ÙŠÙ Ù…ÙØªÙˆØ­Ø©
    text=msg.text.strip()
    score, lvl, details = await ai_grade(text)
    fb=html.escape(details.get("feedback","")) if isinstance(details,dict) else ""
    q_exec("""INSERT INTO writing_submissions(origin_chat_id,quiz_id,user_id,text,score,level,evaluated_at,details_json)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s)""",
           (msg.chat.id,0,msg.from_user.id,text,score,lvl,_now().isoformat(),json.dumps(details,ensure_ascii=False)))
    await msg.reply(
        f"ğŸ“® <b>Schreiben (B1 DTZ)</b>\n"
        f"ğŸ‘¤ {html.escape(hname(msg.from_user))}\n"
        f"ğŸ“Š <b>{score}/20</b>\n"
        f"ğŸ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <b>{lvl}</b>" + (f"\nğŸ“ Ù…Ù„Ø§Ø­Ø¸Ø§Øª: {fb}" if fb else ""),
        reply_markup=owner_kb()
    )

# ---------- Not-yet-implemented buttons (reply instead of silence) ----------
@dp.message(F.text.in_({BTN_BUNDLES, BTN_MERGE, BTN_EXPORT, BTN_IMPORT, BTN_PUBLISH, BTN_SCORE}))
async def placeholder(msg:Message):
    if not await ensure_owner(msg): return
    await msg.answer("Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ø³ØªÙÙØ¹Ù‘Ù„ Ù„Ø§Ø­Ù‚Ù‹Ø§ â€” Ø§Ù„Ø²Ø± ÙŠØ¹Ù…Ù„ ÙˆØªÙ… Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© âœ…", reply_markup=owner_kb())

# ---------- Wipe All with confirmation ----------
@dp.message(F.text==BTN_WIPE_ALL)
async def wipe_all_confirm(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(WipeStates.waiting_confirm)
    await msg.answer("âš ï¸ Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹.", reply_markup=inline_confirm_kb("wipe"))

@dp.callback_query(WipeStates.waiting_confirm, F.data.in_({"wipe:yes","wipe:no"}))
async def wipe_all_decide(cb:CallbackQuery, state:FSMContext):
    if cb.data=="wipe:no":
        await state.clear(); await cb.message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡ âœ…", reply_markup=owner_kb()); return await cb.answer()
    for tbl in ["options","question_attachments","questions","sent_polls","writing_submissions","brief_windows","quizzes"]:
        q_exec(f"DELETE FROM {tbl}")
    await state.clear(); await cb.message.answer("ğŸ§¹ ØªÙ… Ø­Ø°Ù ÙƒÙ„ Ø´ÙŠØ¡.", reply_markup=owner_kb()); await cb.answer()

# ---------- Runner ----------
async def main():
    await dp.start_polling(bot)

if __name__=="__main__":
    try: asyncio.run(main())
    except (KeyboardInterrupt,SystemExit): pass
