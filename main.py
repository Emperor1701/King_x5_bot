#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re
from datetime import datetime, timezone, timedelta
from typing import Optional, List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.exceptions import TelegramBadRequest, TelegramRetryAfter

# ---------- OpenAI (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) ----------
try:
    from openai import OpenAI
except Exception:
    OpenAI = None  # type: ignore

# ---------- ENV ----------
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

# ---------- BOT ----------
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})
print("[DB] Connected to Postgres")

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

# ---------- Schema ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0,
            grading_profile TEXT NOT NULL DEFAULT 'NONE'
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL, media_bundle_id INTEGER,
            photo TEXT, audio TEXT, audio_is_voice INTEGER DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS media_bundles(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS media_bundle_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            bundle_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, user_id BIGINT NOT NULL,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL, answered_at TEXT NOT NULL,
            UNIQUE(chat_id,user_id,question_id)
        )""",
        """CREATE TABLE IF NOT EXISTS participant_names(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, user_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL, name TEXT NOT NULL,
            UNIQUE(origin_chat_id,user_id,quiz_id)
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT
        )""",
        """CREATE TABLE IF NOT EXISTS hl_results(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, user_id BIGINT NOT NULL,
            correct_count INTEGER NOT NULL, total_count INTEGER NOT NULL,
            level TEXT NOT NULL, finished_at TEXT NOT NULL,
            UNIQUE(origin_chat_id,quiz_id,user_id)
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )"""
    ]
    for ddl in ddls: q_exec(ddl)
ensure_schema()

# ---------- UI labels ----------
BTN_NEWQUIZ="ğŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_ADDQ="â• Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„"; BTN_LISTQUIZ="ğŸ“š Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_LISTQ="ğŸ“– Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©"; BTN_EDITQUIZ="ğŸ› ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_DELQUIZ="ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø±"
BTN_BUNDLES="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©"; BTN_MERGE="ğŸ”— Ø¯Ù…Ø¬ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"; BTN_EXPORT="ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø±"
BTN_IMPORT="ğŸ“¥ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙØ¹Ø©"; BTN_PUBLISH="ğŸš€ Ù†Ø´Ø± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_WIPE_ALL="ğŸ§¹ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_SCORE="ğŸ† Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬"; BTN_BACK_HOME="â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©"; BTN_BACK_STEP="â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø®Ù„Ù"
BTN_LEVEL="ğŸ¯ ØªÙ‚ÙŠÙŠÙ… Ù…Ø³ØªÙˆÙ‰"; BTN_HL_PROFILE="ğŸ§  Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª HÃ¶ren & Lesen"; BTN_BRIEF="âœ‰ï¸ Ø²Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ"

ACT_EDIT_TEXT  = "âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù†Øµ"
ACT_EDIT_OPTS  = "ğŸ§© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª"
ACT_EDIT_MEDIA = "ğŸ–¼ï¸ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª"
ACT_DELETE_Q   = "ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„Ø³Ø¤Ø§Ù„"
ACT_BACK       = "â¬…ï¸ Ø±Ø¬ÙˆØ¹"

BTN_USE_BUNDLE = "ğŸ“ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø±ÙÙ‚ Ù…Ø´ØªØ±Ùƒ"
BTN_USE_OWN    = "ğŸ–¼ï¸ Ù…Ø±ÙÙ‚Ø§Øª Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø³Ø¤Ø§Ù„"
BTN_USE_NONE   = "âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª"

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID
async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±/Ø§Ù„Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", reply_markup=owner_kb()); return False
    return True
def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"
def slug(s:str)->str:
    s=re.sub(r"\s+","-",s.strip()); s=re.sub(r"[^\w\-]+","",s,flags=re.U); return s[:50] or "quiz"

# --- Ø­Ø§Ø±Ø³ Ø¹Ø§Ù… Ù„ØºÙŠØ± Ø§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø· ---
ADMIN_PREFIX = ("addq","editq","delq","merge_","exportq","pub","dur","sethl","briefdur","pickbundle","attach_mode")
@dp.callback_query(
    F.from_user.id != OWNER_ID,
    F.data.regexp(r"^(addq|editq|delq|merge_|exportq|pub|dur|sethl|briefdur|pickbundle|attach_mode)")
)
async def admin_cb_guard(cb: CallbackQuery):
    await cb.answer("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", show_alert=True)

# ---------- Bands & AI ----------
SCHREIBEN_BANDS=[(0,6,"Unter A2"),(7,14,"A2"),(15,20,"B1")]
HL_BANDS=[(0,19,"Unter A2"),(20,32,"A2"),(33,45,"B1")]
def map_level(score:int,bands)->str:
    for lo,hi,name in bands:
        if lo<=score<=hi: return name
    return bands[-1][2]

client=None
if OPENAI_API_KEY and OpenAI:
    try: client=OpenAI(api_key=OPENAI_API_KEY)
    except Exception: client=None

async def ai_grade(text: str) -> Tuple[int, str, Dict]:
    if not client:
        base = min(20, max(0, len(text) // 35))
        return base, map_level(base, SCHREIBEN_BANDS), {"note": "fallback heuristic (no OPENAI_API_KEY)"}
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            temperature=0.3,
            messages=[
                {"role":"system","content":"You are a certified Goethe/DTZ examiner. Grade B1 Schreiben (Brief/E-Mail) on a 0â€“20 scale (task fulfilment, coherence, range, accuracy, register). Return JSON: {\"score\":<int>,\"feedback\":\"<Arabic short>\"}."},
                {"role":"user","content":text},
            ],
            response_format={"type":"json_object"},
        )
        raw = resp.choices[0].message.content or "{}"
        try: data = json.loads(raw)
        except Exception: data = {}
        score = int(max(0, min(20, int(data.get("score", 0)))))
        level = map_level(score, SCHREIBEN_BANDS)
        return score, level, data
    except Exception as e:
        base = min(20, max(0, len(text) // 40))
        return base, map_level(base, SCHREIBEN_BANDS), {"error": str(e)}

# ---------- States ----------
class BuildStates(StatesGroup):
    waiting_title=State()
    waiting_pick_quiz_for_addq=State()
    waiting_q_text=State()
    waiting_attach_mode=State()
    waiting_q_attachments=State()
    waiting_pick_bundle_for_q=State()
    waiting_options_count=State()
    waiting_option_text=State()
    waiting_correct_index=State()
    waiting_pick_quiz_generic=State()
    waiting_edit_quiz_title=State()

class PublishStates(StatesGroup):
    waiting_pick_quiz=State()
    waiting_duration_choice=State()
    waiting_custom_hours=State()

class MergeStates(StatesGroup):
    waiting_pick_src=State()
    waiting_pick_dst=State()

class ExportStates(StatesGroup):
    waiting_pick_quiz=State()

class ImportStates(StatesGroup):
    waiting_json=State()

class HLStates(StatesGroup):
    waiting_pick_quiz=State()

class BriefStates(StatesGroup):
    waiting_prompt=State()
    waiting_duration=State()
    waiting_custom=State()

class BundleStates(StatesGroup):
    waiting_pick_quiz_for_bundle=State()
    waiting_bundle_files=State()

# ---------- Keyboards ----------
def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_LISTQ)],
        [KeyboardButton(text=BTN_EDITQUIZ), KeyboardButton(text=BTN_DELQUIZ)],
        [KeyboardButton(text=BTN_BUNDLES), KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_IMPORT), KeyboardButton(text=BTN_EXPORT)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_HL_PROFILE), KeyboardButton(text=BTN_LEVEL)],
        [KeyboardButton(text=BTN_BRIEF), KeyboardButton(text=BTN_WIPE_ALL)],
    ]; return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)

def attach_mode_kb() -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    kb.button(text=BTN_USE_BUNDLE, callback_data="attach_mode:bundle")
    kb.button(text=BTN_USE_OWN, callback_data="attach_mode:own")
    kb.button(text=BTN_USE_NONE, callback_data="attach_mode:none")
    kb.adjust(1); return kb

def done_button_kb(tag: str) -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"done:{tag}")
    return kb

def paged_quizzes_kb(page:int=0, tag:str="pickq", per:int=8):
    rows=q_all("SELECT id,title FROM quizzes WHERE is_archived=0 ORDER BY id DESC")
    start=page*per; chunk=rows[start:start+per]
    kb=InlineKeyboardBuilder()
    for r in chunk: kb.button(text=f"âœ… ID {r['id']} â€” {r['title']}", callback_data=f"{tag}:{r['id']}")
    kb.adjust(1); kb.row()
    if start>0: kb.button(text="â¬…ï¸", callback_data=f"{tag}_page:{page-1}")
    kb.button(text=f"ØµÙØ­Ø© {page+1}", callback_data="noop")
    if start+per<len(rows): kb.button(text="â¡ï¸", callback_data=f"{tag}_page:{page+1}")
    return kb.as_markup()

def paged_bundles_kb(quiz_id:int, page:int=0, tag:str="pickbundle", per:int=8):
    rows=q_all("SELECT id FROM media_bundles WHERE quiz_id=%s ORDER BY id DESC",(quiz_id,))
    start=page*per; chunk=rows[start:start+per]
    kb=InlineKeyboardBuilder()
    for r in chunk:
        att_cnt=q_one("SELECT COUNT(*) AS c FROM media_bundle_attachments WHERE bundle_id=%s",(r["id"],))["c"]
        q_cnt =q_one("SELECT COUNT(*) AS c FROM questions WHERE media_bundle_id=%s",(r["id"],))["c"]
        kb.button(text=f"ğŸ“ Ø­Ø²Ù…Ø© {r['id']} â€” Ù…Ù„ÙØ§Øª:{att_cnt} / Ø£Ø³Ø¦Ù„Ø©:{q_cnt}", callback_data=f"{tag}:{quiz_id}:{r['id']}")
    kb.adjust(1); kb.row()
    if start>0: kb.button(text="â¬…ï¸", callback_data=f"{tag}_page:{quiz_id}:{page-1}")
    kb.button(text=f"ØµÙØ­Ø© {page+1}", callback_data="noop")
    if start+per<len(rows): kb.button(text="â¡ï¸", callback_data=f"{tag}_page:{quiz_id}:{page+1}")
    return kb.as_markup()

# ---------- Attachments helpers ----------
def get_question_atts(question_id:int)->List[dict]:
    return q_all("SELECT kind,file_id,position FROM question_attachments WHERE question_id=%s ORDER BY position",(question_id,))

def get_bundle_atts(bundle_id:int)->List[dict]:
    return q_all("SELECT kind,file_id,position FROM media_bundle_attachments WHERE bundle_id=%s ORDER BY position",(bundle_id,))

async def send_attachments(chat_id:int, atts:List[dict]):
    for a in atts:
        try:
            if a["kind"]=="photo":   await bot.send_photo(chat_id, a["file_id"])
            elif a["kind"]=="voice": await bot.send_voice(chat_id, a["file_id"])
            elif a["kind"]=="audio": await bot.send_audio(chat_id, a["file_id"])
        except Exception: pass
        await asyncio.sleep(0.2)

# ---------- /start ----------
@dp.message(Command("start"))
async def start(msg:Message):
    if is_owner(msg.from_user.id):
        await msg.answer("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¬Ø§Ù‡Ø²Ø© â€” Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:", reply_markup=owner_kb())
    else:
        await msg.answer("Ø£Ù‡Ù„Ù‹Ø§! Ù‡Ø°Ø§ Ø¨ÙˆØª Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¹Ù„Ù….\nØ£Ø¬Ø¨ Ø¹Ø¨Ø± Ø§Ø³ØªÙØªØ§Ø¡Ø§Øª Quiz Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.")

@dp.message(Command("dbinfo"))
async def dbinfo(msg:Message):
    qz=q_one("SELECT COUNT(*) AS n FROM quizzes")["n"]; qs=q_one("SELECT COUNT(*) AS n FROM questions")["n"]; rs=q_one("SELECT COUNT(*) AS n FROM responses")["n"]
    await msg.answer(f"ğŸ—„ï¸ DB: PostgreSQL\nğŸ§ª Quizzes: <b>{qz}</b> â€” Questions: <b>{qs}</b> â€” Responses: <b>{rs}</b>")

# Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø¬ÙˆØ¹
@dp.message(F.text == BTN_BACK_HOME)
async def back_home(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("ØªÙ… Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©.", reply_markup=owner_kb())

@dp.message(F.text == BTN_BACK_STEP)
async def back_step(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("Ø±Ø¬Ø¹Ù†Ø§ Ø®Ø·ÙˆØ© (ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·).", reply_markup=owner_kb())

# ---------- Ø¥Ù†Ø´Ø§Ø¡/Ø¹Ø±Ø¶/ØªØ¹Ø¯ÙŠÙ„/Ø­Ø°Ù ----------
@dp.message(F.text==BTN_NEWQUIZ)
async def new_quiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_title); await msg.answer("Ø£Ø±Ø³Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:")

@dp.message(BuildStates.waiting_title, F.text)
async def got_title(msg:Message, state:FSMContext):
    q_exec("INSERT INTO quizzes(title,created_by,created_at) VALUES (%s,%s,%s)",(msg.text.strip(),msg.from_user.id,_now().isoformat()))
    await state.clear(); await msg.answer("âœ… ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡.", reply_markup=owner_kb())

@dp.message(F.text==BTN_LISTQUIZ)
async def list_quizzes(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title,is_archived FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.")
    await msg.answer("\n".join(["ğŸ“š <b>Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª</b>:"]+[f"â€¢ {r['id']}: {html.escape(r['title'])}{' (Ù…Ø¤Ø±Ø´Ù)' if r['is_archived'] else ''}" for r in rows]))

@dp.message(F.text==BTN_EDITQUIZ)
async def edit_quiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_quiz_generic)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:", reply_markup=paged_quizzes_kb(tag="editq"))

@dp.callback_query(F.data.startswith("editq_page:"))
async def editq_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="editq")); await cb.answer()

@dp.callback_query(F.data.startswith("editq:"))
async def editq_pick(cb:CallbackQuery, state:FSMContext):
    await state.update_data(edit_id=int(cb.data.split(":")[1])); await state.set_state(BuildStates.waiting_edit_quiz_title)
    await cb.message.answer("Ø£Ø±Ø³Ù„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯:"); await cb.answer()

@dp.message(BuildStates.waiting_edit_quiz_title, F.text)
async def apply_edit(msg:Message, state:FSMContext):
    q_exec("UPDATE quizzes SET title=%s WHERE id=%s",(msg.text.strip(),(await state.get_data())["edit_id"]))
    await state.clear(); await msg.answer("âœ… ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„.")

@dp.message(F.text==BTN_DELQUIZ)
async def del_quiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_quiz_generic)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„Ù„Ø­Ø°Ù:", reply_markup=paged_quizzes_kb(tag="delq"))

@dp.callback_query(F.data.startswith("delq_page:"))
async def delq_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="delq")); await cb.answer()

@dp.callback_query(F.data.startswith("delq:"))
async def delq_do(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    q_exec("DELETE FROM options WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)",(qid,))
    q_exec("DELETE FROM question_attachments WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)",(qid,))
    q_exec("DELETE FROM questions WHERE quiz_id=%s",(qid,))
    q_exec("DELETE FROM media_bundle_attachments WHERE bundle_id IN (SELECT id FROM media_bundles WHERE quiz_id=%s)",(qid,))
    q_exec("DELETE FROM media_bundles WHERE quiz_id=%s",(qid,))
    q_exec("DELETE FROM sent_polls WHERE quiz_id=%s",(qid,))
    q_exec("DELETE FROM participant_names WHERE quiz_id=%s",(qid,))
    q_exec("DELETE FROM quizzes WHERE id=%s",(qid,))
    await state.clear(); await cb.message.answer("ğŸ—‘ï¸ ØªÙ… Ø§Ù„Ø­Ø°Ù."); await cb.answer()

# ---------- Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ + Ù…Ø±ÙÙ‚Ø§Øª ----------
@dp.message(F.text==BTN_ADDQ)
async def addq_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_quiz_for_addq)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„:", reply_markup=paged_quizzes_kb(tag="addq"))

@dp.callback_query(F.data.startswith("addq_page:"))
async def addq_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="addq")); await cb.answer()

@dp.callback_query(F.data.startswith("addq:"))
async def addq_pick(cb:CallbackQuery, state:FSMContext):
    await state.update_data(quiz_id=int(cb.data.split(":")[1])); await state.set_state(BuildStates.waiting_q_text)
    await cb.message.answer("Ø£Ø±Ø³Ù„ Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„:"); await cb.answer()

@dp.message(BuildStates.waiting_q_text, F.text)
async def q_text(msg:Message, state:FSMContext):
    qid=(await state.get_data())["quiz_id"]; text=msg.text.strip()
    q_exec("INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",(qid,text,_now().isoformat()))
    new=q_one("SELECT id FROM questions WHERE quiz_id=%s ORDER BY id DESC LIMIT 1",(qid,))["id"]
    await state.update_data(question_id=new)
    kb = attach_mode_kb()
    await state.set_state(BuildStates.waiting_attach_mode)
    await msg.answer("Ø§Ø®ØªÙØ± ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("attach_mode:"))
async def choose_attach_mode(cb:CallbackQuery, state:FSMContext):
    mode=cb.data.split(":")[1]
    d=await state.get_data(); quiz_id=d["quiz_id"]
    if mode=="none":
        await state.set_state(BuildStates.waiting_options_count)
        return await cb.message.answer("ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§ØªØŸ (2..10)")
    if mode=="own":
        await state.update_data(att_pos=0)
        await state.set_state(BuildStates.waiting_q_attachments)
        await cb.message.answer("Ø£Ø±Ø³Ù„ Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ (ØµÙˆØ±/ÙÙˆÙŠØ³/Ø£ÙˆØ¯ÙŠÙˆ). Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ….",
                                reply_markup=done_button_kb("qatt").as_markup())
        return await cb.answer()
    if mode=="bundle":
        await state.set_state(BuildStates.waiting_pick_bundle_for_q)
        await cb.message.answer("Ø§Ø®ØªØ± Ø­Ø²Ù…Ø© Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ© (Ø£Ùˆ Ø£Ù†Ø´Ø¦ ÙˆØ§Ø­Ø¯Ø© Ù…Ù† Ø²Ø± ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©):",
                                reply_markup=paged_bundles_kb(quiz_id, tag="pickbundle"))
        return await cb.answer()

@dp.callback_query(F.data.startswith("pickbundle_page:"))
async def pickbundle_page(cb:CallbackQuery, state:FSMContext):
    _,quiz_id,page=cb.data.split(":")
    await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø­Ø²Ù…Ø©:", reply_markup=paged_bundles_kb(int(quiz_id), int(page), tag="pickbundle"))
    await cb.answer()

@dp.callback_query(F.data.startswith("pickbundle:"))
async def pickbundle_apply(cb:CallbackQuery, state:FSMContext):
    _,quiz_id,bundle_id=cb.data.split(":")
    qid=(await state.get_data())["question_id"]
    q_exec("UPDATE questions SET media_bundle_id=%s WHERE id=%s",(int(bundle_id), qid))
    await state.set_state(BuildStates.waiting_options_count)
    await cb.message.answer("ØªÙ… Ø±Ø¨Ø· Ø§Ù„Ø­Ø²Ù…Ø©. ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§ØªØŸ (2..10)")
    await cb.answer()

# Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ (own)
@dp.message(BuildStates.waiting_q_attachments, F.photo)
async def qatt_photo(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("att_pos",0))
    file_id = msg.photo[-1].file_id
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(qid,"photo",file_id,pos))
    await state.update_data(att_pos=pos+1)

@dp.message(BuildStates.waiting_q_attachments, F.voice)
async def qatt_voice(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("att_pos",0))
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(qid,"voice",msg.voice.file_id,pos))
    await state.update_data(att_pos=pos+1)

@dp.message(BuildStates.waiting_q_attachments, F.audio)
async def qatt_audio(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("att_pos",0))
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(qid,"audio",msg.audio.file_id,pos))
    await state.update_data(att_pos=pos+1)

@dp.callback_query(F.data=="done:qatt")
async def qatt_done(cb:CallbackQuery, state:FSMContext):
    await state.set_state(BuildStates.waiting_options_count)
    await cb.message.answer("ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª. ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§ØªØŸ (2..10)")
    await cb.answer()

# Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø­ØªÙ‰ 10)
@dp.message(BuildStates.waiting_options_count, F.text.regexp(r"^\d{1,2}$"))
async def q_opts_count(msg:Message, state:FSMContext):
    n=int(msg.text)
    if not (2<=n<=10): return await msg.answer("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø±Ù‚Ù… Ø¨ÙŠÙ† 2 Ùˆ 10.")
    await state.update_data(opt_count=n,opt_collected=0); await state.set_state(BuildStates.waiting_option_text)
    await msg.answer(f"Ø£Ø±Ø³Ù„ Ù†Øµ Ø§Ù„Ø®ÙŠØ§Ø± 1/{n}:")

@dp.message(BuildStates.waiting_option_text, F.text)
async def q_opt_text(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; cnt=d["opt_count"]; k=d["opt_collected"]
    q_exec("INSERT INTO options(question_id,option_index,text) VALUES (%s,%s,%s)",(qid,k,msg.text.strip()))
    k+=1; await state.update_data(opt_collected=k)
    if k<cnt: await msg.answer(f"Ø£Ø±Ø³Ù„ Ù†Øµ Ø§Ù„Ø®ÙŠØ§Ø± {k+1}/{cnt}:")
    else: await state.set_state(BuildStates.waiting_correct_index); await msg.answer(f"Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ (1..{cnt}):")

@dp.message(BuildStates.waiting_correct_index, F.text.regexp(r"^\d+$"))
async def q_correct(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; cnt=d["opt_count"]; i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚.")
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear(); await msg.answer("âœ… ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø³Ø¤Ø§Ù„.", reply_markup=owner_kb())

# ---------- Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ----------
@dp.message(F.text==BTN_LISTQ)
async def listq(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_quiz_generic)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(tag="listq"))

@dp.callback_query(F.data.startswith("listq_page:"))
async def listq_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="listq")); await cb.answer()

@dp.callback_query(F.data.startswith("listq:"))
async def listq_show(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    rows=q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id",(qid,))
    if not rows: await cb.message.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø³Ø¦Ù„Ø©."); await cb.answer(); return
    out=["ğŸ“– Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:"]
    for r in rows:
        opts=q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(r["id"],))
        out.append(f"Q{r['id']}: {r['text']}" + "".join([f"\n   {chr(0x61+o['option_index'])}) {o['text']}{' âœ…' if o['is_correct'] else ''}" for o in opts]))
    await cb.message.answer("\n".join(out)); await cb.answer(); await state.clear()

# ---------- Bundles (Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©) ----------
@dp.message(F.text==BTN_BUNDLES)
async def bundles_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BundleStates.waiting_pick_quiz_for_bundle)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø²Ù…:", reply_markup=paged_quizzes_kb(tag="bundq"))

@dp.callback_query(F.data.startswith("bundq_page:"))
async def bundq_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="bundq")); await cb.answer()

@dp.callback_query(F.data.startswith("bundq:"))
async def bundq_pick(cb:CallbackQuery, state:FSMContext):
    await state.update_data(bundle_quiz_id=int(cb.data.split(":")[1]))
    q_exec("INSERT INTO media_bundles(quiz_id,created_at) VALUES (%s,%s)",((await state.get_data())["bundle_quiz_id"], _now().isoformat()))
    bid=q_one("SELECT id FROM media_bundles WHERE quiz_id=%s ORDER BY id DESC LIMIT 1",((await state.get_data())["bundle_quiz_id"],))["id"]
    await state.update_data(active_bundle_id=bid, bundle_pos=0)
    await state.set_state(BundleStates.waiting_bundle_files)
    await cb.message.answer(f"ğŸ“ Ø­Ø²Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø±Ù‚Ù… {bid}. Ø£Ø±Ø³Ù„ ØµÙˆØ±/ÙÙˆÙŠØ³/Ø£ÙˆØ¯ÙŠÙˆ. Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ….",
                            reply_markup=done_button_kb("bundle").as_markup())
    await cb.answer()

@dp.message(BundleStates.waiting_bundle_files, F.photo)
async def bundle_photo(msg:Message, state:FSMContext):
    bid=(await state.get_data())["active_bundle_id"]; pos=int((await state.get_data()).get("bundle_pos",0))
    q_exec("INSERT INTO media_bundle_attachments(bundle_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(bid,"photo",msg.photo[-1].file_id,pos))
    await state.update_data(bundle_pos=pos+1)

@dp.message(BundleStates.waiting_bundle_files, F.voice)
async def bundle_voice(msg:Message, state:FSMContext):
    bid=(await state.get_data())["active_bundle_id"]; pos=int((await state.get_data()).get("bundle_pos",0))
    q_exec("INSERT INTO media_bundle_attachments(bundle_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(bid,"voice",msg.voice.file_id,pos))
    await state.update_data(bundle_pos=pos+1)

@dp.message(BundleStates.waiting_bundle_files, F.audio)
async def bundle_audio(msg:Message, state:FSMContext):
    bid=(await state.get_data())["active_bundle_id"]; pos=int((await state.get_data()).get("bundle_pos",0))
    q_exec("INSERT INTO media_bundle_attachments(bundle_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(bid,"audio",msg.audio.file_id,pos))
    await state.update_data(bundle_pos=pos+1)

@dp.callback_query(F.data=="done:bundle")
async def bundle_done(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    await state.clear()
    await cb.message.answer(f"âœ… ØªÙ… Ø­ÙØ¸ Ø­Ø²Ù…Ø© {d.get('active_bundle_id')}.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Ø¯Ù…Ø¬ ----------
@dp.message(F.text==BTN_MERGE)
async def merge_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(MergeStates.waiting_pick_src)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…ØµØ¯Ø±:", reply_markup=paged_quizzes_kb(tag="merge_src"))

@dp.callback_query(F.data.startswith("merge_src_page:"))
async def merge_src_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ù…ØµØ¯Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="merge_src")); await cb.answer()

@dp.callback_query(F.data.startswith("merge_src:"))
async def merge_src_pick(cb:CallbackQuery, state:FSMContext):
    await state.update_data(src=int(cb.data.split(":")[1])); await state.set_state(MergeStates.waiting_pick_dst)
    await cb.message.answer("Ø§Ø®ØªØ± Ø§Ù„Ù‡Ø¯Ù:", reply_markup=paged_quizzes_kb(tag="merge_dst")); await cb.answer()

@dp.callback_query(F.data.startswith("merge_dst_page:"))
async def merge_dst_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ù‡Ø¯Ù:", reply_markup=paged_quizzes_kb(page=int(p), tag="merge_dst")); await cb.answer()

@dp.callback_query(F.data.startswith("merge_dst:"))
async def merge_do(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data(); src=int(d["src"]); dst=int(cb.data.split(":")[1])
    if src==dst: return await cb.answer("Ø§Ù„Ù…ØµØ¯Ø± ÙˆØ§Ù„Ù‡Ø¯Ù Ù†ÙØ³Ù‡Ù…Ø§.", show_alert=True)
    qs=q_all("SELECT id,text,created_at,media_bundle_id FROM questions WHERE quiz_id=%s ORDER BY id",(src,))
    for r in qs:
        q_exec("INSERT INTO questions(quiz_id,text,created_at,media_bundle_id) VALUES (%s,%s,%s,%s)",(dst,r["text"],r["created_at"],r["media_bundle_id"]))
        nq=q_one("SELECT id FROM questions WHERE quiz_id=%s ORDER BY id DESC LIMIT 1",(dst,))["id"]
        for o in q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(r["id"],)):
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(nq,o["option_index"],o["text"],o["is_correct"]))
        for a in q_all("SELECT kind,file_id,position FROM question_attachments WHERE question_id=%s ORDER BY position",(r["id"],)):
            q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(nq,a["kind"],a["file_id"],a["position"]))
    q_exec("UPDATE quizzes SET is_archived=1 WHERE id=%s",(src,))
    await state.clear(); await cb.message.answer(f"âœ… ØªÙ… Ù†Ù‚Ù„ {len(qs)} Ø³Ø¤Ø§Ù„Ù‹Ø§ ÙˆØ£Ø±Ø´ÙØ© Ø§Ù„Ù…ØµØ¯Ø±."); await cb.answer()

# ---------- ØªØµØ¯ÙŠØ±/Ø§Ø³ØªÙŠØ±Ø§Ø¯ ----------
def build_export_payload(quiz_id:int)->Dict:
    qz=q_one("SELECT id,title,created_by,created_at,grading_profile FROM quizzes WHERE id=%s",(quiz_id,))
    qs=q_all("SELECT id,text,created_at,media_bundle_id FROM questions WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    out=[]
    for r in qs:
        opts=q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(r["id"],))
        atts=get_question_atts(r["id"])
        out.append({"id":r["id"],"text":r["text"],"created_at":r["created_at"],"media_bundle_id":r["media_bundle_id"],
                    "options":[dict(o) for o in opts],"attachments":[dict(a) for a in atts]})
    bundles=q_all("SELECT id,created_at FROM media_bundles WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    b=[]
    for mb in bundles:
        mb_at=get_bundle_atts(mb["id"])
        b.append({"id":mb["id"],"created_at":mb["created_at"],"attachments":[dict(x) for x in mb_at]})
    return {"quiz":dict(qz),"questions":out,"bundles":b,"exported_at":_now().isoformat(),"version":1}

@dp.message(F.text==BTN_EXPORT)
async def export_btn(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(ExportStates.waiting_pick_quiz); await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„Ù„ØªØµØ¯ÙŠØ±:", reply_markup=paged_quizzes_kb(tag="exportq"))

@dp.callback_query(F.data.startswith("exportq_page:"))
async def export_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="exportq")); await cb.answer()

@dp.callback_query(F.data.startswith("exportq:"))
async def export_do(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1]); payload=build_export_payload(qid)
    fname=f"quiz_{qid}_{slug(payload['quiz']['title'])}.json"; path=f"/tmp/{fname}"
    with open(path,"w",encoding="utf-8") as f: json.dump(payload,f,ensure_ascii=False,indent=2)
    try: await cb.message.answer_document(FSInputFile(path), caption="ØªÙ… Ø§Ù„ØªØµØ¯ÙŠØ± âœ…")
    except Exception as e:
        await cb.message.answer(f"ØªØ¹Ø°Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù: {e}\nØ³Ø£Ø±Ø³Ù„ JSON Ù…Ø¨Ø§Ø´Ø±Ø©:"); await cb.message.answer(f"<pre>{html.escape(json.dumps(payload,ensure_ascii=False,indent=2))}</pre>")
    await state.clear(); await cb.answer()

@dp.message(F.text==BTN_IMPORT)
async def import_btn(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(ImportStates.waiting_json); await msg.answer("Ø£Ø±Ø³Ù„ Ù…Ù„Ù JSON Ø£Ùˆ Ø£Ù„ØµÙ‚ JSON Ù…Ø¨Ø§Ø´Ø±Ø©:")

@dp.message(ImportStates.waiting_json, F.document)
async def import_file(msg:Message, state:FSMContext):
    f=await bot.get_file(msg.document.file_id); path=f"/tmp/{msg.document.file_unique_id}.json"
    await bot.download_file(f.file_path, destination=path)
    with open(path,"r",encoding="utf-8") as fp: payload=json.load(fp)
    await perform_import(msg,payload,state)

@dp.message(ImportStates.waiting_json, F.text)
async def import_text(msg:Message, state:FSMContext):
    try: payload=json.loads(msg.text)
    except Exception: return await msg.answer("JSON ØºÙŠØ± ØµØ§Ù„Ø­.")
    await perform_import(msg,payload,state)

async def perform_import(msg:Message, payload:Dict, state:FSMContext):
    qz=payload["quiz"]; title=qz["title"]
    q_exec("INSERT INTO quizzes(title,created_by,created_at,grading_profile) VALUES (%s,%s,%s,%s)",
           (title,msg.from_user.id,_now().isoformat(),qz.get("grading_profile","NONE")))
    new_qid=q_one("SELECT id FROM quizzes ORDER BY id DESC LIMIT 1")["id"]
    for b in payload.get("bundles",[]):
        q_exec("INSERT INTO media_bundles(quiz_id,created_at) VALUES (%s,%s)",(new_qid,b.get("created_at",_now().isoformat())))
        nb=q_one("SELECT id FROM media_bundles WHERE quiz_id=%s ORDER BY id DESC LIMIT 1",(new_qid,))["id"]
        for a in b.get("attachments",[]): q_exec("INSERT INTO media_bundle_attachments(bundle_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(nb,a["kind"],a["file_id"],a["position"]))
    for qu in payload.get("questions",[]):
        q_exec("INSERT INTO questions(quiz_id,text,created_at,media_bundle_id) VALUES (%s,%s,%s,%s)",(new_qid,qu["text"],qu.get("created_at",_now().isoformat()),qu.get("media_bundle_id")))
        nq=q_one("SELECT id FROM questions WHERE quiz_id=%s ORDER BY id DESC LIMIT 1",(new_qid,))["id"]
        for o in qu.get("options",[]): q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(nq,o["option_index"],o["text"],o["is_correct"]))
        for a in qu.get("attachments",[]): q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(nq,a["kind"],a["file_id"],a["position"]))
    await state.clear(); await msg.answer(f"âœ… ØªÙ… Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¥Ù„Ù‰ Ø§Ø®ØªØ¨Ø§Ø± Ø¬Ø¯ÙŠØ¯: {new_qid}")

# ---------- Ù†Ø´Ø± + Ù…Ø±ÙÙ‚Ø§Øª ----------
def dur_kb():
    kb=InlineKeyboardBuilder()
    kb.button(text="â±ï¸ 12 Ø³Ø§Ø¹Ø©", callback_data="dur:12")
    kb.button(text="â±ï¸ 24 Ø³Ø§Ø¹Ø©", callback_data="dur:24")
    kb.button(text="â±ï¸ Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ", callback_data="dur:custom")
    kb.button(text="â™¾ï¸ Ø¨Ù„Ø§ ÙˆÙ‚Øª", callback_data="dur:none")
    kb.adjust(2); return kb.as_markup()

@dp.message(F.text==BTN_PUBLISH)
async def pub_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(PublishStates.waiting_pick_quiz)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„Ù„Ù†Ø´Ø±:", reply_markup=paged_quizzes_kb(tag="pub"))

@dp.callback_query(F.data.startswith("pub_page:"))
async def pub_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="pub")); await cb.answer()

@dp.callback_query(F.data.startswith("pub:"))
async def pub_pick(cb:CallbackQuery, state:FSMContext):
    await state.update_data(pub_qid=int(cb.data.split(":")[1])); await state.set_state(PublishStates.waiting_duration_choice)
    await cb.message.answer("Ø§Ø®ØªØ± Ù…Ø¯Ø© Ø§Ù„Ø¥ØºÙ„Ø§Ù‚:", reply_markup=dur_kb()); await cb.answer()

@dp.callback_query(F.data.startswith("dur:"))
async def pub_duration(cb:CallbackQuery, state:FSMContext):
    action=cb.data.split(":")[1]
    if action=="custom":
        await state.set_state(PublishStates.waiting_custom_hours); await cb.message.answer("ÙƒÙ… Ø³Ø§Ø¹Ø©ØŸ (Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­)"); return await cb.answer()
    hours=None if action=="none" else int(action)
    await do_publish(cb.message.chat.id, (await state.get_data())["pub_qid"], hours)
    await state.clear(); await cb.answer()

@dp.message(PublishStates.waiting_custom_hours, F.text.regexp(r"^\d{1,3}$"))
async def pub_custom(msg:Message, state:FSMContext):
    await do_publish(msg.chat.id, (await state.get_data())["pub_qid"], int(msg.text)); await state.clear()

async def do_publish(chat_id:int, quiz_id:int, hours:Optional[int]):
    qs=q_all("SELECT id,text,media_bundle_id FROM questions WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    if not qs: return await bot.send_message(chat_id,"Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø³Ø¦Ù„Ø©.")
    expires=(_now()+timedelta(hours=hours)).isoformat() if hours is not None else None
    sent=0
    for idx,r in enumerate(qs,1):
        try:
            atts=get_question_atts(r["id"])
            if not atts and r["media_bundle_id"]:
                atts=get_bundle_atts(r["media_bundle_id"])
            if atts:
                await send_attachments(chat_id, atts)
            opts=q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(r["id"],))
            options=[o["text"] for o in opts]
            if not options: continue
            correct=next((o["option_index"] for o in opts if o["is_correct"]),0)
            kb=InlineKeyboardBuilder(); kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"done:{quiz_id}:{r['id']}")
            m=await bot.send_poll(chat_id, question=f"{idx}. {r['text']}", options=options, type=PollType.QUIZ,
                                  correct_option_id=correct, is_anonymous=False, reply_markup=kb.as_markup())
            q_exec("""INSERT INTO sent_polls(chat_id,quiz_id,question_id,poll_id,message_id,expires_at,is_closed)
                      VALUES (%s,%s,%s,%s,%s,%s,0)""",(chat_id,quiz_id,r["id"],m.poll.id,m.message_id,expires))
            sent+=1; await asyncio.sleep(0.6)
        except TelegramRetryAfter as e:
            await asyncio.sleep(int(e.retry_after)+1)
        except TelegramBadRequest as e:
            await bot.send_message(chat_id, f"ØªØ¹Ø°Ù‘Ø± Ù†Ø´Ø± Ø³Ø¤Ø§Ù„: {e.message}")
    await bot.send_message(chat_id, f"ğŸš€ ØªÙ… Ù†Ø´Ø± {sent} Ø³Ø¤Ø§Ù„Ù‹Ø§.")

@dp.callback_query(F.data.startswith("done:"))
async def cb_done(cb:CallbackQuery):
    await cb.answer("ØªÙ… ğŸ‘", show_alert=False)

# ---------- Ø¥ØºÙ„Ø§Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠ ----------
async def auto_closer():
    while True:
        try:
            rows=q_all("SELECT id,chat_id,message_id,expires_at,is_closed FROM sent_polls WHERE expires_at IS NOT NULL AND is_closed=0")
            now=_now().isoformat()
            for r in rows:
                if r["expires_at"]<=now:
                    try: await bot.stop_poll(r["chat_id"], r["message_id"])
                    except Exception: pass
                    q_exec("UPDATE sent_polls SET is_closed=1 WHERE id=%s",(r["id"],))
        except Exception: pass
        await asyncio.sleep(30)

# ---------- Poll answers ----------
@dp.poll_answer()
async def on_poll_answer(pa:PollAnswer):
    pid=pa.poll_id; uid=pa.user.id
    sp=q_one("SELECT chat_id,quiz_id,question_id FROM sent_polls WHERE poll_id=%s",(pid,))
    if not sp: return
    chat_id,quiz_id,qid=sp["chat_id"],sp["quiz_id"],sp["question_id"]
    chosen=pa.option_ids[0] if pa.option_ids else -1
    ok=q_one("SELECT is_correct FROM options WHERE question_id=%s AND option_index=%s",(qid,chosen))
    is_ok=int(ok["is_correct"]) if ok else 0
    q_exec("""INSERT INTO responses(chat_id,user_id,question_id,option_index,is_correct,answered_at)
              VALUES (%s,%s,%s,%s,%s,%s)
              ON CONFLICT (chat_id,user_id,question_id) DO NOTHING""",(chat_id,uid,qid,chosen,is_ok,_now().isoformat()))
    q_exec("""INSERT INTO participant_names(origin_chat_id,user_id,quiz_id,name)
              VALUES (%s,%s,%s,%s)
              ON CONFLICT (origin_chat_id,user_id,quiz_id) DO UPDATE SET name=EXCLUDED.name""",
           (chat_id,uid,quiz_id,hname(pa.user)))

# ---------- Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ----------
@dp.message(F.text==BTN_SCORE)
async def scoreboard(msg:Message):
    if not await ensure_owner(msg): return
    row=q_one("SELECT id,title,grading_profile FROM quizzes WHERE is_archived=0 ORDER BY id DESC LIMIT 1")
    if not row: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.")
    quiz_id,title,prof=row["id"],row["title"],row["grading_profile"]
    data=q_all("""SELECT r.user_id, COALESCE(SUM(r.is_correct),0) AS correct, COUNT(r.question_id) AS answered,
                         COALESCE(MAX(pn.name),'') AS name
                  FROM responses r
                  JOIN questions q ON q.id=r.question_id AND q.quiz_id=%s
                  LEFT JOIN participant_names pn ON pn.origin_chat_id=r.chat_id AND pn.user_id=r.user_id AND pn.quiz_id=%s
                  GROUP BY r.user_id ORDER BY correct DESC""",(quiz_id,quiz_id))
    total=q_one("SELECT COUNT(*) AS n FROM questions WHERE quiz_id=%s",(quiz_id,))["n"]
    lines=[f"ğŸ† <b>Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ â€” {html.escape(title)}</b>"]
    for i,r in enumerate(data,1):
        name=r["name"] or f"UID {r['user_id']}"; correct=int(r["correct"] or 0); answered=int(r["answered"] or 0)
        lines.append(f"{i}. {html.escape(name)}: <b>{correct}</b>/{answered if answered else total}")
    await msg.answer("\n".join(lines))

# ---------- HÃ¶ren & Lesen ØªØ¹ÙŠÙŠÙ† ----------
@dp.message(F.text==BTN_HL_PROFILE)
async def hl_set(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(HLStates.waiting_pick_quiz)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„ØªØ¹ÙŠÙŠÙ†Ù‡ HÃ¶ren & Lesen:", reply_markup=paged_quizzes_kb(tag="sethl"))

@dp.callback_query(F.data.startswith("sethl_page:"))
async def sethl_page(cb:CallbackQuery, state:FSMContext):
    _,p=cb.data.split(":"); await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(p), tag="sethl")); await cb.answer()

@dp.callback_query(F.data.startswith("sethl:"))
async def sethl_do(cb:CallbackQuery, state:FSMContext):
    q_exec("UPDATE quizzes SET grading_profile='HL_B1_DTZ' WHERE id=%s",(int(cb.data.split(":")[1]),))
    await state.clear(); await cb.message.answer("âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† HÃ¶ren & Lesen."); await cb.answer()

# ---------- Schreiben (Ø¨Ø±ÙŠÙ) ----------
@dp.message(F.text==BTN_BRIEF)
async def brief_admin(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BriefStates.waiting_prompt)
    await msg.answer("âœï¸ Ø£Ø±Ø³Ù„ Ù†Øµ Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ/Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ (B1 DTZ):")

@dp.message(BriefStates.waiting_prompt, F.text)
async def brief_prompt(msg:Message, state:FSMContext):
    await state.update_data(prompt=msg.text.strip())
    kb=InlineKeyboardBuilder()
    kb.button(text="â±ï¸ 15 Ø¯Ù‚ÙŠÙ‚Ø©", callback_data="briefdur:15")
    kb.button(text="â±ï¸ 30 Ø¯Ù‚ÙŠÙ‚Ø©", callback_data="briefdur:30")
    kb.button(text="â±ï¸ 60 Ø¯Ù‚ÙŠÙ‚Ø©", callback_data="briefdur:60")
    kb.button(text="â±ï¸ Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ", callback_data="briefdur:custom")
    if get_open_window(msg.chat.id): kb.button(text="â›” Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„", callback_data="briefdur:stop")
    kb.adjust(2); await state.set_state(BriefStates.waiting_duration)
    await msg.answer("Ø§Ø®ØªØ± Ù…Ø¯Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„:", reply_markup=kb.as_markup())

def get_open_window(chat_id:int):
    row=q_one("SELECT id,closes_at,prompt_text,ann_message_id FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(chat_id,))
    if not row: return None
    if row["closes_at"]<=_now().isoformat():
        q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s",(row["id"],)); return None
    return row

def open_window(chat_id:int, owner:int, minutes:int, prompt:str)->Tuple[int,datetime]:
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))
    opened=_now(); closes=opened+timedelta(minutes=minutes)
    q_exec("""INSERT INTO brief_windows(origin_chat_id,opened_by,opened_at,closes_at,is_open,prompt_text)
              VALUES (%s,%s,%s,%s,1,%s)""",(chat_id,owner,opened.isoformat(),closes.isoformat(),prompt))
    bid=q_one("SELECT id FROM brief_windows WHERE origin_chat_id=%s ORDER BY id DESC LIMIT 1",(chat_id,))["id"]
    return bid, closes

def close_window(chat_id:int): q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))

def fmt_countdown(delta:timedelta)->str:
    s=int(delta.total_seconds()); m=s//60; s%=60; h=m//60; m%=60
    return f"{h}Ø³ {m}Ø¯" if h>0 else f"{m}Ø¯ {s}Ø«"

@dp.callback_query(F.data.startswith("briefdur:"))
async def brief_duration(cb:CallbackQuery, state:FSMContext):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    act=cb.data.split(":")[1]; data=await state.get_data(); prompt=data.get("prompt","")
    if act=="stop":
        close_window(cb.message.chat.id); await cb.message.answer("â›” ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª."); return await cb.answer()
    if act=="custom":
        await state.set_state(BriefStates.waiting_custom); await cb.message.answer("Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚ (Ù…Ø«Ø§Ù„: 45)"); return await cb.answer()
    minutes=int(act); bid, closes = open_window(cb.message.chat.id, cb.from_user.id, minutes, prompt)
    txt=(f"ğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
         f"â±ï¸ ÙŠÙ†ØªÙ‡ÙŠ Ø®Ù„Ø§Ù„: <b>{fmt_countdown(closes - _now())}</b> (Ø­ØªÙ‰ {closes.strftime('%Y-%m-%d %H:%M UTC')})\n"
         f"Ø£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ù‡Ù†Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.")
    m=await cb.message.answer(txt)
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear(); await cb.answer()

@dp.message(BriefStates.waiting_custom, F.text.regexp(r"^\d{1,3}$"))
async def brief_custom(msg:Message, state:FSMContext):
    minutes=int(msg.text); prompt=(await state.get_data()).get("prompt","")
    bid,closes=open_window(msg.chat.id,msg.from_user.id,minutes,prompt)
    m=await msg.answer(
        f"ğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
        f"â±ï¸ ÙŠÙ†ØªÙ‡ÙŠ Ø®Ù„Ø§Ù„: <b>{fmt_countdown(closes - _now())}</b> (Ø­ØªÙ‰ {closes.strftime('%Y-%m-%d %H:%M UTC')})\n"
        f"Ø£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ù‡Ù†Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©."
    )
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear()

@dp.message(StateFilter(None), F.text)
async def maybe_brief(msg:Message):
    win=get_open_window(msg.chat.id)
    if not win: return
    text=msg.text.strip()
    score, lvl, details = await ai_grade(text)
    q_exec("""INSERT INTO writing_submissions(origin_chat_id,quiz_id,user_id,text,score,level,evaluated_at,details_json)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s)""",
           (msg.chat.id,0,msg.from_user.id,text,score,lvl,_now().isoformat(),json.dumps(details,ensure_ascii=False)))
    fb=html.escape(details.get("feedback","")) if isinstance(details,dict) else ""
    await msg.reply(
        f"ğŸ“® <b>Schreiben (B1 DTZ)</b>\n"
        f"ğŸ‘¤ {html.escape(hname(msg.from_user))}\n"
        f"ğŸ“Š <b>{score}/20</b>\n"
        f"ğŸ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <b>{lvl}</b>" + (f"\nğŸ“ Ù…Ù„Ø§Ø­Ø¸Ø§Øª: {fb}" if fb else "")
    )

async def brief_countdown_updater():
    while True:
        try:
            rows=q_all("SELECT id,origin_chat_id,closes_at,ann_message_id FROM brief_windows WHERE is_open=1 AND ann_message_id IS NOT NULL")
            now=_now()
            for r in rows:
                closes=datetime.fromisoformat(r["closes_at"]); remain=closes-now
                if remain.total_seconds()<=0:
                    q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s",(r["id"],))
                    try: await bot.edit_message_text("â›” <b>Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª.</b>", r["origin_chat_id"], r["ann_message_id"])
                    except Exception: pass
                    continue
                try:
                    await bot.edit_message_text(
                        f"ğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ (B1 DTZ)</b>\n"
                        f"(ÙŠÙ†ØªÙ‡ÙŠ Ø®Ù„Ø§Ù„: <b>{fmt_countdown(remain)}</b>)\n"
                        f"Ø£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ù‡Ù†Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.",
                        r["origin_chat_id"], r["ann_message_id"], parse_mode=ParseMode.HTML
                    )
                except Exception: pass
        except Exception: pass
        await asyncio.sleep(120)

# ---------- Ø­Ø°Ù ÙƒÙ„ Ø´ÙŠØ¡ ----------
@dp.message(F.text==BTN_WIPE_ALL)
async def wipe_all(msg:Message):
    if not await ensure_owner(msg): return
    for tbl in ["responses","options","question_attachments","questions","media_bundle_attachments","media_bundles",
                "sent_polls","participant_names","hl_results","writing_submissions","brief_windows","quizzes"]:
        q_exec(f"DELETE FROM {tbl}")
    await msg.answer("ğŸ§¹ ØªÙ… Ø­Ø°Ù ÙƒÙ„ Ø´ÙŠØ¡.")

# ---------- Runner ----------
async def main():
    asyncio.create_task(auto_closer())
    asyncio.create_task(brief_countdown_updater())
    await dp.start_polling(bot)

if __name__=="__main__":
    try: asyncio.run(main())
    except (KeyboardInterrupt,SystemExit): print("Bot stopped.")
