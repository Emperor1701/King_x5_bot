
#code = r'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re, tempfile, math
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile, File,
    ReactionTypeEmoji
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

load_dotenv()

# --- Flood control delays ---
POLL_BASE_DELAY = float(os.getenv('POLL_BASE_DELAY', '0.9'))
POLL_JITTER = float(os.getenv('POLL_JITTER', '0.6'))
ATTACH_BASE_DELAY = float(os.getenv('ATTACH_BASE_DELAY', '1.2'))
ATTACH_JITTER = float(os.getenv('ATTACH_JITTER', '0.8'))

async def sleep_jitter(kind: str = 'poll'):
    import random
    if kind == 'attach':
        await asyncio.sleep(ATTACH_BASE_DELAY + random.random()*ATTACH_JITTER)
    else:
        await asyncio.sleep(POLL_BASE_DELAY + random.random()*POLL_JITTER)

BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

def insert_returning_id(sql:str, params:tuple|list|None=None)->int:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql + " RETURNING id", params or ())
            row = cur.fetchone()
        conn.commit()
    return int(row["id"] if isinstance(row, dict) else row[0])

# ---------- Schema + Migrations ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, username TEXT,
            text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT,
            window_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            question_id INTEGER NOT NULL,
            user_id BIGINT NOT NULL,
            username TEXT,
            option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL,
            answered_at TEXT NOT NULL,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS shared_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            kind TEXT NOT NULL,
            file_id TEXT NOT NULL,
            title TEXT,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_runs(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            published_at TEXT NOT NULL,
            grade_enabled INTEGER NOT NULL DEFAULT 0
        )"""
    ]
    for ddl in ddls: q_exec(ddl)

def migrate_schema():
    q_exec("ALTER TABLE sent_polls ADD COLUMN IF NOT EXISTS run_id INTEGER")
    q_exec("ALTER TABLE quiz_responses ADD COLUMN IF NOT EXISTS run_id INTEGER")
    q_exec("ALTER TABLE brief_windows ADD COLUMN IF NOT EXISTS prompt_text TEXT")
    q_exec("ALTER TABLE brief_windows ADD COLUMN IF NOT EXISTS ann_message_id BIGINT")
    q_exec("ALTER TABLE writing_submissions ADD COLUMN IF NOT EXISTS username TEXT")
    q_exec("ALTER TABLE writing_submissions ADD COLUMN IF NOT EXISTS window_id INTEGER")
    q_exec("ALTER TABLE quiz_runs ADD COLUMN IF NOT EXISTS grade_enabled INTEGER NOT NULL DEFAULT 0")

ensure_schema()
migrate_schema()

# ---------- UI ----------
BTN_NEWQUIZ="ğŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_ADDQ="â• Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„"; BTN_LISTQUIZ="ğŸ“š Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EDITQUIZ="ğŸ› ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_DELQUIZ="ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø±"
BTN_BUNDLES="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©"; BTN_MERGE="ğŸ”— Ø¯Ù…Ø¬ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EXPORT="ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_IMPORT="ğŸ“¥ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙØ¹Ø©"
BTN_PUBLISH="ğŸš€ Ù†Ø´Ø± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_WIPE_ALL="ğŸ§¹ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_SCORE="ğŸ† Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬"; BTN_BACK_HOME="â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©"; BTN_BACK_STEP="â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø®Ù„Ù"
BTN_BRIEF="âœ‰ï¸ Ø²Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ"
BTN_LISTQUESTIONS="ğŸ“ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©"
BTN_EDITQUESTION="âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¤Ø§Ù„"
BTN_DELQUESTION="ğŸ—‘ï¸ Ø­Ø°Ù Ø³Ø¤Ø§Ù„"
BTN_BRIEF_RESULTS = "ğŸ“„ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ"  # NEW

def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_EDITQUIZ)],
        [KeyboardButton(text=BTN_LISTQUESTIONS), KeyboardButton(text=BTN_EDITQUESTION)],
        [KeyboardButton(text=BTN_DELQUESTION)],
        [KeyboardButton(text=BTN_DELQUIZ), KeyboardButton(text=BTN_BRIEF)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_BRIEF_RESULTS)],  # NEW
        [KeyboardButton(text=BTN_EXPORT), KeyboardButton(text=BTN_IMPORT)],
        [KeyboardButton(text=BTN_BUNDLES), KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_WIPE_ALL)],
    ]
    return ReplyKeyboardMarkup(
        keyboard=rows, resize_keyboard=True, one_time_keyboard=True,
        is_persistent=False, input_field_placeholder="Ø§Ø®ØªØ± Ø£Ù…Ø±Ù‹Ø§ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± ğŸ‘‡"
    )

ALL_BTN_TEXTS = {
    BTN_BACK_HOME, BTN_BACK_STEP, BTN_NEWQUIZ, BTN_ADDQ, BTN_LISTQUIZ, BTN_EDITQUIZ,
    BTN_DELQUIZ, BTN_BRIEF, BTN_WIPE_ALL, BTN_SCORE, BTN_PUBLISH, BTN_BUNDLES,
    BTN_MERGE, BTN_EXPORT, BTN_IMPORT, BTN_LISTQUESTIONS, BTN_EDITQUESTION, BTN_DELQUESTION,
    BTN_BRIEF_RESULTS  # NEW
}

def done_button_kb(tag: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"done:{tag}")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª", callback_data=f"skip:{tag}")
    kb.adjust(2); return kb.as_markup()

def inline_confirm_kb(tag:str):
    kb=InlineKeyboardBuilder()
    kb.button(text="âœ… ØªØ£ÙƒÙŠØ¯", callback_data=f"{tag}:yes")
    kb.button(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=f"{tag}:no")
    kb.adjust(2); return kb.as_markup()

def attach_choice_kb():
    kb=InlineKeyboardBuilder()
    kb.button(text="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ø®Ø§ØµØ©", callback_data="att:upload")
    kb.button(text="ğŸ“ Ù…Ù† Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©", callback_data="att:shared")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª", callback_data="att:none")
    kb.adjust(2,1); return kb.as_markup()

def shared_list_kb(question_id:int):
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    kb=InlineKeyboardBuilder()
    for r in rows:
        label=f"{r['id']} â€” {r['kind']} â€” {(r['title'] or '')[:20]}"
        kb.button(text=label, callback_data=f"attadd:{question_id}:{r['id']}")
    kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"attdone:{question_id}")
    kb.adjust(1)
    return kb.as_markup()

def publish_hours_kb(quiz_id:int):
    kb=InlineKeyboardBuilder()
    for h in (1,2,4,8,24):
        kb.button(text=f"â³ {h} Ø³Ø§Ø¹Ø©", callback_data=f"pubdur:{quiz_id}:{h}")
    kb.button(text="âŒ¨ï¸ Ø±Ù‚Ù… Ù…Ø®ØµØµ", callback_data=f"pubdur:{quiz_id}:custom")
    kb.button(text="â™¾ï¸ Ø¨Ø¯ÙˆÙ† Ù…Ø¤Ù‚Ù‘Øª", callback_data=f"pubdur:{quiz_id}:0")
    kb.adjust(2,2,1)
    return kb.as_markup()

def publish_eval_kb(quiz_id:int, hours:int):
    kb=InlineKeyboardBuilder()
    kb.button(text="âœ… ÙØ¹Ù‘Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…", callback_data=f"pubeval:{quiz_id}:{hours}:1")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† ØªÙ‚ÙŠÙŠÙ…", callback_data=f"pubeval:{quiz_id}:{hours}:0")
    kb.adjust(2)
    return kb.as_markup()

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID
async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±/Ø§Ù„Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", reply_markup=owner_kb()); return False
    return True
def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"

def mention_html(user_id:int, name:str)->str:
    safe = html.escape(name or "Ù…Ø³ØªØ®Ø¯Ù…")
    return f'<a href="tg://user?id={user_id}">{safe}</a>'

async def send_long(chat_id:int, text:str):
    MAX=3800
    buf=""
    for para in text.split("\n\n"):
        if len(buf)+len(para)+2>MAX and buf:
            await bot.send_message(chat_id, buf)
            buf=""
        buf += (("\n\n" if buf else "") + para)
    if buf:
        await bot.send_message(chat_id, buf)

async def attach_file_to_question(question_id:int, kind:str, file_id:str):
    pos_row = q_one("SELECT COALESCE(MAX(position),-1) AS p FROM question_attachments WHERE question_id=%s",(question_id,))
    pos = int(pos_row["p"]) + 1
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
           (question_id, kind, file_id, pos))

# ===== Chat title cache (Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©) =====
def ensure_chats_cache_table():
    q_exec("""CREATE TABLE IF NOT EXISTS chats_cache(
        chat_id   BIGINT PRIMARY KEY,
        title     TEXT,
        type      TEXT,
        updated_at TIMESTAMPTZ NOT NULL
    )""")

ensure_chats_cache_table()

async def cache_chat_title(chat_id:int):
    """ÙŠØ¬Ù„Ø¨ Ø§Ø³Ù…/Ù†ÙˆØ¹ Ø§Ù„Ø´Ø§Øª Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ÙˆÙŠØ®Ø²Ù‘Ù†Ù‡ Ù…Ø­Ù„ÙŠÙ‹Ø§."""
    try:
        ch = await bot.get_chat(chat_id)
        title = getattr(ch, "title", None) or getattr(ch, "full_name", "") or ""
        ctype = getattr(ch, "type", "") or ""
        q_exec("""INSERT INTO chats_cache(chat_id, title, type, updated_at)
                  VALUES (%s,%s,%s, NOW())
                  ON CONFLICT (chat_id) DO UPDATE
                  SET title=EXCLUDED.title, type=EXCLUDED.type, updated_at=EXCLUDED.updated_at""",
               (chat_id, title, ctype))
    except Exception:
        pass

def chat_title_cached(chat_id:int)->str:
    r = q_one("SELECT title FROM chats_cache WHERE chat_id=%s",(chat_id,))
    return (r and r.get("title")) or f"Chat {chat_id}"

# --- Ù…Ù†Ø¹ Ø¶ØºØ· Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„ØºÙŠØ± Ø§Ù„Ù…Ø§Ù„Ùƒ ---
@dp.callback_query(
    F.from_user.id != OWNER_ID,
    F.data.regexp(r"^(addq|editq|delq|delqconfirm|briefstop|done:|skip:|wipe:|listq:|pgql:|pgqs:|delpick:|del:|delc:|editqs:|pickqs:|qview:|pub:|pubdur:|pubeval:|scorepick:|scorerun:|export:|bund:|merge:|att:|attadd:|attdone:|editm:|bpgch:|bscorechat:|bpgw:|bshoww:)")
)
async def admin_cb_guard(cb: CallbackQuery):
    await cb.answer("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø± Ø®Ø§Øµ Ø¨Ø§Ù„ÙƒÙ†Øº.", show_alert=True)

# ---------- States ----------
class BuildStates(StatesGroup):
    waiting_title=State()
    waiting_pick_quiz_for_addq=State()
    waiting_q_block=State()
    waiting_correct_index=State()
    waiting_pick_for_edit=State()
    waiting_new_title=State()
    waiting_pick_for_delete=State()
    waiting_attach_mode=State()
    waiting_q_attachments_upload=State()
    waiting_q_attachments_shared=State()

class WipeStates(StatesGroup):
    waiting_confirm=State()

class BriefStates(StatesGroup):
    waiting_prompt=State()

class EditQStates(StatesGroup):
    pick_quiz=State()
    edit_menu=State()
    edit_text=State()
    edit_options=State()
    correct_index=State()
    attach_mode=State()
    attach_upload=State()
    attach_shared=State()

class ImportStates(StatesGroup):
    waiting_json=State()

class BundleStates(StatesGroup):
    idle=State()
    add_wait_file=State()
    attach_pick_quiz=State()
    attach_pick_question=State()
    attach_pick_bundle=State()

class MergeStates(StatesGroup):
    pick_dest=State()
    pick_source=State()

class PublishStates(StatesGroup):
    waiting_hours_custom=State()

class ScoreStates(StatesGroup):
    pick_chat = State()   # Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
    pick_quiz = State()
    pick_run = State()

class BriefScoreStates(StatesGroup):  # NEW: Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ
    pick_chat = State()
    pick_window = State()

# ---------- Parsers ----------
_option_line_re = re.compile(
    r"""^\s*(
        (\d+)[\)\.\-]\s*
       |([A-Za-z])[)\.\-]\s*
       |[\-\*\â€¢]\s*
    )?(?P<txt>.+?)\s*(?P<mark>(âœ…|\(\*\)|\*\)|\*\s*$))?\s*$""",
    re.X | re.U
)

def parse_q_block(text:str)->Tuple[str, List[Tuple[str,bool]]]:
    lines=[l for l in (text.replace("\r","").split("\n")) if l.strip()]
    if not lines: raise ValueError("Ù†Øµ ÙØ§Ø±Øº.")
    qline=lines[0].strip()
    opts=[]
    for l in lines[1:]:
        m=_option_line_re.match(l)
        if not m: continue
        t=m.group("txt").strip()
        if not t: continue
        is_correct=bool(m.group("mark"))
        opts.append((t,is_correct))
    if len(opts)<2 or len(opts)>12:
        raise ValueError("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ 2 Ø¥Ù„Ù‰ 10 Ø®ÙŠØ§Ø±Ø§Øª Ø¶Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
    return qline, opts

def parse_options_only(text:str)->List[Tuple[str,bool]]:
    lines=[l for l in (text.replace("\r","").split("\n")) if l.strip()]
    opts=[]
    for l in lines:
        m=_option_line_re.match(l)
        if not m: continue
        t=m.group("txt").strip()
        if not t: continue
        is_correct=bool(m.group("mark"))
        opts.append((t,is_correct))
    if len(opts)<2 or len(opts)>12:
        raise ValueError("Ø£Ø¯Ø®Ù„ 2 Ø¥Ù„Ù‰ 12 Ø®ÙŠØ§Ø±Ø§Øª.")
    return opts

# ---------- /start & back ----------
@dp.message(Command("start"))
async def start(msg:Message):
    if is_owner(msg.from_user.id):
        await msg.answer("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¬Ø§Ù‡Ø²Ø© â€” Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:", reply_markup=owner_kb())
    else:
        await msg.answer("Ø£Ù‡Ù„Ø§Ù‹! Ù‡Ø°Ø§ Ø¨ÙˆØª Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¹Ù„Ù….")

@dp.message(F.text==BTN_BACK_HOME)
async def back_home(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("ØªÙ… Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©.", reply_markup=owner_kb())

@dp.message(F.text==BTN_BACK_STEP)
async def back_step(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("Ø±Ø¬Ø¹Ù†Ø§ Ø®Ø·ÙˆØ© (ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·).", reply_markup=owner_kb())

# ---------- Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø± ----------
@dp.message(F.text==BTN_NEWQUIZ)
async def new_quiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_title)
    await msg.answer("Ø£Ø±Ø³Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:")

@dp.message(BuildStates.waiting_title, F.text)
async def save_quiz_title(msg:Message, state:FSMContext):
    title = msg.text.strip()
    qid = insert_returning_id(
        "INSERT INTO quizzes(title,created_by,created_at) VALUES (%s,%s,%s)",
        (title, msg.from_user.id, _now().isoformat())
    )
    await state.clear()
    await msg.answer(f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± (ID {qid}).", reply_markup=owner_kb())

# =========================================================
# ===== Pagination (5-per-page) â€” Ù…ÙˆØ­Ù‘Ø¯ ===================
# =========================================================
PER_PAGE = 5

def _paginate(rows: List[dict], page: int, per_page: int = PER_PAGE):
    total = len(rows)
    pages = max(1, math.ceil(total / per_page))
    page = max(0, min(page, pages-1))
    start = page * per_page
    end = start + per_page
    return rows[start:end], page, pages, total

def _quizzes_page(mode: str, page: int = 0):
    """
    mode âˆˆ {'ql_view','ql_edit','ql_delete','ql_pick_editq','ql_pick_delq','ql_pick_score'}
    """
    rows = q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    chunk, page, pages, total = _paginate(rows, page)

    kb = InlineKeyboardBuilder()
    for r in chunk:
        title = (r['title'] or '')[:40]
        if mode == "ql_view":
            kb.button(text=f"ğŸ“¦ {r['id']} â€” {title}", callback_data=f"listq:{r['id']}")
        elif mode == "ql_edit":
            kb.button(text=f"âœï¸ {r['id']} â€” {title}", callback_data=f"editq:{r['id']}")
        elif mode == "ql_delete":
            kb.button(text=f"ğŸ—‘ï¸ {r['id']} â€” {title}", callback_data=f"delq:{r['id']}")
        elif mode == "ql_pick_editq":
            kb.button(text=f"â“ {r['id']} â€” {title}", callback_data=f"editqs:{r['id']}")
        elif mode == "ql_pick_delq":
            kb.button(text=f"ğŸ—‘ï¸ Ø£Ø³Ø¦Ù„Ø© {r['id']} â€” {title}", callback_data=f"delpick:{r['id']}:0")
        elif mode == "ql_pick_score":
            kb.button(text=f"ğŸ Ù†ØªØ§Ø¦Ø¬ {r['id']} â€” {title}", callback_data=f"scorepick:{r['id']}:0")
    if page > 0:
        kb.button(text="â¬…ï¸ Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data=f"pgql:{mode}:{page-1}")
    if page < pages-1:
        kb.button(text="Ø§Ù„ØªØ§Ù„ÙŠ â¡ï¸", callback_data=f"pgql:{mode}:{page+1}")
    kb.adjust(1)
    return kb.as_markup(), total, pages, page

def _qs_page_text_header(prefix_emoji: str, title: str, total: int, page: int, pages: int):
    return f"{prefix_emoji} <b>{title}</b> (Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {total}) â€” ØµÙØ­Ø© {page+1}/{pages}"

def _questions_page(quiz_id: int, mode: str, page: int = 0):
    """
    mode âˆˆ {'q_view','q_pick_edit','q_pick_delete'}
    - ÙŠØ¹Ø±Ø¶ Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙƒØ§Ù…Ù„ Ø¨Ø¯ÙˆÙ† Q**
    """
    rows = q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id ASC", (quiz_id,))
    chunk, page, pages, total = _paginate(rows, page)

    blocks = [_qs_page_text_header("ğŸ“", f"Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± {quiz_id}", total, page, pages), ""]
    for r in chunk:
        qtxt = (r['text'] or '').strip()
        blocks.append(f"<code>{html.escape(qtxt)}</code>")
        blocks.append("â€” â€” â€”")
    text = "\n".join(blocks).strip()

    kb = InlineKeyboardBuilder()
    for r in chunk:
        preview = (r['text'] or '').replace("\n"," ")[:40]
        if mode == "q_view":
            kb.button(text=f"ğŸ‘ï¸ {preview}", callback_data=f"qview:{quiz_id}:{r['id']}:{page}")
        elif mode == "q_pick_edit":
            kb.button(text=f"âœï¸ {preview}", callback_data=f"pickqs:{quiz_id}:{r['id']}:{page}")
        elif mode == "q_pick_delete":
            kb.button(text=f"ğŸ—‘ï¸ {preview}", callback_data=f"del:{quiz_id}:{r['id']}")
    if page > 0:
        kb.button(text="â¬…ï¸ Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data=f"pgqs:{mode}:{quiz_id}:{page-1}")
    if page < pages-1:
        kb.button(text="Ø§Ù„ØªØ§Ù„ÙŠ â¡ï¸", callback_data=f"pgqs:{mode}:{quiz_id}:{page+1}")
    kb.adjust(1)
    return text, kb.as_markup(), total, pages, page

# ===== Ù„Ø§Ø¦Ø­Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ØªÙŠ ÙÙŠÙ‡Ø§ Ù†ÙˆØ§ÙØ° Ø¨Ø±ÙŠÙ =====
def brief_chats_page(page:int=0, per_page:int=5):
    rows = q_all("""
        SELECT DISTINCT origin_chat_id AS chat_id
        FROM brief_windows
        ORDER BY MAX(id) OVER (PARTITION BY origin_chat_id) DESC
    """)
    chunk, page, pages, total = _paginate(rows, page, per_page)
    kb = InlineKeyboardBuilder()
    for r in chunk:
        cid = int(r["chat_id"])
        title = chat_title_cached(cid)
        kb.button(text=f"ğŸ‘¥ {title}", callback_data=f"bscorechat:{cid}:0")
    if page>0:
        kb.button(text="â¬…ï¸ Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data=f"bpgch:{page-1}")
    if page<pages-1:
        kb.button(text="Ø§Ù„ØªØ§Ù„ÙŠ â¡ï¸", callback_data=f"bpgch:{page+1}")
    kb.adjust(1)
    return kb.as_markup(), total, pages, page

def brief_windows_page(chat_id:int, page:int=0, per_page:int=6):
    rows = q_all("""
        SELECT id, opened_at, closes_at, is_open, prompt_text
        FROM brief_windows
        WHERE origin_chat_id=%s
        ORDER BY id DESC
    """, (chat_id,))
    chunk, page, pages, total = _paginate(rows, page, per_page)
    kb = InlineKeyboardBuilder()
    for w in chunk:
        opened = (w["opened_at"] or "").replace("T"," ").split(".")[0].replace("+00:00","")
        status = "Ù…ÙØªÙˆØ­Ø©" if int(w["is_open"])==1 else "Ù…ØºÙ„Ù‚Ø©"
        kb.button(text=f"ğŸ•’ {opened} â€” {status}", callback_data=f"bshoww:{int(w['id'])}")
    if page>0:
        kb.button(text="â¬…ï¸ Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data=f"bpgw:{chat_id}:{page-1}")
    if page<pages-1:
        kb.button(text="Ø§Ù„ØªØ§Ù„ÙŠ â¡ï¸", callback_data=f"bpgw:{chat_id}:{page+1}")
    kb.adjust(1)
    return kb.as_markup(), total, pages, page

async def render_brief_window_results(chat_id:int, window_id:int):
    # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø§ÙØ°Ø©
    w = q_one("""SELECT origin_chat_id, opened_at, closes_at, is_open, prompt_text
                 FROM brief_windows WHERE id=%s""", (window_id,))
    if not w:
        await bot.send_message(chat_id, "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¨Ø±ÙŠÙ."); return

    origin = int(w["origin_chat_id"])
    title = chat_title_cached(origin)
    opened = (w["opened_at"] or "").replace("T"," ").split(".")[0].replace("+00:00","")
    closes = (w["closes_at"] or "").replace("T"," ").split(".")[0].replace("+00:00","")
    status = "Ù…ÙØªÙˆØ­Ø© âœ…" if int(w["is_open"])==1 else "Ù…ØºÙ„Ù‚Ø© â›”"

    # Ù‚Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ§Øª (Ù†Ø­ØªÙØ¸ Ø¨Ø¢Ø®Ø± ØªÙ‚ÙŠÙŠÙ… Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…)
    rows = q_all("""
        SELECT user_id, COALESCE(NULLIF(username,''),'Ù…Ø¬Ù‡ÙˆÙ„') AS uname,
               score, level, details_json, evaluated_at
        FROM writing_submissions
        WHERE window_id=%s
        ORDER BY evaluated_at ASC
    """, (window_id,))

    by_user: Dict[int, dict] = {}
    for r in rows:
        by_user[r["user_id"]] = r  # Ø¢Ø®Ø± ÙˆØ§Ø­Ø¯
    results = sorted(by_user.values(), key=lambda x: (-int(x["score"]), x["uname"]))

    # Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù†Øµ
    header = (
        f"ğŸ“ˆ <b>Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ â€” {html.escape(title)}</b>\n"
        f"ğŸªª Window ID: <code>{window_id}</code>\n"
        f"ğŸ•’ Ù…Ù†: <code>{opened}</code>\n"
        f"â³ Ø¥Ù„Ù‰: <code>{closes}</code>\n"
        f"ğŸ” Ø§Ù„Ø­Ø§Ù„Ø©: {status}\n"
        f"âœ‰ï¸ <b>Ø§Ù„Ù†Øµ:</b> {html.escape(w.get('prompt_text') or '')}\n\n"
        f"<b>Ø§Ù„Ù†ØªØ§Ø¦Ø¬:</b>\n"
    )
    if not results:
        await bot.send_message(chat_id, header + "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø§Ø±ÙƒØ§Øª Ø¨Ø¹Ø¯.", reply_markup=owner_kb()); return

    lines=[]
    for i, r in enumerate(results, 1):
        fb = ""
        try:
            det = json.loads(r["details_json"] or "{}"); fb = det.get("feedback","")
        except Exception:
            pass
        fb_short = (fb[:120] + "â€¦") if len(fb) > 120 else fb
        lines.append(
            f"{i:>2}. {html.escape(r['uname'])} â€” <b>{int(r['score'])}/20</b> â€” {html.escape(r['level'])}"
            + (f"\n    ğŸ“ {fb_short}" if fb_short else "")
        )
    await send_long(chat_id, header + "\n".join(lines))


# ===== Ù„Ø§Ø¦Ø­Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ØªÙŠ ÙÙŠÙ‡Ø§ Ø¬Ù„Ø³Ø§Øª Ù†Ø´Ø± =====
def score_chats_page(page:int=0, per_page:int=5):
    # FIX: ØªØ¬Ù†Ù‘Ø¨ SELECT DISTINCT + ORDER BY ØªØ¹Ø¨ÙŠØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯
    rows = q_all("""
        SELECT chat_id, MAX(id) AS last_id
        FROM quiz_runs
        GROUP BY chat_id
        ORDER BY last_id DESC
    """)
    chunk, page, pages, total = _paginate(rows, page, per_page)
    kb = InlineKeyboardBuilder()
    for r in chunk:
        cid = int(r["chat_id"])
        title = chat_title_cached(cid)
        kb.button(text=f"ğŸ‘¥ {title}", callback_data=f"scorechat:{cid}:0")
    if page>0:
        kb.button(text="â¬…ï¸ Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data=f"pgch:{page-1}")
    if page<pages-1:
        kb.button(text="Ø§Ù„ØªØ§Ù„ÙŠ â¡ï¸", callback_data=f"pgch:{page+1}")
    kb.adjust(1)
    return kb.as_markup(), total, pages, page
# =========================================================

# ================== Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ==================
@dp.message(F.text==BTN_LISTQUIZ)
async def list_quizzes_cmd(msg: Message):
    if not await ensure_owner(msg): return
    kb, total, pages, page = _quizzes_page("ql_view", 0)
    await msg.answer(_qs_page_text_header("ğŸ“š", "Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª", total, page, pages), reply_markup=kb)

@dp.message(F.text==BTN_LISTQUESTIONS)
async def list_questions_via_quizzes(msg: Message):
    if not await ensure_owner(msg): return
    kb, total, pages, page = _quizzes_page("ql_view", 0)
    await msg.answer(_qs_page_text_header("ğŸ“š", "Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª", total, page, pages), reply_markup=kb)

@dp.callback_query(F.data.startswith("pgql:"))
async def list_quizzes_nav(cb: CallbackQuery):
    # pgql:<mode>:<page>
    _, mode, page = cb.data.split(":")
    page = int(page)
    kb, total, pages, page = _quizzes_page(mode, page)
    titles = {
        "ql_view": ("ğŸ“š", "Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"),
        "ql_edit": ("ğŸ› ï¸", "ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø± â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§"),
        "ql_delete": ("ğŸ—‘ï¸", "Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø± â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§"),
        "ql_pick_editq": ("âœï¸", "ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¤Ø§Ù„ â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§"),
        "ql_pick_delq": ("ğŸ—‘ï¸", "Ø­Ø°Ù Ø³Ø¤Ø§Ù„ â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§"),
        "ql_pick_score": ("ğŸ", "Ù†ØªØ§Ø¦Ø¬ â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§"),
    }
    emoji, ttl = titles.get(mode, ("ğŸ“š", "Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"))
    try:
        await cb.message.edit_text(_qs_page_text_header(emoji, ttl, total, page, pages), reply_markup=kb)
    except Exception:
        await cb.message.answer(_qs_page_text_header(emoji, ttl, total, page, pages), reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.startswith("listq:"))
async def list_quiz_questions_view(cb: CallbackQuery):
    quiz_id = int(cb.data.split(":")[1])
    text, kb, total, pages, page = _questions_page(quiz_id, "q_view", 0)
    try:
        await cb.message.edit_text(text, reply_markup=kb)
    except Exception:
        await cb.message.answer(text, reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.startswith("pgqs:"))
async def questions_nav(cb: CallbackQuery):
    # pgqs:<mode>:<quiz_id>:<page>
    _, mode, quiz_id, page = cb.data.split(":")
    quiz_id = int(quiz_id); page = int(page)
    text, kb, total, pages, page = _questions_page(quiz_id, mode, page)
    try:
        await cb.message.edit_text(text, reply_markup=kb)
    except Exception:
        await cb.message.answer(text, reply_markup=kb)
    await cb.answer()

# ---------- Ø¹Ø±Ø¶ Ø³Ø¤Ø§Ù„ Ù…Ø¹ÙŠÙ‘Ù† (Ù…Ø¹ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª ÙˆØ§Ù„Ù…Ø±ÙÙ‚Ø§Øª) ----------
async def show_question_details(chat_id:int, quiz_id:int, qid:int, page:int, for_edit:bool):
    qrow = q_one("SELECT text FROM questions WHERE id=%s", (qid,))
    if not qrow:
        return await bot.send_message(chat_id, "Ø§Ù„Ø³Ø¤Ø§Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.", reply_markup=owner_kb())

    # Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø¥Ù† ÙˆØ¬Ø¯Øª
    try:
        await send_question_attachments(chat_id, qid)
    except Exception:
        pass

    # Ø§Ø¬Ù„Ø¨ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª
    opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(qid,))
    lines = [f"â€¢ {i+1}) {html.escape(o['text'])} {'âœ…' if int(o['is_correct'])==1 else ''}" for i,o in enumerate(opts)]
    text = f"â“ <b>Ø³Ø¤Ø§Ù„</b> â€” Ø§Ø®ØªØ¨Ø§Ø± {quiz_id}\n\n<code>{html.escape((qrow['text'] or '').strip())}</code>\n\n" + "\n".join(lines)

    kb = InlineKeyboardBuilder()
    if for_edit:
        kb.button(text="âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¤Ø§Ù„ + Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª", callback_data="editm:text")
        kb.button(text="ğŸ§© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª ÙÙ‚Ø·", callback_data="editm:opts")
        kb.button(text="ğŸ“ Ø¥Ø¶Ø§ÙØ©/ØªØ¨Ø¯ÙŠÙ„ Ù…Ø±ÙÙ‚Ø§Øª", callback_data="editm:att_add")
        kb.button(text="ğŸ—‘ï¸ Ø¥Ø²Ø§Ù„Ø© ÙƒÙ„ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª", callback_data="editm:att_clear")
        kb.button(text="â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©", callback_data=f"pgqs:q_pick_edit:{quiz_id}:{page}")
    else:
        kb.button(text="â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©", callback_data=f"pgqs:q_view:{quiz_id}:{page}")
    kb.adjust(1)
    await bot.send_message(chat_id, text, reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("qview:"))
async def qview_handler(cb: CallbackQuery):
    _, quiz_id, qid, page = cb.data.split(":")
    await show_question_details(cb.message.chat.id, int(quiz_id), int(qid), int(page), for_edit=False)
    await cb.answer()

# ================== ØªØ¹Ø¯ÙŠÙ„ Ø¹Ù†ÙˆØ§Ù† Ø§Ø®ØªØ¨Ø§Ø± ==================
@dp.message(F.text==BTN_EDITQUIZ)
async def editquiz_start(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_for_edit)
    kb, total, pages, page = _quizzes_page("ql_edit", 0)
    await msg.answer(_qs_page_text_header("ğŸ› ï¸", "ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø± â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§", total, page, pages), reply_markup=kb)

@dp.callback_query(BuildStates.waiting_pick_for_edit, F.data.startswith("editq:"))
async def pick_for_edit(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(edit_id=qid)
    await state.set_state(BuildStates.waiting_new_title)
    await cb.message.answer("Ø£Ø±Ø³Ù„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯:")
    await cb.answer()

@dp.message(BuildStates.waiting_new_title, F.text)
async def apply_edit(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_id")
    q_exec("UPDATE quizzes SET title=%s WHERE id=%s", (msg.text.strip(), qid))
    await state.clear()
    await msg.answer("âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†.", reply_markup=owner_kb())

# ================== Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø± ==================
@dp.message(F.text==BTN_DELQUIZ)
async def delquiz_start(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_for_delete)
    kb, total, pages, page = _quizzes_page("ql_delete", 0)
    await msg.answer(_qs_page_text_header("ğŸ—‘ï¸", "Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø± â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§", total, page, pages), reply_markup=kb)

@dp.callback_query(BuildStates.waiting_pick_for_delete, F.data.startswith("delq:"))
async def delq_confirm(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    kb=inline_confirm_kb(f"delqconfirm:{qid}")
    await cb.message.answer(f"âš ï¸ ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ID {qid}ØŸ", reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.regexp(r"^delqconfirm:(\d+):(yes|no)$"))
async def delq_apply(cb:CallbackQuery):
    _, rest = cb.data.split("delqconfirm:")
    qid, decision = rest.split(":")
    qid=int(qid)
    if decision=="no":
        await cb.message.answer("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡ âœ…", reply_markup=owner_kb()); return await cb.answer()
    q_exec("DELETE FROM options WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)", (qid,))
    q_exec("DELETE FROM question_attachments WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)", (qid,))
    q_exec("DELETE FROM questions WHERE quiz_id=%s", (qid,))
    q_exec("DELETE FROM sent_polls WHERE quiz_id=%s", (qid,))
    q_exec("DELETE FROM quizzes WHERE id=%s", (qid,))
    await cb.message.answer("ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.", reply_markup=owner_kb())
    await cb.answer()

# ================== Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ ==================
@dp.message(F.text==BTN_ADDQ)
async def addq_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.\nØ£Ù†Ø´Ø¦ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ø£ÙˆÙ„Ø§Ù‹.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:30]:
        kb.button(text=f"âœ… {r['id']} â€” {r['title']}", callback_data=f"addq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_quiz_for_addq)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_quiz_for_addq, F.data.startswith("addq:"))
async def addq_pick(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(quiz_id=qid)
    await state.set_state(BuildStates.waiting_q_block)
    await cb.message.answer(
        "Ø£Ø±Ø³Ù„ <b>Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©</b>:\n"
        "Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø³Ø¤Ø§Ù„ØŒ Ø«Ù… ÙƒÙ„ Ø®ÙŠØ§Ø± Ø¨Ø³Ø·Ø± Ø¬Ø¯ÙŠØ¯ (2..10).\n"
        "Ù…Ø«Ø§Ù„:\n"
        "Ù…Ø§ Ø¹Ø§ØµÙ…Ø© Ø£Ù„Ù…Ø§Ù†ÙŠØ§ØŸ\n1) Ù‡Ø§Ù…Ø¨ÙˆØ±Øº\n2) Ø¨Ø±Ù„ÙŠÙ† âœ…\n3) Ù…ÙŠÙˆÙ†Ø®\n\n"
        "ÙŠÙ…ÙƒÙ†Ùƒ ÙˆØ¶Ø¹ âœ… Ø£Ùˆ (*) Ø¹Ù„Ù‰ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­."
    )
    await cb.answer()

@dp.message(BuildStates.waiting_q_block, F.text)
async def got_q_block(msg:Message, state:FSMContext):
    try:
        sel=(await state.get_data()); quiz_id=sel["quiz_id"]
        qtext, opts = parse_q_block(msg.text)
        new_q = insert_returning_id(
            "INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
            (quiz_id, qtext, _now().isoformat())
        )
        correct=None
        for i,(t,is_ok) in enumerate(opts):
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (new_q,i,t,1 if is_ok else 0))
            if is_ok: correct=i
        await state.update_data(question_id=new_q, opt_count=len(opts), needs_correct=(correct is None))
        kb=attach_choice_kb()
        await state.set_state(BuildStates.waiting_attach_mode)
        await msg.answer("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ù„Ù„Ø³Ø¤Ø§Ù„:", reply_markup=kb)
    except Exception as e:
        await msg.answer(f"âš ï¸ Ù„Ù… Ø£ÙÙ‡Ù… Ø§Ù„Ø±Ø³Ø§Ù„Ø©: <code>{html.escape(str(e))}</code>")

@dp.callback_query(BuildStates.waiting_attach_mode, F.data.startswith("att:"))
async def addq_attach_mode(cb:CallbackQuery, state:FSMContext):
    mode = cb.data.split(":")[1]
    d=await state.get_data()
    qid = int(d["question_id"])
    if mode=="upload":
        await state.set_state(BuildStates.waiting_q_attachments_upload)
        await cb.message.answer("Ø£Ø±Ø³Ù„ ØµÙˆØ±/ÙÙˆÙŠØ³/Ø£ÙˆØ¯ÙŠÙˆ ÙƒÙ…Ø±ÙÙ‚Ø§Øª Ø®Ø§ØµØ©. Ø«Ù… Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ….", reply_markup=done_button_kb("qatt"))
    elif mode=="shared":
        rows = q_all("SELECT id FROM shared_attachments ORDER BY id DESC LIMIT 1")
        if not rows:
            await cb.message.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ© Ø¨Ø¹Ø¯. Ø£Ø¶Ù Ù…Ù† Ø²Ø± ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©.", reply_markup=owner_kb())
            await cb.message.answer("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª:", reply_markup=attach_choice_kb())
            await cb.answer(); return
        await state.set_state(BuildStates.waiting_q_attachments_shared)
        await cb.message.answer("Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© (ÙŠÙ…ÙƒÙ† Ø§Ø®ØªÙŠØ§Ø± Ø£ÙƒØ«Ø± Ù…Ù† ÙˆØ§Ø­Ø¯) Ø«Ù… Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ….", reply_markup=shared_list_kb(qid))
    elif mode=="none":
        if d.get("needs_correct", True):
            await state.set_state(BuildStates.waiting_correct_index)
            await cb.message.answer(f"Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ (1..{int(d['opt_count'])}):")
        else:
            await state.clear(); await cb.message.answer("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ.", reply_markup=owner_kb())
    await cb.answer()

@dp.message(BuildStates.waiting_q_attachments_upload, F.photo | F.voice | F.audio)
async def addq_attach_upload(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d["question_id"])
    if msg.photo:
        await attach_file_to_question(qid, "photo", msg.photo[-1].file_id)
    elif msg.voice:
        await attach_file_to_question(qid, "voice", msg.voice.file_id)
    elif msg.audio:
        await attach_file_to_question(qid, "audio", msg.audio.file_id)

@dp.callback_query(F.data=="done:qatt")
async def addq_attach_done(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    if d.get("needs_correct", True):
        await state.set_state(BuildStates.waiting_correct_index)
        await cb.message.answer(f"Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ (1..{int(d['opt_count'])}):")
    else:
        await state.clear(); await cb.message.answer("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ.", reply_markup=owner_kb())
    await cb.answer()

@dp.callback_query(BuildStates.waiting_q_attachments_shared, F.data.startswith("attadd:"))
async def addq_attach_shared_add(cb:CallbackQuery):
    _, qid_str, bid_str = cb.data.split(":")
    question_id = int(qid_str); bundle_id = int(bid_str)
    b = q_one("SELECT kind,file_id FROM shared_attachments WHERE id=%s",(bundle_id,))
    if not b:
        await cb.answer("ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.", show_alert=True); return
    await attach_file_to_question(question_id, b["kind"], b["file_id"])
    await cb.answer("ØªÙ… Ø±Ø¨Ø· Ù…Ø±ÙÙ‚.", show_alert=False)

@dp.callback_query(BuildStates.waiting_q_attachments_shared, F.data.startswith("attdone:"))
async def addq_attach_shared_done(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    if d.get("needs_correct", True):
        await state.set_state(BuildStates.waiting_correct_index)
        await cb.message.answer(f"Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ (1..{int(d['opt_count'])}):")
    else:
        await state.clear(); await cb.message.answer("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ.", reply_markup=owner_kb())
    await cb.answer()

@dp.message(BuildStates.waiting_correct_index, F.text.regexp(r"^\d+$"))
async def set_correct(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d["question_id"]); cnt=int(d.get("opt_count",0))
    i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚.")
    q_exec("UPDATE options SET is_correct=0 WHERE question_id=%s",(qid,))
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear(); await msg.answer("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ.", reply_markup=owner_kb())

# ================== ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¤Ø§Ù„ ==================
@dp.message(F.text==BTN_EDITQUESTION)
async def edit_question_pick_quiz(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(EditQStates.pick_quiz)
    kb, total, pages, page = _quizzes_page("ql_pick_editq", 0)
    await msg.answer(_qs_page_text_header("âœï¸", "ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¤Ø§Ù„ â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§", total, page, pages), reply_markup=kb)

@dp.callback_query(EditQStates.pick_quiz, F.data.startswith("editqs:"))
async def pick_quiz_then_pick_question(cb: CallbackQuery, state: FSMContext):
    qz = int(cb.data.split(":")[1])
    await state.set_state(EditQStates.edit_menu)
    text, kb, *_ = _questions_page(qz, "q_pick_edit", 0)
    await cb.message.edit_text(text, reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.startswith("pickqs:"))
async def picked_question(cb:CallbackQuery, state:FSMContext):
    _, quiz_id, qid, page = cb.data.split(":")
    quiz_id = int(quiz_id); qid=int(qid); page=int(page)
    await show_question_details(cb.message.chat.id, quiz_id, qid, page, for_edit=True)
    await state.update_data(edit_question_id=qid)
    await cb.answer()

@dp.callback_query(F.data=="editm:text")
async def editm_text(cb:CallbackQuery, state:FSMContext):
    await state.set_state(EditQStates.edit_text)
    await cb.message.answer("Ø£Ø±Ø³Ù„ Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙƒØ§Ù…Ù„Ø© (Ø³Ø·Ø± Ø³Ø¤Ø§Ù„ + Ø®ÙŠØ§Ø±Ø§Øª).")
    await cb.answer()

@dp.callback_query(F.data=="editm:opts")
async def editm_opts(cb:CallbackQuery, state:FSMContext):
    await state.set_state(EditQStates.edit_options)
    await cb.message.answer("Ø£Ø±Ø³Ù„ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª ÙÙ‚Ø·ØŒ ÙƒÙ„ Ø®ÙŠØ§Ø± Ø¨Ø³Ø·Ø±ØŒ Ø¶Ø¹ âœ… Ø¹Ù„Ù‰ Ø§Ù„ØµØ­ÙŠØ­.")
    await cb.answer()

@dp.callback_query(F.data=="editm:att_add")
async def editm_att_add(cb:CallbackQuery, state:FSMContext):
    await state.set_state(EditQStates.attach_mode)
    kb=InlineKeyboardBuilder()
    kb.button(text="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ø®Ø§ØµØ© (Ø£Ø±Ø³Ù„ Ù…Ù„ÙØ§Øª)", callback_data="att:upload")
    kb.button(text="ğŸ“ Ù…Ù† Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©", callback_data="att:shared")
    kb.adjust(1)
    await cb.message.answer("Ø§Ø®ØªØ± Ø·Ø±ÙŠÙ‚Ø© Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(F.data=="editm:att_clear")
async def editm_att_clear(cb:CallbackQuery, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    q_exec("DELETE FROM question_attachments WHERE question_id=%s",(qid,))
    await state.clear()
    await cb.message.answer("ğŸ—‘ï¸ ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª.", reply_markup=owner_kb())
    await cb.answer()

@dp.message(EditQStates.edit_text, F.text)
async def apply_question_edit_full(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    if not qid: return
    qtext, opts = parse_q_block(msg.text)
    q_exec("UPDATE questions SET text=%s WHERE id=%s",(qtext,qid))
    q_exec("DELETE FROM options WHERE question_id=%s",(qid,))
    for i,(t,is_ok) in enumerate(opts):
        q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(qid,i,t,1 if is_ok else 0))
    await state.clear()
    await msg.answer("âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ®ÙŠØ§Ø±Ø§ØªÙ‡.", reply_markup=owner_kb())

@dp.message(EditQStates.edit_options, F.text)
async def apply_options_only(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    if not qid: return
    opts=parse_options_only(msg.text)
    correct = next((i for i,(_,ok) in enumerate(opts) if ok), None)
    q_exec("DELETE FROM options WHERE question_id=%s",(qid,))
    for i,(t,is_ok) in enumerate(opts):
        q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(qid,i,t,1 if is_ok else 0))
    if correct is None:
        await state.update_data(opt_count=len(opts))
        await state.set_state(EditQStates.correct_index)
        await msg.answer(f"Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØµØ­ÙŠØ­ (1..{len(opts)}):")
    else:
        await state.clear(); await msg.answer("âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª.", reply_markup=owner_kb())

@dp.message(EditQStates.correct_index, F.text.regexp(r"^\d+$"))
async def apply_options_correct_index(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d.get("edit_question_id")); cnt=int(d.get("opt_count",0))
    i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø·Ø§Ù‚.")
    q_exec("UPDATE options SET is_correct=0 WHERE question_id=%s",(qid,))
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear(); await msg.answer("âœ… ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©.", reply_markup=owner_kb())

@dp.callback_query(EditQStates.attach_mode, F.data.startswith("att:"))
async def edit_attach_mode(cb:CallbackQuery, state:FSMContext):
    mode=cb.data.split(":")[1]
    if mode=="upload":
        await state.set_state(EditQStates.attach_upload)
        await cb.message.answer("Ø£Ø±Ø³Ù„ ØµÙˆØ±/ÙÙˆÙŠØ³/Ø£ÙˆØ¯ÙŠÙˆ Ù„Ø¥Ø±ÙØ§Ù‚Ù‡Ø§ØŒ Ø«Ù… Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ….", reply_markup=done_button_kb("qatt"))
    elif mode=="shared":
        qid=(await state.get_data()).get("edit_question_id")
        await state.set_state(EditQStates.attach_shared)
        await cb.message.answer("Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ø«Ù… Ø§Ø¶ØºØ· âœ”ï¸ ØªÙ….", reply_markup=shared_list_kb(qid))
    await cb.answer()

@dp.message(EditQStates.attach_upload, F.photo | F.voice | F.audio)
async def edit_attach_upload(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    if msg.photo:
        await attach_file_to_question(qid, "photo", msg.photo[-1].file_id)
    elif msg.voice:
        await attach_file_to_question(qid, "voice", msg.voice.file_id)
    elif msg.audio:
        await attach_file_to_question(qid, "audio", msg.audio.file_id)

@dp.callback_query(EditQStates.attach_upload, F.data=="done:qatt")
async def edit_attach_upload_done(cb:CallbackQuery, state:FSMContext):
    await state.clear()
    await cb.message.answer("âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª.", reply_markup=owner_kb())
    await cb.answer()

@dp.callback_query(EditQStates.attach_shared, F.data.startswith("attadd:"))
async def edit_attach_shared_add(cb:CallbackQuery, state:FSMContext):
    _, qid_str, bid_str = cb.data.split(":")
    question_id = int(qid_str); bundle_id = int(bid_str)
    b = q_one("SELECT kind,file_id FROM shared_attachments WHERE id=%s",(bundle_id,))
    if not b:
        await cb.answer("ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.", show_alert=True); return
    await attach_file_to_question(question_id, b["kind"], b["file_id"])
    await cb.answer("ØªÙ… Ø±Ø¨Ø· Ù…Ø±ÙÙ‚.", show_alert=False)

@dp.callback_query(EditQStates.attach_shared, F.data.startswith("attdone:"))
async def edit_attach_shared_done(cb:CallbackQuery, state:FSMContext):
    await state.clear()
    await cb.message.answer("âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©.", reply_markup=owner_kb())
    await cb.answer()

# ================== Ø¨Ø±ÙŠÙ â€” ÙŠØ¯ÙˆÙŠ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ ==================
MANUAL_CLOSES_AT = "9999-12-31T23:59:59+00:00"

def open_window_manual(chat_id:int, owner:int, prompt:str)->Tuple[int,datetime]:
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))
    opened=_now()
    bid = insert_returning_id(
        """INSERT INTO brief_windows(origin_chat_id,opened_by,opened_at,closes_at,is_open,prompt_text)
              VALUES (%s,%s,%s,%s,1,%s)""",
        (chat_id,owner,opened.isoformat(),MANUAL_CLOSES_AT,prompt)
    )
    return bid, opened

def close_window(chat_id:int):
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))

@dp.message(Command("brief"))
@dp.message(F.text==BTN_BRIEF)
async def brief_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await state.set_state(BriefStates.waiting_prompt)
    await msg.answer("âœï¸ Ø£Ø±Ø³Ù„ Ù†Øµ Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ/Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ (B1 DTZ):", reply_markup=owner_kb())

@dp.message(BriefStates.waiting_prompt, F.text)
async def brief_got_prompt(msg:Message, state:FSMContext):
    try:
        prompt=msg.text.strip()
        migrate_schema()
        bid, _ = open_window_manual(msg.chat.id, msg.from_user.id, prompt)
        kb = InlineKeyboardBuilder()
        kb.button(text="â›” Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„", callback_data="briefstop")
        kb.adjust(1)
        m = await msg.answer(
            f"ğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
            f"âœ³ï¸ Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ <b>ÙŠØ¯ÙˆÙŠ</b> â€” Ø§Ø¶ØºØ· â›” Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡.\n"
            f"Ø£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ù‡Ù†Ø§ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©.",
            reply_markup=kb.as_markup()
        )
        q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
        await state.clear()
    except Exception as e:
        await msg.reply(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¨Ø±ÙŠÙ: <code>{html.escape(str(e))}</code>")

# ---------- Ù…ØµØ­Ù‘Ø­ Ù…Ø¬Ø§Ù†ÙŠ Ø¨Ø³ÙŠØ· ----------
def free_b1_grade(text: str) -> Tuple[int, Dict]:
    raw = text.strip()
    t = raw.lower()

    words = re.findall(r"[A-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸ]+", raw)
    wc = len(words)
    sents = re.split(r"[.!?ØŸ!]+", raw)
    sents = [s.strip() for s in sents if s.strip()]
    scount = len(sents)

    if 70 <= wc <= 140: length_score = 3
    elif 55 <= wc < 70 or 140 < wc <= 170: length_score = 2
    elif 40 <= wc < 55 or 170 < wc <= 220: length_score = 1
    else: length_score = 0

    greeting_patterns = [r"sehr geehrte", r"guten tag", r"hallo"]
    closing_patterns = [r"mit freundlichen grÃ¼ÃŸen", r"mit freundlichen gru[e|ÃŸ]en", r"\bmfg\b"]
    has_greet = any(re.search(p, t) for p in greeting_patterns)
    has_close = any(re.search(p, t) for p in closing_patterns)
    lines = [ln.strip() for ln in raw.splitlines() if ln.strip()]
    last_block = " ".join(lines[-3:]).strip() if lines else raw
    has_name_like = bool(re.search(r"[A-ZÃ„Ã–Ãœ][a-zÃ¤Ã¶Ã¼ÃŸ]{2,}\s+[A-ZÃ„Ã–Ãœ][a-zÃ¤Ã¶Ã¼ÃŸ]{2,}", last_block))

    structure_score = (2 if has_greet else 0) + (1 if has_close else 0) + (1 if has_name_like else 0)

    months = ["januar","februar","mÃ¤rz","maerz","april","mai","juni","juli","august","september","oktober","november","dezember","dez."]
    move_rx = r"(umzug|einzug|auszug|ab dem|ab\s+[\d\.]+\s+(%s)|am\s+[\d\.]+\s+(%s))" % ("|".join(months),"|".join(months))
    reason_rx = r"(ich\s+(mÃ¶chte|will|muss)\s+.*(schreiben|melden)|wegen|grund|anzeige|ich\s+schreibe)"
    apt_rx = r"(wohnung|zimmer|balkon|kÃ¼che|bad|hell|groÃŸ|gross|ruhig|familie)"
    cost_rx = r"(miete|kaltmiete|warmmiete|nebenkosten|kosten|â‚¬|euro|\b\d+\s*â‚¬)"

    cover = {
        "reason": bool(re.search(reason_rx, t)),
        "apartment": bool(re.search(apt_rx, t)),
        "costs": bool(re.search(cost_rx, t)),
        "date": bool(re.search(move_rx, t)),
    }

    coverage_score = 0
    for k, ok in cover.items():
        if ok: coverage_score += 2
        else:
            if k == "reason" and ("suche" in t or "interesse" in t): coverage_score += 1
            elif k == "apartment" and ("lage" in t or "qm" in t): coverage_score += 1
            elif k == "costs" and re.search(r"\b\d+\b", t): coverage_score += 1
            elif k == "date" and ("sofort" in t or "ab sofort" in t): coverage_score += 1

    connectors = ["weil","dass","deshalb","auÃŸerdem","ausserdem","dann","damit","obwohl","aber","oder","und"]
    conn_used = sum(1 for c in connectors if re.search(r"\b"+c+r"\b", t))
    if conn_used >= 4: cohesion_score = 3
    elif conn_used >= 2: cohesion_score = 2
    elif conn_used == 1: cohesion_score = 1
    else: cohesion_score = 0

    avg_len = (wc / scount) if scount else wc
    if scount >= 5 and 8 <= avg_len <= 20: sentence_score = 2
    elif scount >= 3: sentence_score = 1
    else: sentence_score = 0

    total = structure_score + coverage_score + length_score + cohesion_score + sentence_score
    total = max(0, min(20, int(round(total))))

    tips = []
    if not has_greet: tips.append("Ø£Ø¶Ù ØªØ­ÙŠØ© Ø±Ø³Ù…ÙŠØ© Ù…Ø«Ù„: <i>Sehr geehrte Damen und Herren,</i>")
    if not has_close: tips.append("Ø§Ø®ØªÙ… Ø¨Ù€ <i>Mit freundlichen GrÃ¼ÃŸen</i> ÙˆØ§Ø³Ù…Ùƒ.")
    if not cover["reason"]: tips.append("Ø§Ø°ÙƒØ± Ø³Ø¨Ø¨ Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø¨ÙˆØ¶ÙˆØ­.")
    if not cover["apartment"]: tips.append("ØµÙ Ø§Ù„Ø´Ù‚Ø© (Ø§Ù„ØºØ±Ù/Ø§Ù„Ù†ÙˆØ±/Ø§Ù„Ø¨Ù„ÙƒÙˆÙ†).")
    if not cover["costs"]: tips.append("Ø§Ø°ÙƒØ± Ø§Ù„Ø¥ÙŠØ¬Ø§Ø± ÙˆØ§Ù„ØªÙƒØ§Ù„ÙŠÙ Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù….")
    if not cover["date"]: tips.append("Ø­Ø¯Ù‘Ø¯ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥ØªØ§Ø­Ø© (z.B. ab dem 1. Oktober).")
    if conn_used < 2: tips.append("Ø§Ø³ØªØ®Ø¯Ù… Ø±ÙˆØ§Ø¨Ø·: weil, deshalb, auÃŸerdem, damitâ€¦")

    feedback = "Ø¬ÙŠØ¯ Ø¬Ø¯Ù‹Ø§ØŒ Ø§Ø³ØªÙ…Ø±Ù‘." if not tips else "Ø› ".join(tips)
    return total, {"feedback": feedback}

def brief_level(score: int) -> str:
    if score <= 6: return "Unter A2"
    if score <= 14: return "A2"
    return "B1"

@dp.message(
    StateFilter("*"),
    F.text,
    ~F.text.in_(ALL_BTN_TEXTS),
    ~F.text.startswith("/"),
    F.from_user.as_('u')
)
async def collect_briefs(msg:Message, u):
    if getattr(u, "is_bot", False):
        return
    row = q_one("SELECT id,closes_at FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(msg.chat.id,))
    if not row:
        return
    if row["closes_at"] <= _now().isoformat():
        q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s",(row["id"],))
        return
    text=msg.text.strip()
    score, details = free_b1_grade(text)
    lvl = brief_level(score)
    q_exec("""INSERT INTO writing_submissions(origin_chat_id,quiz_id,user_id,username,text,score,level,evaluated_at,details_json,window_id)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)""",
           (msg.chat.id,0,msg.from_user.id,(msg.from_user.username or ""),text,score,lvl,_now().isoformat(),json.dumps(details,ensure_ascii=False),row["id"]))

@dp.callback_query(F.data=="briefstop")
async def brief_stop(cb:CallbackQuery):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    w = q_one("SELECT id,prompt_text FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(cb.message.chat.id,))
    if not w:
        return await cb.message.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø§ÙØ°Ø© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ù…ÙØªÙˆØ­Ø©.", reply_markup=owner_kb())
    close_window(cb.message.chat.id)
    rows = q_all("""SELECT user_id, COALESCE(NULLIF(username,''),'Ù…Ø¬Ù‡ÙˆÙ„') AS uname, score, level, details_json, evaluated_at
                    FROM writing_submissions
                    WHERE origin_chat_id=%s AND window_id=%s
                    ORDER BY evaluated_at ASC""", (cb.message.chat.id, w["id"]))
    by_user: Dict[int, dict] = {}
    for r in rows:
        by_user[r["user_id"]] = r
    if not by_user:
        return await cb.message.answer("â›” ØªÙ… Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù â€” Ù„Ù… ØªØµÙ„ Ø£ÙŠ Ù…Ø´Ø§Ø±ÙƒØ§Øª.", reply_markup=owner_kb())
    results = sorted(by_user.values(), key=lambda x: (-int(x["score"]), x["uname"]))
    lines = []
    for i, r in enumerate(results, 1):
        fb = ""
        try:
            det = json.loads(r["details_json"] or "{}"); fb = det.get("feedback","")
        except Exception:
            pass
        fb_short = (fb[:120] + "â€¦") if len(fb) > 120 else fb
        lines.append(f"{i:>2}. {html.escape(r['uname'])} â€” <b>{int(r['score'])}/20</b> â€” {html.escape(r['level'])}" + (f"\n    ğŸ“ {fb_short}" if fb_short else ""))
    header = f"â›” <b>ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„</b>\nğŸ“£ <b>Ø³Ø¤Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ:</b> {html.escape(w.get('prompt_text') or '')}\n\n<b>Ø§Ù„Ù†ØªØ§Ø¦Ø¬:</b>"
    await send_long(cb.message.chat.id, header + "\n" + "\n".join(lines))

# ---------- Ø¥Ø±Ø³Ø§Ù„ Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ ----------
async def send_question_attachments(chat_id:int, question_id:int):
    atts = q_all("SELECT kind,file_id FROM question_attachments WHERE question_id=%s ORDER BY position",(question_id,))
    for a in atts:
        kind=a["kind"]; fid=a["file_id"]
        try:
            if kind=="photo": await bot.send_photo(chat_id, fid)
            elif kind=="voice": await bot.send_voice(chat_id, fid)
            elif kind=="audio": await bot.send_audio(chat_id, fid)
            try: await sleep_jitter('attach')
            except Exception: await asyncio.sleep(0.8)
        except Exception as e:
            ra = getattr(e,'retry_after',None) or getattr(e,'timeout',None)
            try: await asyncio.sleep(float(ra)+1 if ra else 2.0)
            except Exception: pass

# ---------- Ù†Ø´Ø± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± + Ø§Ø®ØªÙŠØ§Ø± ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… ----------
@dp.message(F.text==BTN_PUBLISH)
async def publish_entry(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù†Ø´Ø±Ù‡Ø§.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"ğŸš€ Ù†Ø´Ø± {r['id']} â€” {r['title']}", callback_data=f"pub:{r['id']}")
    kb.adjust(1)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„Ù„Ù†Ø´Ø± ÙƒÙ€ Quiz Polls:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("pub:"))
async def publish_pick_hours(cb:CallbackQuery, state:FSMContext):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    quiz_id = int(cb.data.split(":")[1])
    await state.update_data(pub_quiz_id=quiz_id)
    await cb.message.answer("Ø§Ø®ØªØ± Ù…Ø¤Ù‚Ù‘Øª Ø§Ù„Ù†Ø´Ø± (Ø¨Ø§Ù„Ø³Ø§Ø¹Ø§Øª):", reply_markup=publish_hours_kb(quiz_id))
    await cb.answer()

def normalize_arabic_digits(s:str)->str:
    DIGITS_AR = "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©"
    return s.translate({ord(a): str(i) for i,a in enumerate(DIGITS_AR)})

@dp.callback_query(F.data.startswith("pubdur:"))
async def publish_with_hours_decide(cb:CallbackQuery, state:FSMContext):
    _, qid_str, token = cb.data.split(":")
    quiz_id = int(qid_str)
    if token == "custom":
        await state.set_state(PublishStates.waiting_hours_custom)
        await state.update_data(pub_quiz_id=quiz_id)
        await cb.message.answer("Ø§ÙƒØªØ¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø§Øª (Ù…Ø«Ø§Ù„: 2 Ø£Ùˆ Ù¢).")
        return await cb.answer()
    hours = int(token)
    await state.update_data(pub_hours=hours, pub_quiz_id=quiz_id)
    await cb.message.answer("Ù‡Ù„ ØªØ±ÙŠØ¯ ØªÙØ¹ÙŠÙ„ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø·Ø§Ù„Ø¨ Ø­Ø³Ø¨ Ø¹Ù„Ø§Ù…ØªÙ‡ØŸ", reply_markup=publish_eval_kb(quiz_id, hours))
    await cb.answer()

@dp.message(PublishStates.waiting_hours_custom, F.text)
async def publish_hours_custom(msg:Message, state:FSMContext):
    raw = normalize_arabic_digits(msg.text)
    m = re.search(r"(\d{1,3})", raw)
    if not m:
        return await msg.reply("Ø§ÙƒØªØ¨ Ø±Ù‚Ù… Ø§Ù„Ø³Ø§Ø¹Ø§Øª ÙÙ‚Ø· (1..240).")
    hours = int(m.group(1)); hours = max(1, min(240, hours))
    quiz_id = int((await state.get_data()).get("pub_quiz_id"))
    await state.update_data(pub_hours=hours, pub_quiz_id=quiz_id)
    await msg.answer("Ù‡Ù„ ØªØ±ÙŠØ¯ ØªÙØ¹ÙŠÙ„ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø·Ø§Ù„Ø¨ Ø­Ø³Ø¨ Ø¹Ù„Ø§Ù…ØªÙ‡ØŸ", reply_markup=publish_eval_kb(quiz_id, hours))

@dp.callback_query(F.data.startswith("pubeval:"))
async def publish_eval_choice(cb: CallbackQuery, state: FSMContext):
    _, quiz_id, hours, flag = cb.data.split(":")
    quiz_id = int(quiz_id); hours = int(hours); grade_enabled = int(flag)==1
    await _publish_quiz_now(cb, quiz_id, hours, grade_enabled)
    await state.clear()
    await cb.answer()

async def _publish_quiz_now(cb_or_dummy, quiz_id:int, hours:int, grade_enabled:bool):
    chat_id = cb_or_dummy.message.chat.id
    expiry_iso = None
    if hours and hours > 0:
        expiry = _now() + timedelta(hours=hours)
        expiry_iso = expiry.isoformat()

    # Ø£Ù†Ø´Ø¦ Ø¬Ù„Ø³Ø© Ù†Ø´Ø± (run)
    run_id = insert_returning_id(
        "INSERT INTO quiz_runs(chat_id,quiz_id,published_at,grade_enabled) VALUES (%s,%s,%s,%s)",
        (chat_id, quiz_id, _now().isoformat(), 1 if grade_enabled else 0)
    )

    questions = q_all("SELECT id, text FROM questions WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    sent = 0
    for q in questions:
        try:
            await send_question_attachments(chat_id, q["id"])
        except Exception:
            try: await cb_or_dummy.message.answer(f"âš ï¸ ØªØ¹Ø°Ù‘Ø± Ø¥Ø±Ø³Ø§Ù„ Ù…Ø±ÙÙ‚Ø§Øª Ù„Ù„Ø³Ø¤Ø§Ù„ {q['id']}.")
            except Exception: pass

        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        if len(opts) < 2: continue
        correct = next((o for o in opts if int(o.get("is_correct",0))==1), None) or opts[0]
        selected = list(opts[:10]) if len(opts) <= 10 else [correct] + [o for o in opts if int(o.get("is_correct",0))!=1][:9]
        question_text = str(q["text"])[:295]
        options_text = [str(o["text"])[:100] for o in selected]
        correct_index = selected.index(correct)

        try:
            m = await bot.send_poll(
                chat_id=chat_id, question=question_text, options=options_text,
                type=PollType.QUIZ, correct_option_id=correct_index, is_anonymous=False,
            )
            q_exec(
                "INSERT INTO sent_polls (chat_id,quiz_id,question_id,poll_id,message_id,expires_at,is_closed,run_id) VALUES (%s,%s,%s,%s,%s,%s,0,%s)",
                (chat_id, quiz_id, q["id"], m.poll.id, m.message_id, expiry_iso, run_id)
            )
            sent += 1
            try: await sleep_jitter("poll")
            except Exception: await asyncio.sleep(0.8)
        except Exception as e:
            try: await cb_or_dummy.message.answer(f"âš ï¸ ØªØ¹Ø°Ù‘Ø± Ù†Ø´Ø± Ø³Ø¤Ø§Ù„ ID {q['id']}: {e}")
            except Exception: pass
            try:
                ra = getattr(e, "retry_after", None) or getattr(e, "timeout", None)
                await asyncio.sleep(float(ra)+1 if ra else 2.0)
            except Exception: pass
            continue

    await cb_or_dummy.message.answer(
        f"ğŸš€ ØªÙ… Ù†Ø´Ø± {sent} Ø³Ø¤Ø§Ù„Ù‹Ø§ Ù…Ù† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± {quiz_id}"
        + (f" â€” Ø§Ù„Ù…Ø¤Ù‚Ù‘Øª: {hours} Ø³Ø§Ø¹Ø©" if hours and hours>0 else " â€” Ø¨Ø¯ÙˆÙ† Ù…Ø¤Ù‚Ù‘Øª")
        + (", Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ù…ÙÙØ¹Ù‘Ù„ âœ…" if grade_enabled else ", Ø¨Ø¯ÙˆÙ† ØªÙ‚ÙŠÙŠÙ… âŒ"),
        reply_markup=owner_kb()
    )

# ---------- Ø¥ØºÙ„Ø§Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø§Ø³ØªØ·Ù„Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© ----------
async def close_expired_polls_loop():
    while True:
        try:
            rows = q_all("""
                SELECT chat_id, message_id, id
                FROM sent_polls
                WHERE is_closed=0 AND expires_at IS NOT NULL AND expires_at <= %s
                ORDER BY id ASC
                LIMIT 20
            """, (_now().isoformat(),))
            for r in rows:
                try:
                    await bot.stop_poll(chat_id=r["chat_id"], message_id=r["message_id"])
                except Exception:
                    pass
                q_exec("UPDATE sent_polls SET is_closed=1 WHERE id=%s",(r["id"],))
        except Exception:
            pass
        await asyncio.sleep(30)

# ---------- ØªÙØ§Ø¹Ù„ Ù…Ø¹ Poll + Ø¥Ø¹Ù„Ø§Ù† Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¹Ù†Ø¯ Ø¥ÙƒÙ…Ø§Ù„ ÙƒÙ„ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ----------
def quiz_level_from_score(correct:int, total:int) -> str:
    # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø¥Ù„Ù‰ Ù…Ù‚ÙŠØ§Ø³ Ù…Ù† 45 Ø«Ù… ØªØµÙ†ÙŠÙ
    if total <= 0: return "-"
    scaled = int(round((correct / total) * 45))
    if scaled <= 19: return "Unter A2"
    if scaled <= 32: return "A2"
    return "B1"

@dp.poll_answer()
async def on_poll_answer(pa: PollAnswer):
    poll_id = pa.poll_id
    chosen = pa.option_ids[0] if pa.option_ids else -1
    u = pa.user
    sp = q_one("SELECT chat_id, quiz_id, question_id, message_id, expires_at, is_closed, run_id FROM sent_polls WHERE poll_id=%s",(poll_id,))
    if not sp: return
    if sp["is_closed"]: return
    if sp["expires_at"] and sp["expires_at"] <= _now().isoformat(): return

    chat_id = sp["chat_id"]; quiz_id=sp["quiz_id"]; qid=sp["question_id"]; message_id=sp["message_id"]; run_id=sp.get("run_id")

    opt = q_one("SELECT is_correct FROM options WHERE question_id=%s AND option_index=%s",(qid,chosen))
    is_ok = int(opt["is_correct"]) if opt else 0

    q_exec("""INSERT INTO quiz_responses(chat_id,quiz_id,question_id,user_id,username,option_index,is_correct,answered_at,run_id)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s)""",
           (chat_id,quiz_id,qid,u.id, u.username or (u.full_name or ""), chosen, is_ok, _now().isoformat(), run_id))

    try:
        emoji = "ğŸ‰" if is_ok else "âŒ"
        await bot.set_message_reaction(chat_id=chat_id, message_id=message_id, reaction=[ReactionTypeEmoji(emoji=emoji)], is_big=True)
    except Exception:
        pass

    # Ø¹Ù†Ø¯ Ø¥ÙƒÙ…Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø£Ø¹Ù„Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© (Ù…Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¥Ø°Ø§ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ù…ÙÙØ¹Ù‘Ù„)
    try:
        total_polls = q_one("SELECT COUNT(*) AS c FROM sent_polls WHERE run_id=%s",(run_id,))["c"]
        answered = q_one("SELECT COUNT(DISTINCT question_id) AS c FROM quiz_responses WHERE run_id=%s AND user_id=%s",(run_id,u.id))["c"]
        if answered == total_polls and total_polls > 0:
            correct = q_one("SELECT COALESCE(SUM(is_correct),0) AS s FROM quiz_responses WHERE run_id=%s AND user_id=%s",(run_id,u.id))["s"]
            run = q_one("SELECT grade_enabled FROM quiz_runs WHERE id=%s",(run_id,))
            msg = f"ğŸ“Š Ù†ØªÙŠØ¬Ø© {mention_html(u.id, u.full_name or u.username or 'Ø·Ø§Ù„Ø¨')}: <b>{int(correct)}/{int(total_polls)}</b>"
            if run and int(run["grade_enabled"])==1:
                lvl = quiz_level_from_score(int(correct), int(total_polls))
                msg += f"\nğŸ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <b>{lvl}</b>"
            await bot.send_message(chat_id, msg, parse_mode=ParseMode.HTML)
    except Exception:
        pass

        # ================== Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù„Ø³Ø© Ø§Ù„Ù†Ø´Ø± ==================
class ScoreStates(StatesGroup):
    pick_chat = State()
    pick_quiz = State()
    pick_run  = State()

# ØµÙØ­Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ØªÙŠ Ù„Ø¯ÙŠÙ‡Ø§ Ø¬Ù„Ø³Ø§Øª Ù†Ø´Ø± (Ù…Ø±ØªØ¨ Ø­Ø³Ø¨ Ø£Ø­Ø¯Ø« Run)
def score_chats_page(page:int=0, per_page:int=5):
    rows = q_all("""
        SELECT chat_id, MAX(id) AS last_run
        FROM quiz_runs
        GROUP BY chat_id
        ORDER BY last_run DESC
    """)
    chunk, page, pages, total = _paginate(rows, page, per_page)
    kb = InlineKeyboardBuilder()
    for r in chunk:
        cid = int(r["chat_id"])
        title = chat_title_cached(cid)
        kb.button(text=f"ğŸ‘¥ {title}", callback_data=f"scorechat:{cid}:0")
    if page > 0:
        kb.button(text="â¬…ï¸ Ø§Ù„Ø³Ø§Ø¨Ù‚", callback_data=f"pgch:{page-1}")
    if page < pages-1:
        kb.button(text="Ø§Ù„ØªØ§Ù„ÙŠ â¡ï¸", callback_data=f"pgch:{page+1}")
    kb.adjust(1)
    return kb.as_markup(), total, pages, page

@dp.message(F.text==BTN_SCORE)
async def score_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await state.set_state(ScoreStates.pick_chat)
    kb, total, pages, page = score_chats_page(0)
    if total == 0:
        return await msg.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙÙŠÙ‡Ø§ Ø¬Ù„Ø³Ø§Øª Ù†Ø´Ø± Ø¨Ø¹Ø¯.", reply_markup=owner_kb())
    await msg.answer(_qs_page_text_header("ğŸ", "Ù†ØªØ§Ø¦Ø¬ â€” Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©", total, page, pages), reply_markup=kb)

@dp.callback_query(ScoreStates.pick_chat, F.data.startswith("pgch:"))
async def score_chats_nav(cb:CallbackQuery, state:FSMContext):
    page = int(cb.data.split(":")[1])
    kb, total, pages, page = score_chats_page(page)
    try:
        await cb.message.edit_text(_qs_page_text_header("ğŸ", "Ù†ØªØ§Ø¦Ø¬ â€” Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©", total, page, pages), reply_markup=kb)
    except Exception:
        await cb.message.answer(_qs_page_text_header("ğŸ", "Ù†ØªØ§Ø¦Ø¬ â€” Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©", total, page, pages), reply_markup=kb)
    await cb.answer()

@dp.callback_query(ScoreStates.pick_chat, F.data.startswith("scorechat:"))
async def score_pick_chat(cb:CallbackQuery, state:FSMContext):
    _, chat_id, _ = cb.data.split(":")
    chat_id = int(chat_id)
    try:
        await cache_chat_title(chat_id)
    except Exception:
        pass
    await state.update_data(score_chat_id=chat_id)
    kb, total, pages, page = _quizzes_page("ql_pick_score", 0)
    title = chat_title_cached(chat_id)
    await state.set_state(ScoreStates.pick_quiz)
    await cb.message.answer(_qs_page_text_header("ğŸ§ª", f"Ù†ØªØ§Ø¦Ø¬ â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ â€” {title}", total, page, pages), reply_markup=kb)
    await cb.answer()

@dp.callback_query(ScoreStates.pick_quiz, F.data.startswith("scorepick:"))
async def score_pick_quiz(cb:CallbackQuery, state:FSMContext):
    data = await state.get_data()
    chat_id = int(data.get("score_chat_id"))
    _, quiz_id, _ = cb.data.split(":")
    quiz_id = int(quiz_id)
    await state.update_data(score_quiz_id=quiz_id)

    runs = q_all("""
        SELECT r.id, r.published_at, r.grade_enabled, COUNT(sp.id)::int AS qcount
        FROM quiz_runs r
        LEFT JOIN sent_polls sp ON sp.run_id=r.id
        WHERE r.chat_id=%s AND r.quiz_id=%s
        GROUP BY r.id, r.published_at, r.grade_enabled
        ORDER BY r.id DESC
    """, (chat_id, quiz_id))

    title = chat_title_cached(chat_id)
    if not runs:
        await cb.message.answer(f"Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª Ù†Ø´Ø± Ù„Ù‡Ø°Ø§ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙÙŠ Â«{html.escape(title)}Â».", reply_markup=owner_kb())
        return await cb.answer()

    kb = InlineKeyboardBuilder()
    for r in runs[:50]:
        dt = (r["published_at"] or "").replace("T"," ").split(".")[0].replace("+00:00","")
        tag = "âœ… ØªÙ‚ÙŠÙŠÙ…" if int(r["grade_enabled"])==1 else "âŒ Ø¨Ø¯ÙˆÙ† ØªÙ‚ÙŠÙŠÙ…"
        kb.button(text=f"ğŸ•’ {dt} â€” {r['qcount']} Ø³. â€” {tag}", callback_data=f"scorerun:{r['id']}")
    kb.adjust(1)
    await state.set_state(ScoreStates.pick_run)
    await cb.message.answer(f"Ø§Ø®ØªØ± Ø¬Ù„Ø³Ø© Ø§Ù„Ù†Ø´Ø± â€” Â«{html.escape(title)}Â»:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(ScoreStates.pick_run, F.data.startswith("scorerun:"))
async def score_show_run(cb:CallbackQuery, state:FSMContext):
    run_id = int(cb.data.split(":")[1])
    data = await state.get_data()
    chat_id = int(data.get("score_chat_id"))
    quiz_id = int(data.get("score_quiz_id"))
    title = chat_title_cached(chat_id)

    total_q = q_one("SELECT COUNT(*) AS c FROM sent_polls WHERE run_id=%s",(run_id,))["c"]
    if int(total_q) == 0:
        await cb.message.answer(f"Â«{html.escape(title)}Â» â€” Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ø¦Ù„Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¬Ù„Ø³Ø©.", reply_markup=owner_kb())
        await state.clear()
        return await cb.answer()

    run_row = q_one("SELECT published_at, grade_enabled FROM quiz_runs WHERE id=%s",(run_id,))
    pub_txt = (run_row["published_at"] or "").replace("T"," ").split(".")[0].replace("+00:00","")
    grade_enabled = int(run_row["grade_enabled"])

    rows = q_all("""
        SELECT user_id,
               COALESCE(NULLIF(username,''),'Ù…Ø¬Ù‡ÙˆÙ„') AS uname,
               SUM(is_correct)::int AS correct
        FROM quiz_responses
        WHERE run_id=%s
        GROUP BY user_id, uname
        ORDER BY correct DESC, user_id ASC
        LIMIT 200
    """, (run_id,))

    lines=[]
    for i,r in enumerate(rows,1):
        base = f"{i:>2}. {html.escape(r['uname'])} â€” {int(r['correct'])}/{int(total_q)}"
        if grade_enabled==1:
            lvl = quiz_level_from_score(int(r['correct']), int(total_q))
            base += f" â€” {lvl}"
        lines.append(base)

    header = (
        f"ğŸ <b>Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¬Ù„Ø³Ø© â€” {html.escape(title)}</b>\n"
        f"ğŸ§ª Quiz ID: <code>{quiz_id}</code>\n"
        f"ğŸ†” Run: <code>{run_id}</code>\n"
        f"ğŸ•’ Ù†Ø´Ø±: <code>{pub_txt}</code>\n"
        f"ğŸ”¢ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©: <b>{int(total_q)}</b>\n"
        f"ğŸ§® Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: {'Ù…ÙÙØ¹Ù‘Ù„ âœ…' if grade_enabled==1 else 'ØºÙŠØ± Ù…ÙÙØ¹Ù‘Ù„ âŒ'}\n\n"
    )
    await cb.message.answer(header + ("\n".join(lines) if lines else "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø§Ø±ÙƒØ§Øª Ø¨Ø¹Ø¯."), reply_markup=owner_kb())
    await state.clear()
    await cb.answer()
# ================== Ù†Ù‡Ø§ÙŠØ© Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ==================


# ================== Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ (Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¬Ù…ÙˆØ¹Ø© Ø«Ù… Ù†Ø§ÙØ°Ø©) ==================

@dp.message(F.text==BTN_BRIEF_RESULTS)
async def brief_scores_entry(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await state.set_state(BriefScoreStates.pick_chat)

    # ØªØ­Ø¯ÙŠØª/ØªØ®Ø²ÙŠÙ† Ø§Ø³Ù… Ø§Ù„Ø´Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠ Ø§Ø­ØªÙŠØ§Ø·Ù‹Ø§
    try:
        await cache_chat_title(msg.chat.id)
    except Exception:
        pass

    kb, total, pages, page = brief_chats_page(0)
    if total == 0:
        return await msg.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ÙˆØ§ÙØ° Ø¨Ø±ÙŠÙ ÙÙŠ Ø£ÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ø¹Ø¯.", reply_markup=owner_kb())
    await msg.answer(_qs_page_text_header("ğŸ“ˆ", "Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ â€” Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©", total, page, pages), reply_markup=kb)

@dp.callback_query(BriefScoreStates.pick_chat, F.data.startswith("bpgch:"))
async def brief_chats_nav(cb: CallbackQuery, state: FSMContext):
    page = int(cb.data.split(":")[1])
    kb, total, pages, page = brief_chats_page(page)
    try:
        await cb.message.edit_text(_qs_page_text_header("ğŸ“ˆ", "Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ â€” Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©", total, page, pages), reply_markup=kb)
    except Exception:
        await cb.message.answer(_qs_page_text_header("ğŸ“ˆ", "Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ â€” Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©", total, page, pages), reply_markup=kb)
    await cb.answer()

@dp.callback_query(BriefScoreStates.pick_chat, F.data.startswith("bscorechat:"))
async def brief_pick_chat(cb: CallbackQuery, state: FSMContext):
    _, chat_id, _ = cb.data.split(":")
    chat_id = int(chat_id)
    try:
        await cache_chat_title(chat_id)
    except Exception:
        pass
    await state.update_data(brief_chat_id=chat_id)
    title = chat_title_cached(chat_id)

    kb, total, pages, page = brief_windows_page(chat_id, 0)
    await state.set_state(BriefScoreStates.pick_window)
    if total == 0:
        await cb.message.answer(f"Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ÙˆØ§ÙØ° Ø¨Ø±ÙŠÙ ÙÙŠ Â«{html.escape(title)}Â».", reply_markup=owner_kb())
    else:
        await cb.message.answer(_qs_page_text_header("ğŸªª", f"Ù†ÙˆØ§ÙØ° Ø§Ù„Ø¨Ø±ÙŠÙ â€” {title}", total, page, pages), reply_markup=kb)
    await cb.answer()

@dp.callback_query(BriefScoreStates.pick_window, F.data.startswith("bpgw:"))
async def brief_windows_nav(cb: CallbackQuery, state: FSMContext):
    _, chat_id, page = cb.data.split(":")
    chat_id = int(chat_id); page = int(page)
    kb, total, pages, page = brief_windows_page(chat_id, page)
    title = chat_title_cached(chat_id)
    try:
        await cb.message.edit_text(_qs_page_text_header("ğŸªª", f"Ù†ÙˆØ§ÙØ° Ø§Ù„Ø¨Ø±ÙŠÙ â€” {title}", total, page, pages), reply_markup=kb)
    except Exception:
        await cb.message.answer(_qs_page_text_header("ğŸªª", f"Ù†ÙˆØ§ÙØ° Ø§Ù„Ø¨Ø±ÙŠÙ â€” {title}", total, page, pages), reply_markup=kb)
    await cb.answer()

@dp.callback_query(BriefScoreStates.pick_window, F.data.startswith("bshoww:"))
async def brief_show_window(cb: CallbackQuery, state: FSMContext):
    window_id = int(cb.data.split(":")[1])
    await render_brief_window_results(cb.message.chat.id, window_id)
    await state.clear()
    await cb.answer()

# ================== Ù†Ù‡Ø§ÙŠØ© Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ ==================

# ================== ØªØµØ¯ÙŠØ±/Ø§Ø³ØªÙŠØ±Ø§Ø¯ ==================
@dp.message(F.text==BTN_EXPORT)
async def export_entry(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"ğŸ“¤ ØªØµØ¯ÙŠØ± {r['id']} â€” {r['title']}", callback_data=f"export:{r['id']}")
    kb.adjust(1)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„ØªØµØ¯ÙŠØ±Ù‡ ÙƒÙ…Ù„Ù JSON:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("export:"))
async def do_export(cb:CallbackQuery):
    quiz_id = int(cb.data.split(":")[1])
    qrow = q_one("SELECT id,title FROM quizzes WHERE id=%s",(quiz_id,))
    if not qrow:
        await cb.message.answer("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±."); return await cb.answer()
    qs = q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    payload = {"title": qrow["title"], "questions": []}
    for q in qs:
        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        payload["questions"].append({
            "text": q["text"],
            "options": [{"text": o["text"], "is_correct": int(o["is_correct"])==1} for o in opts]
        })
    with tempfile.NamedTemporaryFile("w", delete=False, suffix=f"_quiz_{quiz_id}.json", encoding="utf-8") as tf:
        json.dump(payload, tf, ensure_ascii=False, indent=2)
        temp_path = tf.name
    await bot.send_document(cb.message.chat.id, FSInputFile(temp_path, filename=f"quiz_{quiz_id}.json"), caption=f"ğŸ“¤ ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± {quiz_id}")
    await cb.answer()

@dp.message(F.text==BTN_IMPORT)
async def import_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(ImportStates.waiting_json)
    await msg.answer("ğŸ“¥ Ø§Ø±ÙØ¹ Ù…Ù„Ù <b>.json</b> Ø¨Ù†ÙØ³ ØµÙŠØºØ© Ø§Ù„ØªØµØ¯ÙŠØ±ØŒ Ø£Ùˆ Ø£Ù„ØµÙ‚ JSON ÙƒÙ†Øµ.")

@dp.message(ImportStates.waiting_json, F.document)
async def import_from_file(msg:Message, state:FSMContext):
    try:
        doc = msg.document
        if not (doc.file_name.lower().endswith(".json") or (doc.mime_type and "json" in doc.mime_type)):
            return await msg.reply("âŒ Ø±Ø¬Ø§Ø¡Ù‹ Ø§Ø±ÙØ¹ Ù…Ù„Ù JSON Ø¨Ø§Ù…ØªØ¯Ø§Ø¯ .json")
        with tempfile.NamedTemporaryFile("wb", delete=False, suffix=".json") as tf:
            temp_path = tf.name
        try:
            await bot.download(doc, destination=temp_path)
        except Exception:
            f: File = await bot.get_file(doc.file_id)
            await bot.download(f, destination=temp_path)
        with open(temp_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        quiz_id = await _import_payload_create_quiz(data, msg.from_user.id)
        await state.clear()
        await msg.answer(f"âœ… ØªÙ… Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ø§Ù„Ù…Ù„Ù ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ID {quiz_id}.", reply_markup=owner_kb())
    except Exception as e:
        await msg.answer(f"âŒ ÙØ´Ù„ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ø§Ù„Ù…Ù„Ù: <code>{html.escape(str(e))}</code>")

@dp.message(ImportStates.waiting_json, F.text)
async def import_from_text(msg:Message, state:FSMContext):
    try:
        data = json.loads(msg.text)
        quiz_id = await _import_payload_create_quiz(data, msg.from_user.id)
        await state.clear()
        await msg.answer(f"âœ… ØªÙ… Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙƒÙ†Øµ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ID {quiz_id}.", reply_markup=owner_kb())
    except Exception as e:
        await msg.answer(f"âŒ JSON ØºÙŠØ± ØµØ§Ù„Ø­: <code>{html.escape(str(e))}</code>")

async def _import_payload_create_quiz(data:dict, creator_id:int)->int:
    title = str(data.get("title") or "").strip()
    if not title: raise ValueError("title Ù…Ø·Ù„ÙˆØ¨")
    questions = data.get("questions") or []
    if not isinstance(questions, list) or not questions: raise ValueError("questions ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù‚Ø§Ø¦Ù…Ø© ØºÙŠØ± ÙØ§Ø±ØºØ©")

    quiz_id = insert_returning_id("INSERT INTO quizzes(title,created_by,created_at) VALUES (%s,%s,%s)",
                                  (title, creator_id, _now().isoformat()))
    for q in questions:
        qtext = str(q.get("text") or "").strip()
        opts = q.get("options") or []
        if not qtext or len(opts) < 2: continue
        qid = insert_returning_id("INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
                                  (quiz_id, qtext, _now().isoformat()))
        for i, o in enumerate(opts[:10]):
            t = str(o.get("text") or "").strip()
            ok = 1 if bool(o.get("is_correct")) else 0
            if not t: continue
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (qid, i, t, ok))
    return quiz_id

# ---------- Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ© ----------
@dp.message(F.text==BTN_BUNDLES)
async def bundles_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    kb=InlineKeyboardBuilder()
    kb.button(text="â• Ø¥Ø¶Ø§ÙØ© Ù…Ø±ÙÙ‚", callback_data="bund:add")
    kb.button(text="ğŸ“œ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª", callback_data="bund:list")
    kb.button(text="ğŸ”— Ø±Ø¨Ø· Ø¨Ø³Ø¤Ø§Ù„", callback_data="bund:attach")
    kb.adjust(2,1)
    await state.set_state(BundleStates.idle)
    await msg.answer("ğŸ“ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©:", reply_markup=kb.as_markup())

@dp.callback_query(BundleStates.idle, F.data=="bund:add")
async def bundles_add(cb:CallbackQuery, state:FSMContext):
    await state.set_state(BundleStates.add_wait_file)
    await cb.message.answer("Ø£Ø±Ø³Ù„ <b>ØµÙˆØ±Ø©/ØµÙˆØª/ÙÙˆÙŠØ³</b> ÙƒÙ…Ø±ÙÙ‚ Ù…Ø´ØªØ±Ùƒ (Ø¶Ø¹ Ø¹Ù†ÙˆØ§Ù†Ù‹Ø§ ÙÙŠ Ø§Ù„ÙƒØ§Ø¨ØªØ´Ù† Ø§Ø®ØªÙŠØ§Ø±ÙŠ).")
    await cb.answer()

@dp.message(BundleStates.add_wait_file, F.photo | F.audio | F.voice)
async def bundles_add_file(msg:Message, state:FSMContext):
    title = (msg.caption or "").strip()
    if msg.photo:
        kind="photo"; file_id = msg.photo[-1].file_id
    elif msg.audio:
        kind="audio"; file_id = msg.audio.file_id
    else:
        kind="voice"; file_id = msg.voice.file_id
    insert_returning_id("INSERT INTO shared_attachments(kind,file_id,title,created_at) VALUES (%s,%s,%s,%s)",
                        (kind,file_id,title,_now().isoformat()))
    await state.set_state(BundleStates.idle)
    await msg.answer("âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø±ÙÙ‚ Ø§Ù„Ù…Ø´ØªØ±Ùƒ.", reply_markup=owner_kb())

@dp.callback_query(BundleStates.idle, F.data=="bund:list")
async def bundles_list(cb:CallbackQuery):
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    if not rows:
        await cb.message.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ© Ø¨Ø¹Ø¯.", reply_markup=owner_kb()); return await cb.answer()
    text = "ğŸ“œ <b>Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©</b>:\n" + "\n".join([f"â€¢ {r['id']} â€” {r['kind']} â€” {html.escape(r['title'] or '')}" for r in rows])
    await cb.message.answer(text, reply_markup=owner_kb())
    await cb.answer()

@dp.callback_query(BundleStates.idle, F.data=="bund:attach")
async def bundles_attach_start(cb:CallbackQuery, state:FSMContext):
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows:
        await cb.message.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"{r['id']} â€” {r['title']}", callback_data=f"bund:q:{r['id']}")
    kb.adjust(1)
    await state.set_state(BundleStates.attach_pick_quiz)
    await cb.message.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(BundleStates.attach_pick_quiz, F.data.startswith("bund:q:"))
async def bundles_attach_pick_quiz(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[2])
    qs=q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id",(qid,))
    if not qs:
        await cb.message.answer("Ù‡Ø°Ø§ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ù„Ø§ Ø£Ø³Ø¦Ù„Ø©.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for q in qs[:100]:
        preview = (q['text'][:40] + "â€¦") if len(q['text'])>40 else q['text']
        kb.button(text=f"{preview}", callback_data=f"bund:qq:{q['id']}")
    kb.adjust(1)
    await state.update_data(bundle_target_quiz=qid)
    await state.set_state(BundleStates.attach_pick_question)
    await cb.message.answer("Ø§Ø®ØªØ± Ø§Ù„Ø³Ø¤Ø§Ù„:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(BundleStates.attach_pick_question, F.data.startswith("bund:qq:"))
async def bundles_attach_pick_question(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[2])
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    if not rows:
        await cb.message.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ© Ù„Ø¥Ø±ÙØ§Ù‚Ù‡Ø§.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for r in rows:
        label = f"{r['id']} â€” {r['kind']} â€” {(r['title'] or '')[:20]}"
        kb.button(text=label, callback_data=f"bund:pick:{qid}:{r['id']}")
    kb.adjust(1)
    await state.set_state(BundleStates.attach_pick_bundle)
    await cb.message.answer("Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±ÙÙ‚:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(BundleStates.attach_pick_bundle, F.data.startswith("bund:pick:"))
async def bundles_attach_apply(cb:CallbackQuery, state:FSMContext):
    _,_, qid_str, bid_str = cb.data.split(":")
    question_id = int(qid_str); bundle_id = int(bid_str)
    b = q_one("SELECT kind,file_id FROM shared_attachments WHERE id=%s",(bundle_id,))
    if not b:
        await cb.message.answer("Ø§Ù„Ù…Ø±ÙÙ‚ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.", reply_markup=owner_kb()); return await cb.answer()
    pos_row = q_one("SELECT COALESCE(MAX(position),-1) AS p FROM question_attachments WHERE question_id=%s",(question_id,))
    pos = int(pos_row["p"]) + 1
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
           (question_id, b["kind"], b["file_id"], pos))
    await state.clear()
    await cb.message.answer("âœ… ØªÙ… Ø±Ø¨Ø· Ø§Ù„Ù…Ø±ÙÙ‚ Ø¨Ø§Ù„Ø³Ø¤Ø§Ù„.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Ø­Ø°Ù Ø³Ø¤Ø§Ù„ (ØµÙØ­Ø§Øª 5) ----------
@dp.message(F.text==BTN_DELQUESTION)
async def del_question_pick_quiz(msg: Message):
    if not await ensure_owner(msg): return
    kb, total, pages, page = _quizzes_page("ql_pick_delq", 0)
    await msg.answer(_qs_page_text_header("ğŸ—‘ï¸", "Ø­Ø°Ù Ø³Ø¤Ø§Ù„ â€” Ø§Ø®ØªØ± Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§", total, page, pages), reply_markup=kb)

@dp.callback_query(F.data.startswith("delpick:"))
async def del_question_pick_page(cb: CallbackQuery):
    _, quiz_id, page = cb.data.split(":")
    quiz_id = int(quiz_id); page = int(page)
    text, kb, *_ = _questions_page(quiz_id, "q_pick_delete", page)
    try:
        await cb.message.edit_text(text, reply_markup=kb)
    except Exception:
        await cb.message.answer(text, reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.startswith("del:"))
async def del_question_confirm(cb:CallbackQuery):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("ØºÙŠØ± Ù…ØµØ±Ø­.", show_alert=True)
    _, quiz_id, qid = cb.data.split(":"); quiz_id=int(quiz_id); qid=int(qid)
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ… Ù†Ø¹Ù…ØŒ Ø§Ø­Ø°Ù", callback_data=f"delc:{qid}")
    kb.button(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=f"delpick:{quiz_id}:0")
    kb.adjust(2)
    await cb.message.answer("ØªØ£ÙƒÙŠØ¯ Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„ØŸ", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(F.data.startswith("delc:"))
async def del_question_apply(cb:CallbackQuery):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("ØºÙŠØ± Ù…ØµØ±Ø­.", show_alert=True)
    _, qid = cb.data.split(":"); qid=int(qid)
    q_exec("DELETE FROM options WHERE question_id=%s", (qid,))
    q_exec("DELETE FROM question_attachments WHERE question_id=%s", (qid,))
    q_exec("DELETE FROM questions WHERE id=%s", (qid,))
    await cb.message.answer("âœ… ØªÙ… Ø­Ø°Ù Ø§Ù„Ø³Ø¤Ø§Ù„.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Ø¯Ù…Ø¬ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ----------
@dp.message(F.text==BTN_MERGE)
async def merge_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"ÙˆØ¬Ù‡Ø© â† {r['id']} â€” {r['title']}", callback_data=f"merge:dest:{r['id']}")
    kb.adjust(1)
    await state.set_state(MergeStates.pick_dest)
    await msg.answer("Ø§Ø®ØªØ± <b>Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ÙˆØ¬Ù‡Ø©</b> Ø§Ù„Ø°ÙŠ Ø³ÙŠØªÙ… Ø§Ù„Ø¯Ù…Ø¬ Ø¥Ù„ÙŠÙ‡:", reply_markup=kb.as_markup())

@dp.callback_query(MergeStates.pick_dest, F.data.startswith("merge:dest:"))
async def merge_pick_dest(cb:CallbackQuery, state:FSMContext):
    dest=int(cb.data.split(":")[2])
    await state.update_data(merge_dest=dest)
    rows=q_all("SELECT id,title FROM quizzes WHERE id<>%s ORDER BY id DESC",(dest,))
    if not rows:
        await cb.message.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…ØµØ¯Ø± Ù„Ù„Ø¯Ù…Ø¬.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"Ù…ØµØ¯Ø± â†’ {r['id']} â€” {r['title']}", callback_data=f"merge:src:{r['id']}")
    kb.adjust(1)
    await state.set_state(MergeStates.pick_source)
    await cb.message.answer("Ø§Ø®ØªØ± <b>Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…ØµØ¯Ø±</b> Ù„Ù†Ø³Ø® Ø£Ø³Ø¦Ù„ØªÙ‡:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(MergeStates.pick_source, F.data.startswith("merge:src:"))
async def merge_apply(cb:CallbackQuery, state:FSMContext):
    src=int(cb.data.split(":")[2])
    dest=(await state.get_data()).get("merge_dest")
    if not dest:
        await cb.message.answer("Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙˆØ¬Ù‡Ø©.", reply_markup=owner_kb()); return await cb.answer()
    qs = q_all("SELECT id,text,created_at FROM questions WHERE quiz_id=%s ORDER BY id",(src,))
    copied=0
    for q in qs:
        new_qid = insert_returning_id("INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
                                      (dest,q["text"],_now().isoformat()))
        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        for o in opts:
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (new_qid, o["option_index"], o["text"], o["is_correct"]))
        atts = q_all("SELECT kind,file_id,position FROM question_attachments WHERE question_id=%s ORDER BY position",(q["id"],))
        for a in atts:
            q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
                   (new_qid, a["kind"], a["file_id"], a["position"]))
        copied += 1
    await state.clear()
    await cb.message.answer(f"ğŸ”— ØªÙ… Ø§Ù„Ø¯Ù…Ø¬: Ù†ÙØ³Ø® {copied} Ø³Ø¤Ø§Ù„Ù‹Ø§ Ù…Ù† {src} Ø¥Ù„Ù‰ {dest}.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Runner ----------
async def main():
    asyncio.create_task(close_expired_polls_loop())
    await dp.start_polling(bot, allowed_updates=["message","callback_query","poll_answer"])

if __name__=="__main__":
    try: asyncio.run(main())
    except (KeyboardInterrupt,SystemExit): pass
