import os, asyncio, html, re, json, tempfile, math, uuid
from datetime import datetime, timezone, timedelta
from zoneinfo import ZoneInfo

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.types import Message, CallbackQuery
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import StatesGroup, State
import psycopg
from psycopg_pool import ConnectionPool

load_dotenv()

# --- Single-instance lock config (optional envs) ---
INSTANCE_ID = os.getenv("INSTANCE_ID", "").strip() or f"inst-{uuid.uuid4().hex[:8]}"
LOCK_TTL_SECONDS = int(os.getenv("LOCK_TTL_SECONDS", "40"))
LOCK_RENEW_EVERY = int(os.getenv("LOCK_RENEW_EVERY", "15"))

# --- Flood control delays ---
POLL_BASE_DELAY = float(os.getenv("POLL_BASE_DELAY", "0.9"))
POLL_JITTER = float(os.getenv("POLL_JITTER", "0.6"))
ATTACH_BASE_DELAY = float(os.getenv("ATTACH_BASE_DELAY", "1.2"))
ATTACH_JITTER = float(os.getenv("ATTACH_JITTER", "0.8"))

async def sleep_jitter(kind: str = "poll"):
    import random
    if kind == "attach":
        await asyncio.sleep(ATTACH_BASE_DELAY + random.random() * ATTACH_JITTER)
    else:
        await asyncio.sleep(POLL_BASE_DELAY + random.random() * POLL_JITTER)

# --- Core ENV (required) ---
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

# ØªÙˆÙ‚ÙŠØª Ø¨Ø±Ù„ÙŠÙ†
BERLIN_TZ = ZoneInfo("Europe/Berlin")

# --- Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø¯ÙŠØ²Ø¨Ø§Ø´Ø± ---
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# --- PostgreSQL pool ---
pool = ConnectionPool(conninfo=DATABASE_URL, open=True)

# --- DB Helpers ---
def q_exec(sql: str, params: tuple = ()):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params)
        conn.commit()

def q_one(sql: str, params: tuple = ()):
    with pool.connection() as conn:
        with conn.cursor(row_factory=psycopg.rows.dict_row) as cur:
            cur.execute(sql, params)
            return cur.fetchone()

def q_all(sql: str, params: tuple = ()):
    with pool.connection() as conn:
        with conn.cursor(row_factory=psycopg.rows.dict_row) as cur:
            cur.execute(sql, params)
            return cur.fetchall()

# --- DB Schema ---
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, username TEXT,
            text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT,
            window_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            question_id INTEGER NOT NULL,
            user_id BIGINT NOT NULL,
            username TEXT,
            option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL,
            answered_at TEXT NOT NULL,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS shared_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            kind TEXT NOT NULL,
            file_id TEXT NOT NULL,
            title TEXT,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_runs(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            published_at TEXT NOT NULL,
            grade_enabled INTEGER NOT NULL DEFAULT 0
        )"""
    ]

    # Ø¥Ø¶Ø§ÙØ§Øª Ø¬Ø¯ÙŠØ¯Ø©
    ddls.append(
        """CREATE TABLE IF NOT EXISTS chats_cache(
            chat_id BIGINT PRIMARY KEY,
            title TEXT,
            type TEXT,
            updated_at TEXT NOT NULL
        )"""
    )

    ddls.append(
        """CREATE TABLE IF NOT EXISTS bot_lock(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            instance_id TEXT NOT NULL,
            holder TEXT NOT NULL,
            lease_until TEXT NOT NULL,
            updated_at TEXT NOT NULL
        )"""
    )

    for ddl in ddls:
        q_exec(ddl)

# ---------- Helpers ----------
def _now() -> datetime:
    return datetime.now(timezone.utc)

def fmt_berlin(iso_str_or_dt) -> str:
    """
    ÙŠØ­ÙˆÙ‘Ù„ ISO Ø£Ùˆ datetime Ø¥Ù„Ù‰ ÙˆÙ‚Øª Ø¨Ø±Ù„ÙŠÙ†: YYYY-MM-DD HH:MM:SS
    """
    if isinstance(iso_str_or_dt, datetime):
        dt = iso_str_or_dt
    else:
        try:
            dt = datetime.fromisoformat(str(iso_str_or_dt))
        except Exception:
            return str(iso_str_or_dt)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(BERLIN_TZ).strftime("%Y-%m-%d %H:%M:%S")

def is_owner(uid: int) -> bool:
    return uid == OWNER_ID

async def ensure_owner(msg: Message) -> bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±/Ø§Ù„Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", reply_markup=owner_kb())
        return False
    return True

def hname(u) -> str:
    nm = " ".join([x for x in [getattr(u, "first_name", None), getattr(u, "last_name", None)] if x]).strip()
    if not nm and getattr(u, "username", None):
        nm = f"@{u.username}"
    return nm or f"UID {u.id}"

def mention_html(user_id: int, name: str) -> str:
    safe = html.escape(name or "Ù…Ø³ØªØ®Ø¯Ù…")
    return f'<a href="tg://user?id={user_id}">{safe}</a>'

# ÙƒØ§Ø´ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
async def get_chat_label(chat_id: int) -> str:
    row = q_one("SELECT title FROM chats_cache WHERE chat_id=%s", (chat_id,))
    if row and row.get("title"):
        return row["title"]
    try:
        ch = await bot.get_chat(chat_id)
        title = getattr(ch, "title", None) or getattr(ch, "full_name", None) or str(chat_id)
        q_exec(
            """INSERT INTO chats_cache(chat_id,title,type,updated_at)
               VALUES (%s,%s,%s,%s)
               ON CONFLICT (chat_id) DO UPDATE
               SET title=EXCLUDED.title, type=EXCLUDED.type, updated_at=EXCLUDED.updated_at""",
            (chat_id, title, getattr(ch, "type", ""), _now().isoformat()),
        )
        return title
    except Exception:
        return str(chat_id)

# --- Single-Instance Lease helpers ---
def _utcnow() -> datetime:
    return datetime.now(timezone.utc)

def _lease_until_iso() -> str:
    return (_utcnow() + timedelta(seconds=LOCK_TTL_SECONDS)).isoformat()

def try_acquire_lock(holder: str) -> bool:
    now = _utcnow().isoformat()
    until = _lease_until_iso()
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                """
                UPDATE bot_lock
                   SET instance_id=%s, holder=%s, lease_until=%s, updated_at=%s
                 WHERE (lease_until <= %s) OR (holder=%s)
                RETURNING id
                """,
                (INSTANCE_ID, holder, until, now, now, holder),
            )
            row = cur.fetchone()
            if not row:
                cur.execute("SELECT COUNT(*) FROM bot_lock WHERE lease_until > %s", (now,))
                active = (cur.fetchone() or (0,))[0]
                if int(active) == 0:
                    cur.execute(
                        """
                        INSERT INTO bot_lock(instance_id, holder, lease_until, updated_at)
                        VALUES (%s, %s, %s, %s)
                        RETURNING id
                        """,
                        (INSTANCE_ID, holder, until, now),
                    )
                    row = cur.fetchone()
        conn.commit()
    return bool(row)

def renew_lock(holder: str) -> bool:
    now = _utcnow().isoformat()
    until = _lease_until_iso()
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                """
                UPDATE bot_lock
                   SET lease_until=%s, updated_at=%s
                 WHERE holder=%s AND lease_until > %s
                RETURNING id
                """,
                (until, now, holder, now),
            )
            ok = cur.fetchone()
        conn.commit()
    return bool(ok)

async def lock_renew_loop(holder: str):
    while True:
        await asyncio.sleep(LOCK_RENEW_EVERY)
        try:
            if not renew_lock(holder):
                try:
                    await bot.close()
                except Exception:
                    pass
                print("LOCK LOST â€” another instance took the lease. Exiting.", flush=True)
                os._exit(0)
        except Exception as e:
            print(f"LOCK RENEW ERROR: {e}", flush=True)
# --- end Single-Instance Lease helpers ---

async def send_long(chat_id: int, text: str):
    MAX = 3800
    buf = ""
    for para in text.split("\n\n"):
        if len(buf) + len(para) + 2 > MAX and buf:
            await bot.send_message(chat_id, buf)
            buf = ""
        buf += (("\n\n" if buf else "") + para)
    if buf:
        await bot.send_message(chat_id, buf)

async def attach_file_to_question(question_id: int, kind: str, file_id: str):
    pos_row = q_one("SELECT COALESCE(MAX(position),-1) AS p FROM question_attachments WHERE question_id=%s", (question_id,))
    pos = int(pos_row["p"]) + 1
    q_exec(
        "INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
        (question_id, kind, file_id, pos),
    )

# --- FSM States ---
class QuizStates(StatesGroup):
    waiting_title = State()
    waiting_question = State()
    waiting_option = State()

class BriefStates(StatesGroup):
    waiting_brief = State()

class ScoreByGroupStates(StatesGroup):
    pick_group = State()

class BriefScoreStates(StatesGroup):
    pick_group = State()

# --- Ù…Ù†Ø¹ Ø¶ØºØ· Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„ØºÙŠØ± Ø§Ù„Ù…Ø§Ù„Ùƒ ---
@dp.callback_query()
async def admin_cb_guard(cb: CallbackQuery):
    if cb.from_user.id != OWNER_ID and re.match(r"^(addq|editq|delq|...)", cb.data or ""):
        await cb.answer("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø± Ø®Ø§Øµ Ø¨Ø§Ù„ÙƒÙ†Øº ÙÙ‚Ø·.", show_alert=True)

# --- Ø£ÙˆØ§Ù…Ø± Ø£Ø³Ø§Ø³ÙŠØ© ---
@dp.message(F.text == "/start")
async def cmd_start(msg: Message):
    await msg.answer("ğŸ‘‹ Ø£Ù‡Ù„Ø§ Ø¨Ùƒ! Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙˆØ§Ù„ØªÙ…Ø§Ø±ÙŠÙ†.")

@dp.message(F.text == "/newquiz")
async def cmd_newquiz(msg: Message, state):
    if not await ensure_owner(msg): return
    await msg.answer("Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:")
    await state.set_state(QuizStates.waiting_title)

@dp.message(QuizStates.waiting_title)
async def quiz_title(msg: Message, state):
    title = msg.text.strip()
    q_exec("INSERT INTO quizzes(title, created_by, created_at) VALUES (%s,%s,%s)",
           (title, msg.from_user.id, _now().isoformat()))
    await msg.answer(f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±: {title}")
    await state.clear()

@dp.message(F.text == "/quizzes")
async def cmd_quizzes(msg: Message):
    rows = q_all("SELECT * FROM quizzes WHERE is_archived=0")
    if not rows:
        await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø­Ø§Ù„ÙŠØ§.")
        return
    text = "\n".join([f"{r['id']}: {r['title']}" for r in rows])
    await send_long(msg.chat.id, f"ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª:\n{text}")

@dp.message(F.text == "/brief")
async def cmd_brief(msg: Message, state):
    await msg.answer("âœï¸ Ø£Ø±Ø³Ù„ Ù„ÙŠ Ø§Ù„Ø¨Ø±ÙŠÙ Ø§Ù„Ø¢Ù†:")
    await state.set_state(BriefStates.waiting_brief)

@dp.message(BriefStates.waiting_brief)
async def handle_brief(msg: Message, state):
    q_exec(
        "INSERT INTO writing_submissions(origin_chat_id,user_id,username,text,score,level,evaluated_at) VALUES (%s,%s,%s,%s,%s,%s,%s)",
        (msg.chat.id, msg.from_user.id, msg.from_user.username, msg.text, 0, "ØºÙŠØ± Ù…ØµØ­Ø­", _now().isoformat()),
    )
    await msg.answer("âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„Ø¨Ø±ÙŠÙ.")
    await state.clear()

@dp.message(F.text == "/briefscores")
async def cmd_briefs(msg: Message, state):
    chats = q_all("SELECT DISTINCT origin_chat_id FROM writing_submissions ORDER BY origin_chat_id")
    if not chats:
        await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø±ÙŠÙØ§Øª Ù…Ø³ØªÙ„Ù…Ø©.")
        return
    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    markup = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=f"Ù…Ø¬Ù…ÙˆØ¹Ø© {c['origin_chat_id']}", callback_data=f"briefgrp:{c['origin_chat_id']}")] for c in chats])
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ø¹Ø±Ø¶ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ:", reply_markup=markup)
    await state.set_state(BriefScoreStates.pick_group)

@dp.callback_query(BriefScoreStates.pick_group, F.data.startswith("briefgrp:"))
async def cb_briefs(cb: CallbackQuery, state):
    chat_id = int(cb.data.split(":")[1])
    rows = q_all("SELECT * FROM writing_submissions WHERE origin_chat_id=%s", (chat_id,))
    if not rows:
        await cb.message.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø±ÙŠÙØ§Øª.")
        return
    text = "\n".join([f"{r['username']}: {r['text']} ({r['evaluated_at']})" for r in rows])
    await send_long(cb.message.chat.id, f"ğŸ“ Ø¨Ø±ÙŠÙØ§Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {chat_id}:\n{text}")
    await state.clear()

async def main():
    ensure_schema()
    # Ø¬Ø±Ù‘Ø¨ ØªØ£Ø®Ø° Ø§Ù„Ù‚ÙÙ„
    if not try_acquire_lock("main"):
        print("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙÙ„. Ø®Ø±ÙˆØ¬.")
        return
    asyncio.create_task(lock_renew_loop("main"))
    print("âœ… Bot started...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
