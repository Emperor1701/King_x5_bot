#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re, tempfile, math, uuid, random
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile, File,
    ReactionTypeEmoji
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

# --- Europe/Berlin timezone for display ---
try:
    from zoneinfo import ZoneInfo
    TZ_BERLIN = ZoneInfo("Europe/Berlin")
except Exception:
    TZ_BERLIN = None

load_dotenv()

# --- Flood control delays ---
POLL_BASE_DELAY = float(os.getenv('POLL_BASE_DELAY', '0.9'))
POLL_JITTER = float(os.getenv('POLL_JITTER', '0.6'))
ATTACH_BASE_DELAY = float(os.getenv('ATTACH_BASE_DELAY', '1.2'))
ATTACH_JITTER = float(os.getenv('ATTACH_JITTER', '0.8'))

async def sleep_jitter(kind: str = 'poll'):
    if kind == 'attach':
        await asyncio.sleep(ATTACH_BASE_DELAY + random.random()*ATTACH_JITTER)
    else:
        await asyncio.sleep(POLL_BASE_DELAY + random.random()*POLL_JITTER)

BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

# --- Single-instance lease lock config (NEW) ---
INSTANCE_ID = os.getenv("INSTANCE_ID", "").strip() or f"inst-{uuid.uuid4().hex[:8]}"
LOCK_TTL_SECONDS = int(os.getenv("LOCK_TTL_SECONDS", "40"))
LOCK_RENEW_EVERY = int(os.getenv("LOCK_RENEW_EVERY", "15"))

bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

def insert_returning_id(sql:str, params:tuple|list|None=None)->int:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql + " RETURNING id", params or ())
            row = cur.fetchone()
        conn.commit()
    return int(row["id"] if isinstance(row, dict) else row[0])

# ---------- Schema + Migrations ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, username TEXT,
            text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT,
            window_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            question_id INTEGER NOT NULL,
            user_id BIGINT NOT NULL,
            username TEXT,
            option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL,
            answered_at TEXT NOT NULL,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS shared_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            kind TEXT NOT NULL,
            file_id TEXT NOT NULL,
            title TEXT,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_runs(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            published_at TEXT NOT NULL,
            grade_enabled INTEGER NOT NULL DEFAULT 0
        )""",
        # NEW: ÿ¨ÿØŸàŸÑ ÿßŸÑŸÇŸÅŸÑ (ÿ£ŸÜŸàÿßÿπ ÿßŸÑŸàŸÇÿ™ ÿµÿ≠Ÿäÿ≠ÿ© TIMESTAMPTZ)
        """CREATE TABLE IF NOT EXISTS bot_lock(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            instance_id TEXT NOT NULL,
            holder      TEXT NOT NULL,
            lease_until TIMESTAMPTZ NOT NULL,
            updated_at  TIMESTAMPTZ NOT NULL
        )""",
        # ŸÅŸáÿ±ÿ≥ Ÿäÿ∂ŸÖŸÜ ÿµŸÅ Ÿàÿßÿ≠ÿØ ŸÅŸÇÿ∑ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä ÿ®ÿ≥ ŸÖŸÅŸäÿØ)
        """CREATE UNIQUE INDEX IF NOT EXISTS bot_lock_one ON bot_lock((1))""",
        # NEW: ŸÉÿßÿ¥ ŸÑÿπŸÜÿßŸàŸäŸÜ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™
        """CREATE TABLE IF NOT EXISTS chats_cache(
            chat_id   BIGINT PRIMARY KEY,
            title     TEXT,
            type      TEXT,
            updated_at TIMESTAMPTZ NOT NULL
        )""",
    ]
    for ddl in ddls:
        q_exec(ddl)

def migrate_schema():
    # ŸÖŸÄÿßŸäÿ¨ÿ±Ÿäÿ¥ŸÜÿßÿ™ŸÉ ÿßŸÑŸÇÿØŸäŸÖÿ© ŸÉŸÖÿß ŸáŸä
    q_exec("ALTER TABLE sent_polls ADD COLUMN IF NOT EXISTS run_id INTEGER")
    q_exec("ALTER TABLE quiz_responses ADD COLUMN IF NOT EXISTS run_id INTEGER")
    q_exec("ALTER TABLE brief_windows ADD COLUMN IF NOT EXISTS prompt_text TEXT")
    q_exec("ALTER TABLE brief_windows ADD COLUMN IF NOT EXISTS ann_message_id BIGINT")
    q_exec("ALTER TABLE writing_submissions ADD COLUMN IF NOT EXISTS username TEXT")
    q_exec("ALTER TABLE writing_submissions ADD COLUMN IF NOT EXISTS window_id INTEGER")
    q_exec("ALTER TABLE quiz_runs ADD COLUMN IF NOT EXISTS grade_enabled INTEGER NOT NULL DEFAULT 0")

    # NEW: ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ ÿ£ÿπŸÖÿØÿ© bot_lock ŸÖŸÜ ŸÜŸàÿπ TIMESTAMPTZ (ÿπŸÑÿßÿ¨ ÿßŸÑÿÆÿ∑ÿ£ text <= timestamptz)
    try:
        q_exec("""
            ALTER TABLE bot_lock
              ALTER COLUMN lease_until TYPE TIMESTAMPTZ USING lease_until::timestamptz
        """)
    except Exception:
        pass
    try:
        q_exec("""
            ALTER TABLE bot_lock
              ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at::timestamptz
        """)
    except Exception:
        pass

    # NEW: ÿ£ÿπŸÖÿØÿ© ŸÖÿ∂ŸÖŸàŸÜÿ© ŸÖŸàÿ¨ŸàÿØÿ©
    q_exec("ALTER TABLE bot_lock ADD COLUMN IF NOT EXISTS instance_id TEXT NOT NULL DEFAULT ''")
    q_exec("ALTER TABLE bot_lock ADD COLUMN IF NOT EXISTS holder TEXT NOT NULL DEFAULT ''")
    # ÿ¥ŸäŸÑ ÿßŸÑÿØŸäŸÅŸàŸÑÿ™ ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ ÿ≠ÿ™Ÿâ ÿ™ÿ∂ŸÑ ÿßŸÑÿ£ÿπŸÖÿØÿ© NOT NULL ÿ®ÿØŸàŸÜ ŸÇŸäŸÖ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©
    q_exec("ALTER TABLE bot_lock ALTER COLUMN instance_id DROP DEFAULT")
    q_exec("ALTER TABLE bot_lock ALTER COLUMN holder DROP DEFAULT")

    # NEW: ŸÅŸáÿ±ÿ≥ ÿßŸÑŸÇŸÅŸÑ ÿ•ÿ∞ÿß ŸÖÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØ
    q_exec("CREATE UNIQUE INDEX IF NOT EXISTS bot_lock_one ON bot_lock((1))")

    # NEW: ÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ¨ÿØŸàŸÑ ÿßŸÑŸÉÿßÿ¥ (ŸÑŸà ŸÜÿ≥ÿÆ ŸÇÿØŸäŸÖ ŸÖÿß ŸÅŸäŸá ensure ÿ≠ÿØŸäÿ´)
    q_exec("""CREATE TABLE IF NOT EXISTS chats_cache(
                chat_id   BIGINT PRIMARY KEY,
                title     TEXT,
                type      TEXT,
                updated_at TIMESTAMPTZ NOT NULL
             )""")


ensure_schema()
migrate_schema()

# ---------- UI ----------
BTN_NEWQUIZ="üÜï ÿ•ŸÜÿ¥ÿßÿ° ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_ADDQ="‚ûï ÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ"; BTN_LISTQUIZ="üìö ÿπÿ±ÿ∂ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™"
BTN_EDITQUIZ="üõ†Ô∏è ÿ™ÿπÿØŸäŸÑ ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_DELQUIZ="üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿßÿÆÿ™ÿ®ÿßÿ±"
BTN_BUNDLES="üìé ŸÖÿ±ŸÅŸÇÿßÿ™ ŸÖÿ¥ÿ™ÿ±ŸÉÿ©"; BTN_MERGE="üîó ÿØŸÖÿ¨ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™"
BTN_EXPORT="üì§ ÿ™ÿµÿØŸäÿ± ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_IMPORT="üì• ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿØŸÅÿπÿ©"
BTN_PUBLISH="üöÄ ŸÜÿ¥ÿ± ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_WIPE_ALL="üßπ ÿ≠ÿ∞ŸÅ ŸÉŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™"
BTN_SCORE="üèÜ ŸÑŸàÿ≠ÿ© ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨"; BTN_BACK_HOME="‚Ü©Ô∏è ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ®ÿØÿßŸäÿ©"; BTN_BACK_STEP="‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ ŸÑŸÑÿÆŸÑŸÅ"
BTN_BRIEF="‚úâÔ∏è ÿ≤ÿ± ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ"
BTN_LISTQUESTIONS="üìù ÿπÿ±ÿ∂ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©"
BTN_EDITQUESTION="‚úèÔ∏è ÿ™ÿπÿØŸäŸÑ ÿ≥ÿ§ÿßŸÑ"
BTN_DELQUESTION="üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿ≥ÿ§ÿßŸÑ"
# NEW button (ŸÑÿß ÿ≠ÿ∞ŸÅ ŸÑÿ£Ÿä ÿ≤ÿ± ŸÇÿØŸäŸÖ)
BTN_BRIEF_RESULTS = "üìä ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ®ÿ±ŸäŸÅ"

def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_EDITQUIZ)],
        [KeyboardButton(text=BTN_LISTQUESTIONS), KeyboardButton(text=BTN_EDITQUESTION)],
        [KeyboardButton(text=BTN_DELQUESTION)],
        [KeyboardButton(text=BTN_DELQUIZ), KeyboardButton(text=BTN_BRIEF)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_EXPORT), KeyboardButton(text=BTN_IMPORT)],
        [KeyboardButton(text=BTN_BUNDLES), KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_BRIEF_RESULTS)],  # NEW: ÿµŸÅ ÿ•ÿ∂ÿßŸÅŸä ŸÑŸÑÿ≤ÿ± ÿßŸÑÿ¨ÿØŸäÿØ
        [KeyboardButton(text=BTN_WIPE_ALL)],
    ]
    return ReplyKeyboardMarkup(
        keyboard=rows, resize_keyboard=True, one_time_keyboard=True,
        is_persistent=False, input_field_placeholder="ÿßÿÆÿ™ÿ± ÿ£ŸÖÿ±Ÿãÿß ŸÖŸÜ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± üëá"
    )

ALL_BTN_TEXTS = {
    BTN_BACK_HOME, BTN_BACK_STEP, BTN_NEWQUIZ, BTN_ADDQ, BTN_LISTQUIZ, BTN_EDITQUIZ,
    BTN_DELQUIZ, BTN_BRIEF, BTN_WIPE_ALL, BTN_SCORE, BTN_PUBLISH, BTN_BUNDLES,
    BTN_MERGE, BTN_EXPORT, BTN_IMPORT, BTN_LISTQUESTIONS, BTN_EDITQUESTION, BTN_DELQUESTION,
    BTN_BRIEF_RESULTS  # NEW
}

def done_button_kb(tag: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úîÔ∏è ÿ™ŸÖ", callback_data=f"done:{tag}")
    kb.button(text="‚ùå ÿ®ÿØŸàŸÜ ŸÖÿ±ŸÅŸÇÿßÿ™", callback_data=f"skip:{tag}")
    kb.adjust(2); return kb.as_markup()

def inline_confirm_kb(tag:str):
    kb=InlineKeyboardBuilder()
    kb.button(text="‚úÖ ÿ™ÿ£ŸÉŸäÿØ", callback_data=f"{tag}:yes")
    kb.button(text="‚ùå ÿ•ŸÑÿ∫ÿßÿ°", callback_data=f"{tag}:no")
    kb.adjust(2); return kb.as_markup()

def attach_choice_kb():
    kb=InlineKeyboardBuilder()
    kb.button(text="üìé ŸÖÿ±ŸÅŸÇÿßÿ™ ÿÆÿßÿµÿ©", callback_data="att:upload")
    kb.button(text="üìé ŸÖŸÜ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉÿ©", callback_data="att:shared")
    kb.button(text="‚ùå ÿ®ÿØŸàŸÜ ŸÖÿ±ŸÅŸÇÿßÿ™", callback_data="att:none")
    kb.adjust(2,1); return kb.as_markup()

def shared_list_kb(question_id:int):
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    kb=InlineKeyboardBuilder()
    for r in rows:
        label=f"{r['id']} ‚Äî {r['kind']} ‚Äî {(r['title'] or '')[:20]}"
        kb.button(text=label, callback_data=f"attadd:{question_id}:{r['id']}")
    kb.button(text="‚úîÔ∏è ÿ™ŸÖ", callback_data=f"attdone:{question_id}")
    kb.adjust(1)
    return kb.as_markup()

def publish_hours_kb(quiz_id:int):
    kb=InlineKeyboardBuilder()
    for h in (1,2,4,8,24):
        kb.button(text=f"‚è≥ {h} ÿ≥ÿßÿπÿ©", callback_data=f"pubdur:{quiz_id}:{h}")
    kb.button(text="‚å®Ô∏è ÿ±ŸÇŸÖ ŸÖÿÆÿµÿµ", callback_data=f"pubdur:{quiz_id}:custom")
    kb.button(text="‚ôæÔ∏è ÿ®ÿØŸàŸÜ ŸÖÿ§ŸÇŸëÿ™", callback_data=f"pubdur:{quiz_id}:0")
    kb.adjust(2,2,1)
    return kb.as_markup()

def publish_eval_kb(quiz_id:int, hours:int):
    kb=InlineKeyboardBuilder()
    kb.button(text="‚úÖ ŸÅÿπŸëŸÑ ÿßŸÑÿ™ŸÇŸäŸäŸÖ", callback_data=f"pubeval:{quiz_id}:{hours}:1")
    kb.button(text="‚ùå ÿ®ÿØŸàŸÜ ÿ™ŸÇŸäŸäŸÖ", callback_data=f"pubeval:{quiz_id}:{hours}:0")
    kb.adjust(2)
    return kb.as_markup()

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def _utcnow()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID

async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("üö´ Ÿáÿ∞ÿß ÿßŸÑÿ≤ÿ±/ÿßŸÑÿ£ŸÖÿ± ÿÆÿßÿµ ÿ®ÿßŸÑŸÖÿßŸÑŸÉ.", reply_markup=owner_kb()); return False
    return True

def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"

def mention_html(user_id:int, name:str)->str:
    safe = html.escape(name or "ŸÖÿ≥ÿ™ÿÆÿØŸÖ")
    return f'<a href="tg://user?id={user_id}">{safe}</a>'

async def send_long(chat_id:int, text:str):
    MAX=3800
    buf=""
    for para in text.split("\n\n"):
        if len(buf)+len(para)+2>MAX and buf:
            await bot.send_message(chat_id, buf)
            buf=""
        buf += (("\n\n" if buf else "") + para)
    if buf:
        await bot.send_message(chat_id, buf)

# NEW: format ISO (UTC) to Europe/Berlin string for display
def fmt_berlin(iso_str:str)->str:
    if not iso_str:
        return "-"
    try:
        dt = datetime.fromisoformat(iso_str.replace("Z","+00:00"))
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        if TZ_BERLIN:
            dt = dt.astimezone(TZ_BERLIN)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return iso_str

# ---------- FSM States ----------
class NewQuizStates(StatesGroup):
    waiting_title          = State()
    waiting_question_text  = State()
    waiting_options        = State()
    waiting_corrects       = State()
    waiting_more_q         = State()

class AttachStates(StatesGroup):
    waiting_pick_quiz      = State()
    waiting_pick_question  = State()
    waiting_attach         = State()

class ScoreStates(StatesGroup):
    pick_quiz              = State()
    pick_run               = State()

class ScoreByGroupStates(StatesGroup):
    pick_group             = State()
    pick_quiz              = State()
    pick_run               = State()

# NEW: FSM ŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ®ÿ±ŸäŸÅ
class BriefResultStates(StatesGroup):
    pick_group             = State()
    pick_window            = State()

# ---------- Start / Back ----------
@dp.message(Command("start"))
async def cmd_start(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("üëã ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÅŸä ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ®Ÿàÿ™", reply_markup=owner_kb())

@dp.message(F.text == BTN_BACK_HOME)
async def back_home(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("üè† ÿ±ÿ¨ÿπŸÜÿßŸÉ ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©", reply_markup=owner_kb())

@dp.message(F.text == BTN_BACK_STEP)
async def back_step(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("‚¨ÖÔ∏è ÿ±ÿ¨ÿπŸÜÿßŸÉ ÿÆÿ∑Ÿàÿ© ŸÑŸÑÿÆŸÑŸÅ", reply_markup=owner_kb())

# ---------- Cache chat labels ----------
async def get_chat_label(chat_id:int)->str:
    row = q_one("SELECT title FROM chats_cache WHERE chat_id=%s", (chat_id,))
    if row and row.get("title"):
        return row["title"]
    try:
        ch = await bot.get_chat(chat_id)
        title = ch.title or (getattr(ch,"full_name",None) or str(chat_id))
        q_exec("""INSERT INTO chats_cache(chat_id,title,type,updated_at)
                  VALUES (%s,%s,%s,%s)
                  ON CONFLICT (chat_id) DO UPDATE SET title=EXCLUDED.title, type=EXCLUDED.type, updated_at=EXCLUDED.updated_at""",
               (chat_id, title, getattr(ch,"type",""), _now().isoformat()))
        return title
    except Exception:
        return str(chat_id)

# ---------- Single-instance lock helpers ----------
def _lease_until(): return _utcnow() + timedelta(seconds=LOCK_TTL_SECONDS)

def try_acquire_lock(holder:str)->bool:
    now=_utcnow(); until=_lease_until()
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""UPDATE bot_lock
                           SET instance_id=%s, holder=%s, lease_until=%s, updated_at=%s
                           WHERE (lease_until <= %s) OR (holder=%s)
                           RETURNING id""",
                        (INSTANCE_ID, holder, until, now, now, holder))
            row = cur.fetchone()
            if not row:
                cur.execute("SELECT COUNT(*) FROM bot_lock WHERE lease_until > %s",(now,))
                active=cur.fetchone()[0]
                if active==0:
                    cur.execute("""INSERT INTO bot_lock(instance_id,holder,lease_until,updated_at)
                                   VALUES (%s,%s,%s,%s) RETURNING id""",
                                (INSTANCE_ID, holder, until, now))
                    row=cur.fetchone()
        conn.commit()
    return bool(row)

def renew_lock(holder:str)->bool:
    now=_utcnow(); until=_lease_until()
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""UPDATE bot_lock SET lease_until=%s, updated_at=%s
                           WHERE holder=%s AND lease_until > %s RETURNING id""",
                        (until, now, holder, now))
            ok=cur.fetchone()
        conn.commit()
    return bool(ok)

async def lock_renew_loop(holder:str):
    while True:
        await asyncio.sleep(LOCK_RENEW_EVERY)
        try:
            if not renew_lock(holder):
                try: await bot.close()
                except Exception: pass
                print("LOCK LOST ‚Äî another instance took the lease. Exiting.", flush=True)
                os._exit(0)
        except Exception as e:
            print(f"LOCK RENEW ERROR: {e}", flush=True)

# ---------- ŸÑŸàÿ≠ÿ© ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ----------
@dp.message(F.text == BTN_SCORE)
async def score_entry(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    # ÿßÿ≥ÿ™ÿÆÿ±ÿ¨ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÑŸä ŸÅŸäŸáÿß ŸÜÿ¥ÿ±
    rows = q_all("SELECT DISTINCT chat_id FROM quiz_runs ORDER BY chat_id")
    if not rows:
        await msg.answer("üö´ ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£Ÿä ŸÜÿ™ÿßÿ¶ÿ¨ ÿ®ÿπÿØ.")
        return
    kb = InlineKeyboardBuilder()
    for r in rows:
        label = await get_chat_label(r["chat_id"])
        kb.button(text=label, callback_data=f"score_group:{r['chat_id']}")
    kb.adjust(1)
    await state.set_state(ScoreByGroupStates.pick_group)
    await msg.answer("üìä ÿßÿÆÿ™ÿ± ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ŸÑÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨:", reply_markup=kb.as_markup())

@dp.callback_query(ScoreByGroupStates.pick_group, F.data.startswith("score_group:"))
async def score_pick_group(cb: CallbackQuery, state: FSMContext):
    chat_id = int(cb.data.split(":")[1])
    await state.update_data(chat_id=chat_id)
    # ÿ¨ŸÑÿ® ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜ Ÿáÿ∞ÿß ÿßŸÑÿ¥ÿßÿ™
    rows = q_all("SELECT DISTINCT quiz_id FROM quiz_runs WHERE chat_id=%s ORDER BY quiz_id",(chat_id,))
    if not rows:
        await cb.message.edit_text("üö´ ŸÑÿß ŸäŸàÿ¨ÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ŸÖŸÜÿ¥Ÿàÿ±ÿ© ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.")
        return
    kb=InlineKeyboardBuilder()
    for r in rows:
        qz = q_one("SELECT title FROM quizzes WHERE id=%s",(r["quiz_id"],))
        kb.button(text=f"{r['quiz_id']} ‚Äî {qz['title']}", callback_data=f"score_quiz:{r['quiz_id']}")
    kb.adjust(1)
    await state.set_state(ScoreByGroupStates.pick_quiz)
    await cb.message.edit_text("üìö ÿßÿÆÿ™ÿ± ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±:", reply_markup=kb.as_markup())

@dp.callback_query(ScoreByGroupStates.pick_quiz, F.data.startswith("score_quiz:"))
async def score_pick_quiz(cb: CallbackQuery, state: FSMContext):
    quiz_id = int(cb.data.split(":")[1])
    data = await state.get_data()
    chat_id = data["chat_id"]
    await state.update_data(quiz_id=quiz_id)
    # ÿ¨ŸÑÿ® ÿ¨ŸÑÿ≥ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±
    rows = q_all("SELECT id,published_at FROM quiz_runs WHERE chat_id=%s AND quiz_id=%s ORDER BY id",(chat_id,quiz_id))
    if not rows:
        await cb.message.edit_text("üö´ ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ¨ŸÑÿ≥ÿßÿ™ ŸÜÿ¥ÿ± ŸÑŸáÿ∞ÿß ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±.")
        return
    kb=InlineKeyboardBuilder()
    for r in rows:
        ts = fmt_berlin(r["published_at"])
        kb.button(text=f"ÿ¨ŸÑÿ≥ÿ© {r['id']} ‚Äî {ts}", callback_data=f"score_run:{r['id']}")
    kb.adjust(1)
    await state.set_state(ScoreByGroupStates.pick_run)
    await cb.message.edit_text("‚è≥ ÿßÿÆÿ™ÿ± ÿ¨ŸÑÿ≥ÿ© ÿßŸÑŸÜÿ¥ÿ±:", reply_markup=kb.as_markup())

@dp.callback_query(ScoreByGroupStates.pick_run, F.data.startswith("score_run:"))
async def score_pick_run(cb: CallbackQuery, state: FSMContext):
    run_id = int(cb.data.split(":")[1])
    data = await state.get_data()
    chat_id, quiz_id = data["chat_id"], data["quiz_id"]

    # ÿ¨ŸÑÿ® ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
    rows = q_all("""SELECT user_id, username, SUM(is_correct)::int AS corrects, COUNT(*) AS total
                    FROM quiz_responses
                    WHERE chat_id=%s AND quiz_id=%s AND run_id=%s
                    GROUP BY user_id, username
                    ORDER BY corrects DESC""",
                 (chat_id, quiz_id, run_id))
    if not rows:
        await cb.message.edit_text("üö´ ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ•ÿ¨ÿßÿ®ÿßÿ™ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑÿ¨ŸÑÿ≥ÿ©.")
        return

    lines=[]
    rank=1
    for r in rows:
        nm = r["username"] or f"UID {r['user_id']}"
        lines.append(f"{rank}. {nm} ‚Äî {r['corrects']}/{r['total']}")
        rank+=1
    text="üèÜ <b>ŸÑŸàÿ≠ÿ© ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨</b>\n" + "\n".join(lines)
    await cb.message.edit_text(text)

# ---------- ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ®ÿ±ŸäŸÅ ----------
@dp.message(F.text == BTN_BRIEF_RESULTS)
async def brief_results_entry(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    rows = q_all("SELECT DISTINCT origin_chat_id FROM brief_windows ORDER BY origin_chat_id")
    if not rows:
        await msg.answer("üö´ ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£Ÿä ŸÜŸàÿßŸÅÿ∞ ÿ®ÿ±ŸäŸÅ.")
        return
    kb = InlineKeyboardBuilder()
    for r in rows:
        label = await get_chat_label(r["origin_chat_id"])
        kb.button(text=label, callback_data=f"brief_group:{r['origin_chat_id']}")
    kb.adjust(1)
    await state.set_state(BriefResultStates.pick_group)
    await msg.answer("‚úâÔ∏è ÿßÿÆÿ™ÿ± ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©:", reply_markup=kb.as_markup())

@dp.callback_query(BriefResultStates.pick_group, F.data.startswith("brief_group:"))
async def brief_pick_group(cb: CallbackQuery, state: FSMContext):
    chat_id = int(cb.data.split(":")[1])
    await state.update_data(chat_id=chat_id)
    rows = q_all("""SELECT id,opened_at,closes_at,prompt_text
                    FROM brief_windows
                    WHERE origin_chat_id=%s
                    ORDER BY id DESC""",(chat_id,))
    if not rows:
        await cb.message.edit_text("üö´ ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜŸàÿßŸÅÿ∞ ÿ®ÿ±ŸäŸÅ ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.")
        return
    kb=InlineKeyboardBuilder()
    for r in rows:
        ts = fmt_berlin(r["opened_at"])
        kb.button(text=f"ŸÜÿßŸÅÿ∞ÿ© {r['id']} ‚Äî {ts}", callback_data=f"brief_window:{r['id']}")
    kb.adjust(1)
    await state.set_state(BriefResultStates.pick_window)
    await cb.message.edit_text("üìã ÿßÿÆÿ™ÿ± ŸÜÿßŸÅÿ∞ÿ© ÿßŸÑÿ®ÿ±ŸäŸÅ:", reply_markup=kb.as_markup())

@dp.callback_query(BriefResultStates.pick_window, F.data.startswith("brief_window:"))
async def brief_pick_window(cb: CallbackQuery, state: FSMContext):
    window_id = int(cb.data.split(":")[1])
    win = q_one("SELECT * FROM brief_windows WHERE id=%s",(window_id,))
    if not win:
        await cb.message.edit_text("üö´ ŸÜÿßŸÅÿ∞ÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©.")
        return

    # ÿ¨ŸÑÿ® ÿßŸÑÿ®ÿ±ŸäŸÅÿßÿ™
    rows = q_all("""SELECT user_id, username, text, evaluated_at, score, level
                    FROM writing_submissions
                    WHERE window_id=%s
                    ORDER BY evaluated_at""",(window_id,))
    if not rows:
        await cb.message.edit_text("üö´ ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ÿ±ŸäŸÅÿßÿ™ ŸÖÿ±ÿ≥ŸÑÿ©.")
        return

    lines=[]
    for r in rows:
        nm = r["username"] or f"UID {r['user_id']}"
        t = fmt_berlin(r["evaluated_at"])
        lines.append(f"üë§ {nm}\nüïí {t}\nüìÑ {r['text']}\n‚úÖ {r['score']} ‚Äî {r['level']}\n---")

    text=(f"üìä <b>ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ®ÿ±ŸäŸÅ</b>\n"
          f"ŸÖŸÜ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©: {await get_chat_label(win['origin_chat_id'])}\n"
          f"ÿßŸÑŸÜÿµ: {win.get('prompt_text') or '-'}\n"
          f"ŸÖŸÜ {fmt_berlin(win['opened_at'])} ÿ≠ÿ™Ÿâ {fmt_berlin(win['closes_at'])}\n\n" +
          "\n".join(lines))
    await cb.message.edit_text(text)

# ---------- Main ----------
async def main():
    holder = f"{INSTANCE_ID}:{os.getpid()}"
    got = False
    try:
        got = try_acquire_lock(holder)
    except Exception as e:
        print(f"LOCK ACQUIRE ERROR: {e}", flush=True)

    if not got:
        print("Another instance is active. Exiting.", flush=True)
        return

    # ÿ¨ÿØŸàŸÑÿ© ÿ™ÿ¨ÿØŸäÿØ ÿßŸÑŸÇŸÅŸÑ
    asyncio.create_task(lock_renew_loop(holder))

    # ‚úÖ ŸÖŸáŸÖ: ÿ£ÿ®ŸÇŸä ÿπŸÑŸâ ÿ≠ŸÑŸÇÿ© ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿßÿ≥ÿ™ÿ∑ŸÑÿßÿπÿßÿ™ ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ© ŸÉŸÖÿß ŸÅŸä ŸÉŸàÿØŸÉ ÿßŸÑÿ£ÿµŸÑŸä
    asyncio.create_task(close_expired_polls_loop())

    # ÿßÿ®ÿØÿ£ ÿßŸÑÿ®Ÿàÿ™
    await dp.start_polling(bot, allowed_updates=["message","callback_query","poll_answer"])

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass
