#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re, tempfile, math, uuid, random
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile, File,
    ReactionTypeEmoji
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

# --- Europe/Berlin timezone for display ---
try:
    from zoneinfo import ZoneInfo
    TZ_BERLIN = ZoneInfo("Europe/Berlin")
except Exception:
    TZ_BERLIN = None

load_dotenv()

# --- Flood control delays ---
POLL_BASE_DELAY = float(os.getenv('POLL_BASE_DELAY', '0.9'))
POLL_JITTER = float(os.getenv('POLL_JITTER', '0.6'))
ATTACH_BASE_DELAY = float(os.getenv('ATTACH_BASE_DELAY', '1.2'))
ATTACH_JITTER = float(os.getenv('ATTACH_JITTER', '0.8'))

async def sleep_jitter(kind: str = 'poll'):
    if kind == 'attach':
        await asyncio.sleep(ATTACH_BASE_DELAY + random.random()*ATTACH_JITTER)
    else:
        await asyncio.sleep(POLL_BASE_DELAY + random.random()*POLL_JITTER)

BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

# --- Single-instance lease lock config (NEW) ---
INSTANCE_ID = os.getenv("INSTANCE_ID", "").strip() or f"inst-{uuid.uuid4().hex[:8]}"
LOCK_TTL_SECONDS = int(os.getenv("LOCK_TTL_SECONDS", "40"))
LOCK_RENEW_EVERY = int(os.getenv("LOCK_RENEW_EVERY", "15"))

bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

def insert_returning_id(sql:str, params:tuple|list|None=None)->int:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql + " RETURNING id", params or ())
            row = cur.fetchone()
        conn.commit()
    return int(row["id"] if isinstance(row, dict) else row[0])

# ---------- Schema + Migrations ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, username TEXT,
            text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT,
            window_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            question_id INTEGER NOT NULL,
            user_id BIGINT NOT NULL,
            username TEXT,
            option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL,
            answered_at TEXT NOT NULL,
            run_id INTEGER
        )""",
        """CREATE TABLE IF NOT EXISTS shared_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            kind TEXT NOT NULL,
            file_id TEXT NOT NULL,
            title TEXT,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_runs(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            published_at TEXT NOT NULL,
            grade_enabled INTEGER NOT NULL DEFAULT 0
        )""",
        # NEW: Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù‚ÙÙ„ (Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ÙˆÙ‚Øª ØµØ­ÙŠØ­Ø© TIMESTAMPTZ)
        """CREATE TABLE IF NOT EXISTS bot_lock(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            instance_id TEXT NOT NULL,
            holder      TEXT NOT NULL,
            lease_until TIMESTAMPTZ NOT NULL,
            updated_at  TIMESTAMPTZ NOT NULL
        )""",
        # ÙÙ‡Ø±Ø³ ÙŠØ¶Ù…Ù† ØµÙ ÙˆØ§Ø­Ø¯ ÙÙ‚Ø· (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ø¨Ø³ Ù…ÙÙŠØ¯)
        """CREATE UNIQUE INDEX IF NOT EXISTS bot_lock_one ON bot_lock((1))""",
        # NEW: ÙƒØ§Ø´ Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
        """CREATE TABLE IF NOT EXISTS chats_cache(
            chat_id   BIGINT PRIMARY KEY,
            title     TEXT,
            type      TEXT,
            updated_at TIMESTAMPTZ NOT NULL
        )""",
    ]
    for ddl in ddls:
        q_exec(ddl)

def migrate_schema():
    # Ù…Ù€Ø§ÙŠØ¬Ø±ÙŠØ´Ù†Ø§ØªÙƒ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ÙƒÙ…Ø§ Ù‡ÙŠ
    q_exec("ALTER TABLE sent_polls ADD COLUMN IF NOT EXISTS run_id INTEGER")
    q_exec("ALTER TABLE quiz_responses ADD COLUMN IF NOT EXISTS run_id INTEGER")
    q_exec("ALTER TABLE brief_windows ADD COLUMN IF NOT EXISTS prompt_text TEXT")
    q_exec("ALTER TABLE brief_windows ADD COLUMN IF NOT EXISTS ann_message_id BIGINT")
    q_exec("ALTER TABLE writing_submissions ADD COLUMN IF NOT EXISTS username TEXT")
    q_exec("ALTER TABLE writing_submissions ADD COLUMN IF NOT EXISTS window_id INTEGER")
    q_exec("ALTER TABLE quiz_runs ADD COLUMN IF NOT EXISTS grade_enabled INTEGER NOT NULL DEFAULT 0")

    # NEW: ØªØ£ÙƒØ¯ Ø£Ù† Ø£Ø¹Ù…Ø¯Ø© bot_lock Ù…Ù† Ù†ÙˆØ¹ TIMESTAMPTZ (Ø¹Ù„Ø§Ø¬ Ø§Ù„Ø®Ø·Ø£ text <= timestamptz)
    try:
        q_exec("""
            ALTER TABLE bot_lock
              ALTER COLUMN lease_until TYPE TIMESTAMPTZ USING lease_until::timestamptz
        """)
    except Exception:
        pass
    try:
        q_exec("""
            ALTER TABLE bot_lock
              ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at::timestamptz
        """)
    except Exception:
        pass

    # NEW: Ø£Ø¹Ù…Ø¯Ø© Ù…Ø¶Ù…ÙˆÙ†Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
    q_exec("ALTER TABLE bot_lock ADD COLUMN IF NOT EXISTS instance_id TEXT NOT NULL DEFAULT ''")
    q_exec("ALTER TABLE bot_lock ADD COLUMN IF NOT EXISTS holder TEXT NOT NULL DEFAULT ''")
    # Ø´ÙŠÙ„ Ø§Ù„Ø¯ÙŠÙÙˆÙ„Øª Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø­ØªÙ‰ ØªØ¶Ù„ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© NOT NULL Ø¨Ø¯ÙˆÙ† Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    q_exec("ALTER TABLE bot_lock ALTER COLUMN instance_id DROP DEFAULT")
    q_exec("ALTER TABLE bot_lock ALTER COLUMN holder DROP DEFAULT")

    # NEW: ÙÙ‡Ø±Ø³ Ø§Ù„Ù‚ÙÙ„ Ø¥Ø°Ø§ Ù…Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯
    q_exec("CREATE UNIQUE INDEX IF NOT EXISTS bot_lock_one ON bot_lock((1))")

    # NEW: ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ø¯ÙˆÙ„ Ø§Ù„ÙƒØ§Ø´ (Ù„Ùˆ Ù†Ø³Ø® Ù‚Ø¯ÙŠÙ… Ù…Ø§ ÙÙŠÙ‡ ensure Ø­Ø¯ÙŠØ«)
    q_exec("""CREATE TABLE IF NOT EXISTS chats_cache(
                chat_id   BIGINT PRIMARY KEY,
                title     TEXT,
                type      TEXT,
                updated_at TIMESTAMPTZ NOT NULL
             )""")


ensure_schema()
migrate_schema()

# ---------- UI ----------
BTN_NEWQUIZ="ğŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_ADDQ="â• Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„"; BTN_LISTQUIZ="ğŸ“š Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EDITQUIZ="ğŸ› ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø±"; BTN_DELQUIZ="ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø±"
BTN_BUNDLES="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©"; BTN_MERGE="ğŸ”— Ø¯Ù…Ø¬ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EXPORT="ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_IMPORT="ğŸ“¥ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙØ¹Ø©"
BTN_PUBLISH="ğŸš€ Ù†Ø´Ø± Ø§Ø®ØªØ¨Ø§Ø±"; BTN_WIPE_ALL="ğŸ§¹ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_SCORE="ğŸ† Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬"; BTN_BACK_HOME="â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©"; BTN_BACK_STEP="â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø®Ù„Ù"
BTN_BRIEF="âœ‰ï¸ Ø²Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ"
BTN_LISTQUESTIONS="ğŸ“ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©"
BTN_EDITQUESTION="âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ø³Ø¤Ø§Ù„"
BTN_DELQUESTION="ğŸ—‘ï¸ Ø­Ø°Ù Ø³Ø¤Ø§Ù„"
# NEW button (Ù„Ø§ Ø­Ø°Ù Ù„Ø£ÙŠ Ø²Ø± Ù‚Ø¯ÙŠÙ…)
BTN_BRIEF_RESULTS = "ğŸ“Š Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ"

def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_EDITQUIZ)],
        [KeyboardButton(text=BTN_LISTQUESTIONS), KeyboardButton(text=BTN_EDITQUESTION)],
        [KeyboardButton(text=BTN_DELQUESTION)],
        [KeyboardButton(text=BTN_DELQUIZ), KeyboardButton(text=BTN_BRIEF)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_EXPORT), KeyboardButton(text=BTN_IMPORT)],
        [KeyboardButton(text=BTN_BUNDLES), KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_BRIEF_RESULTS)],  # NEW: ØµÙ Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ø²Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
        [KeyboardButton(text=BTN_WIPE_ALL)],
    ]
    return ReplyKeyboardMarkup(
        keyboard=rows, resize_keyboard=True, one_time_keyboard=True,
        is_persistent=False, input_field_placeholder="Ø§Ø®ØªØ± Ø£Ù…Ø±Ù‹Ø§ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± ğŸ‘‡"
    )

ALL_BTN_TEXTS = {
    BTN_BACK_HOME, BTN_BACK_STEP, BTN_NEWQUIZ, BTN_ADDQ, BTN_LISTQUIZ, BTN_EDITQUIZ,
    BTN_DELQUIZ, BTN_BRIEF, BTN_WIPE_ALL, BTN_SCORE, BTN_PUBLISH, BTN_BUNDLES,
    BTN_MERGE, BTN_EXPORT, BTN_IMPORT, BTN_LISTQUESTIONS, BTN_EDITQUESTION, BTN_DELQUESTION,
    BTN_BRIEF_RESULTS  # NEW
}

def done_button_kb(tag: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"done:{tag}")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª", callback_data=f"skip:{tag}")
    kb.adjust(2); return kb.as_markup()

def inline_confirm_kb(tag:str):
    kb=InlineKeyboardBuilder()
    kb.button(text="âœ… ØªØ£ÙƒÙŠØ¯", callback_data=f"{tag}:yes")
    kb.button(text="âŒ Ø¥Ù„ØºØ§Ø¡", callback_data=f"{tag}:no")
    kb.adjust(2); return kb.as_markup()

def attach_choice_kb():
    kb=InlineKeyboardBuilder()
    kb.button(text="ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ø®Ø§ØµØ©", callback_data="att:upload")
    kb.button(text="ğŸ“ Ù…Ù† Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©", callback_data="att:shared")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† Ù…Ø±ÙÙ‚Ø§Øª", callback_data="att:none")
    kb.adjust(2,1); return kb.as_markup()

def shared_list_kb(question_id:int):
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    kb=InlineKeyboardBuilder()
    for r in rows:
        label=f"{r['id']} â€” {r['kind']} â€” {(r['title'] or '')[:20]}"
        kb.button(text=label, callback_data=f"attadd:{question_id}:{r['id']}")
    kb.button(text="âœ”ï¸ ØªÙ…", callback_data=f"attdone:{question_id}")
    kb.adjust(1)
    return kb.as_markup()

def publish_hours_kb(quiz_id:int):
    kb=InlineKeyboardBuilder()
    for h in (1,2,4,8,24):
        kb.button(text=f"â³ {h} Ø³Ø§Ø¹Ø©", callback_data=f"pubdur:{quiz_id}:{h}")
    kb.button(text="âŒ¨ï¸ Ø±Ù‚Ù… Ù…Ø®ØµØµ", callback_data=f"pubdur:{quiz_id}:custom")
    kb.button(text="â™¾ï¸ Ø¨Ø¯ÙˆÙ† Ù…Ø¤Ù‚Ù‘Øª", callback_data=f"pubdur:{quiz_id}:0")
    kb.adjust(2,2,1)
    return kb.as_markup()

def publish_eval_kb(quiz_id:int, hours:int):
    kb=InlineKeyboardBuilder()
    kb.button(text="âœ… ÙØ¹Ù‘Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…", callback_data=f"pubeval:{quiz_id}:{hours}:1")
    kb.button(text="âŒ Ø¨Ø¯ÙˆÙ† ØªÙ‚ÙŠÙŠÙ…", callback_data=f"pubeval:{quiz_id}:{hours}:0")
    kb.adjust(2)
    return kb.as_markup()

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def _utcnow()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID

async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±/Ø§Ù„Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", reply_markup=owner_kb()); return False
    return True

def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"

def mention_html(user_id:int, name:str)->str:
    safe = html.escape(name or "Ù…Ø³ØªØ®Ø¯Ù…")
    return f'<a href="tg://user?id={user_id}">{safe}</a>'

async def send_long(chat_id:int, text:str):
    MAX=3800
    buf=""
    for para in text.split("\n\n"):
        if len(buf)+len(para)+2>MAX and buf:
            await bot.send_message(chat_id, buf)
            buf=""
        buf += (("\n\n" if buf else "") + para)
    if buf:
        await bot.send_message(chat_id, buf)

# NEW: format ISO (UTC) to Europe/Berlin string for display
def fmt_berlin(iso_str:str)->str:
    if not iso_str:
        return "-"
    try:
        dt = datetime.fromisoformat(iso_str.replace("Z","+00:00"))
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        if TZ_BERLIN:
            dt = dt.astimezone(TZ_BERLIN)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return iso_str

# ---------- FSM States ----------
class NewQuizStates(StatesGroup):
    waiting_title          = State()
    waiting_question_text  = State()
    waiting_options        = State()
    waiting_corrects       = State()
    waiting_more_q         = State()

class AttachStates(StatesGroup):
    waiting_pick_quiz      = State()
    waiting_pick_question  = State()
    waiting_attach         = State()

class ScoreStates(StatesGroup):
    pick_quiz              = State()
    pick_run               = State()

class ScoreByGroupStates(StatesGroup):
    pick_group             = State()
    pick_quiz              = State()
    pick_run               = State()

# NEW: FSM Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ
class BriefResultStates(StatesGroup):
    pick_group             = State()
    pick_window            = State()

# ---------- Start / Back ----------
@dp.message(Command("start"))
async def cmd_start(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø¨ÙˆØª", reply_markup=owner_kb())

@dp.message(F.text == BTN_BACK_HOME)
async def back_home(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("ğŸ  Ø±Ø¬Ø¹Ù†Ø§Ùƒ Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", reply_markup=owner_kb())

@dp.message(F.text == BTN_BACK_STEP)
async def back_step(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("â¬…ï¸ Ø±Ø¬Ø¹Ù†Ø§Ùƒ Ø®Ø·ÙˆØ© Ù„Ù„Ø®Ù„Ù", reply_markup=owner_kb())

# ---------- Cache chat labels ----------
async def get_chat_label(chat_id:int)->str:
    row = q_one("SELECT title FROM chats_cache WHERE chat_id=%s", (chat_id,))
    if row and row.get("title"):
        return row["title"]
    try:
        ch = await bot.get_chat(chat_id)
        title = ch.title or (getattr(ch,"full_name",None) or str(chat_id))
        q_exec("""INSERT INTO chats_cache(chat_id,title,type,updated_at)
                  VALUES (%s,%s,%s,%s)
                  ON CONFLICT (chat_id) DO UPDATE SET title=EXCLUDED.title, type=EXCLUDED.type, updated_at=EXCLUDED.updated_at""",
               (chat_id, title, getattr(ch,"type",""), _now().isoformat()))
        return title
    except Exception:
        return str(chat_id)

# ---------- Single-instance lock helpers ----------
def _lease_until(): return _utcnow() + timedelta(seconds=LOCK_TTL_SECONDS)

def try_acquire_lock(holder:str)->bool:
    now=_utcnow(); until=_lease_until()
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""UPDATE bot_lock
                           SET instance_id=%s, holder=%s, lease_until=%s, updated_at=%s
                           WHERE (lease_until <= %s) OR (holder=%s)
                           RETURNING id""",
                        (INSTANCE_ID, holder, until, now, now, holder))
            row = cur.fetchone()
            if not row:
                cur.execute("SELECT COUNT(*) FROM bot_lock WHERE lease_until > %s",(now,))
                active=cur.fetchone()[0]
                if active==0:
                    cur.execute("""INSERT INTO bot_lock(instance_id,holder,lease_until,updated_at)
                                   VALUES (%s,%s,%s,%s) RETURNING id""",
                                (INSTANCE_ID, holder, until, now))
                    row=cur.fetchone()
        conn.commit()
    return bool(row)

def renew_lock(holder:str)->bool:
    now=_utcnow(); until=_lease_until()
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute("""UPDATE bot_lock SET lease_until=%s, updated_at=%s
                           WHERE holder=%s AND lease_until > %s RETURNING id""",
                        (until, now, holder, now))
            ok=cur.fetchone()
        conn.commit()
    return bool(ok)

async def lock_renew_loop(holder:str):
    while True:
        await asyncio.sleep(LOCK_RENEW_EVERY)
        try:
            if not renew_lock(holder):
                try: await bot.close()
                except Exception: pass
                print("LOCK LOST â€” another instance took the lease. Exiting.", flush=True)
                os._exit(0)
        except Exception as e:
            print(f"LOCK RENEW ERROR: {e}", flush=True)

# ---------- Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ----------
@dp.message(F.text == BTN_SCORE)
async def score_entry(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    # Ø§Ø³ØªØ®Ø±Ø¬ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡Ø§ Ù†Ø´Ø±
    rows = q_all("SELECT DISTINCT chat_id FROM quiz_runs ORDER BY chat_id")
    if not rows:
        await msg.answer("ğŸš« Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙŠ Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯.")
        return
    kb = InlineKeyboardBuilder()
    for r in rows:
        label = await get_chat_label(r["chat_id"])
        kb.button(text=label, callback_data=f"score_group:{r['chat_id']}")
    kb.adjust(1)
    await state.set_state(ScoreByGroupStates.pick_group)
    await msg.answer("ğŸ“Š Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:", reply_markup=kb.as_markup())

@dp.callback_query(ScoreByGroupStates.pick_group, F.data.startswith("score_group:"))
async def score_pick_group(cb: CallbackQuery, state: FSMContext):
    chat_id = int(cb.data.split(":")[1])
    await state.update_data(chat_id=chat_id)
    # Ø¬Ù„Ø¨ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø´Ø§Øª
    rows = q_all("SELECT DISTINCT quiz_id FROM quiz_runs WHERE chat_id=%s ORDER BY quiz_id",(chat_id,))
    if not rows:
        await cb.message.edit_text("ğŸš« Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù…Ù†Ø´ÙˆØ±Ø© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.")
        return
    kb=InlineKeyboardBuilder()
    for r in rows:
        qz = q_one("SELECT title FROM quizzes WHERE id=%s",(r["quiz_id"],))
        kb.button(text=f"{r['quiz_id']} â€” {qz['title']}", callback_data=f"score_quiz:{r['quiz_id']}")
    kb.adjust(1)
    await state.set_state(ScoreByGroupStates.pick_quiz)
    await cb.message.edit_text("ğŸ“š Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=kb.as_markup())

@dp.callback_query(ScoreByGroupStates.pick_quiz, F.data.startswith("score_quiz:"))
async def score_pick_quiz(cb: CallbackQuery, state: FSMContext):
    quiz_id = int(cb.data.split(":")[1])
    data = await state.get_data()
    chat_id = data["chat_id"]
    await state.update_data(quiz_id=quiz_id)
    # Ø¬Ù„Ø¨ Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù†Ø´Ø±
    rows = q_all("SELECT id,published_at FROM quiz_runs WHERE chat_id=%s AND quiz_id=%s ORDER BY id",(chat_id,quiz_id))
    if not rows:
        await cb.message.edit_text("ğŸš« Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª Ù†Ø´Ø± Ù„Ù‡Ø°Ø§ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.")
        return
    kb=InlineKeyboardBuilder()
    for r in rows:
        ts = fmt_berlin(r["published_at"])
        kb.button(text=f"Ø¬Ù„Ø³Ø© {r['id']} â€” {ts}", callback_data=f"score_run:{r['id']}")
    kb.adjust(1)
    await state.set_state(ScoreByGroupStates.pick_run)
    await cb.message.edit_text("â³ Ø§Ø®ØªØ± Ø¬Ù„Ø³Ø© Ø§Ù„Ù†Ø´Ø±:", reply_markup=kb.as_markup())

@dp.callback_query(ScoreByGroupStates.pick_run, F.data.startswith("score_run:"))
async def score_pick_run(cb: CallbackQuery, state: FSMContext):
    run_id = int(cb.data.split(":")[1])
    data = await state.get_data()
    chat_id, quiz_id = data["chat_id"], data["quiz_id"]

    # Ø¬Ù„Ø¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    rows = q_all("""SELECT user_id, username, SUM(is_correct)::int AS corrects, COUNT(*) AS total
                    FROM quiz_responses
                    WHERE chat_id=%s AND quiz_id=%s AND run_id=%s
                    GROUP BY user_id, username
                    ORDER BY corrects DESC""",
                 (chat_id, quiz_id, run_id))
    if not rows:
        await cb.message.edit_text("ğŸš« Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¬Ù„Ø³Ø©.")
        return

    lines=[]
    rank=1
    for r in rows:
        nm = r["username"] or f"UID {r['user_id']}"
        lines.append(f"{rank}. {nm} â€” {r['corrects']}/{r['total']}")
        rank+=1
    text="ğŸ† <b>Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬</b>\n" + "\n".join(lines)
    await cb.message.edit_text(text)

# ---------- Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ ----------
@dp.message(F.text == BTN_BRIEF_RESULTS)
async def brief_results_entry(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    rows = q_all("SELECT DISTINCT origin_chat_id FROM brief_windows ORDER BY origin_chat_id")
    if not rows:
        await msg.answer("ğŸš« Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙŠ Ù†ÙˆØ§ÙØ° Ø¨Ø±ÙŠÙ.")
        return
    kb = InlineKeyboardBuilder()
    for r in rows:
        label = await get_chat_label(r["origin_chat_id"])
        kb.button(text=label, callback_data=f"brief_group:{r['origin_chat_id']}")
    kb.adjust(1)
    await state.set_state(BriefResultStates.pick_group)
    await msg.answer("âœ‰ï¸ Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:", reply_markup=kb.as_markup())

@dp.callback_query(BriefResultStates.pick_group, F.data.startswith("brief_group:"))
async def brief_pick_group(cb: CallbackQuery, state: FSMContext):
    chat_id = int(cb.data.split(":")[1])
    await state.update_data(chat_id=chat_id)
    rows = q_all("""SELECT id,opened_at,closes_at,prompt_text
                    FROM brief_windows
                    WHERE origin_chat_id=%s
                    ORDER BY id DESC""",(chat_id,))
    if not rows:
        await cb.message.edit_text("ğŸš« Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ÙˆØ§ÙØ° Ø¨Ø±ÙŠÙ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.")
        return
    kb=InlineKeyboardBuilder()
    for r in rows:
        ts = fmt_berlin(r["opened_at"])
        kb.button(text=f"Ù†Ø§ÙØ°Ø© {r['id']} â€” {ts}", callback_data=f"brief_window:{r['id']}")
    kb.adjust(1)
    await state.set_state(BriefResultStates.pick_window)
    await cb.message.edit_text("ğŸ“‹ Ø§Ø®ØªØ± Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¨Ø±ÙŠÙ:", reply_markup=kb.as_markup())

@dp.callback_query(BriefResultStates.pick_window, F.data.startswith("brief_window:"))
async def brief_pick_window(cb: CallbackQuery, state: FSMContext):
    window_id = int(cb.data.split(":")[1])
    win = q_one("SELECT * FROM brief_windows WHERE id=%s",(window_id,))
    if not win:
        await cb.message.edit_text("ğŸš« Ù†Ø§ÙØ°Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©.")
        return

    # Ø¬Ù„Ø¨ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª
    rows = q_all("""SELECT user_id, username, text, evaluated_at, score, level
                    FROM writing_submissions
                    WHERE window_id=%s
                    ORDER BY evaluated_at""",(window_id,))
    if not rows:
        await cb.message.edit_text("ğŸš« Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨Ø±ÙŠÙØ§Øª Ù…Ø±Ø³Ù„Ø©.")
        return

    lines=[]
    for r in rows:
        nm = r["username"] or f"UID {r['user_id']}"
        t = fmt_berlin(r["evaluated_at"])
        lines.append(f"ğŸ‘¤ {nm}\nğŸ•’ {t}\nğŸ“„ {r['text']}\nâœ… {r['score']} â€” {r['level']}\n---")

    text=(f"ğŸ“Š <b>Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø±ÙŠÙ</b>\n"
          f"Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: {await get_chat_label(win['origin_chat_id'])}\n"
          f"Ø§Ù„Ù†Øµ: {win.get('prompt_text') or '-'}\n"
          f"Ù…Ù† {fmt_berlin(win['opened_at'])} Ø­ØªÙ‰ {fmt_berlin(win['closes_at'])}\n\n" +
          "\n".join(lines))
    await cb.message.edit_text(text)

# ---------- Main ----------
async def main():
    holder = f"{INSTANCE_ID}:{os.getpid()}"
    got = False
    try:
        got = try_acquire_lock(holder)
    except Exception as e:
        print(f"LOCK ACQUIRE ERROR: {e}", flush=True)

    if not got:
        print("Another instance is active. Exiting.", flush=True)
        return

    # Ø¬Ø¯ÙˆÙ„Ø© ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ù‚ÙÙ„
    asyncio.create_task(lock_renew_loop(holder))

    # âœ… Ù…Ù‡Ù…: Ø£Ø¨Ù‚ÙŠ Ø¹Ù„Ù‰ Ø­Ù„Ù‚Ø© Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø§Ø³ØªØ·Ù„Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© ÙƒÙ…Ø§ ÙÙŠ ÙƒÙˆØ¯Ùƒ Ø§Ù„Ø£ØµÙ„ÙŠ
    asyncio.create_task(close_expired_polls_loop())

    # Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¨ÙˆØª
    await dp.start_polling(bot, allowed_updates=["message","callback_query","poll_answer"])

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass
