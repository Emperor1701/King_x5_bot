#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Telegram Quiz Bot (Railway + PostgreSQL)
- Export (JSON)
- HL (HÃ¶ren & Lesen) auto-level B1 DTZ
- Schreiben (Brief/E-Mail) grading with OpenAI (fallback if no key)
- Brief timed window (owner-only trigger)
- Scoreboard shows level for HL

Requirements (requirements.txt):
  aiogram==3.*
  python-dotenv
  psycopg[binary,pool]
  openai        # Ø§Ø®ØªÙŠØ§Ø±ÙŠ

ENV (Railway Variables):
  BOT_TOKEN=...
  OWNER_ID=123456789
  DATABASE_URL=postgres://USER:PASS@HOST:PORT/DBNAME
  OPENAI_API_KEY=sk-...      # Ø§Ø®ØªÙŠØ§Ø±ÙŠ
"""

import asyncio
import os
import json
import html
import re
from datetime import datetime, timezone, timedelta
from typing import Optional, Tuple, Dict, List

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F, types
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.types import (
    Message, CallbackQuery,
    InlineKeyboardMarkup,
    ReplyKeyboardMarkup, KeyboardButton,
    FSInputFile
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

# OpenAI (optional)
try:
    from openai import OpenAI
except Exception:
    OpenAI = None  # type: ignore

# ---------- ENV ----------
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()

if not BOT_TOKEN:
    raise SystemExit("âŒ BOT_TOKEN missing")
if not OWNER_ID:
    raise SystemExit("âŒ OWNER_ID missing")
if not DATABASE_URL:
    raise SystemExit("âŒ DATABASE_URL (Postgres) missing")

# ---------- BOT ----------
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres (psycopg pool) ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool

pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})
print("[DB] Connected to Postgres")

def q_exec(sql: str, params: tuple | list | None = None) -> None:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql: str, params: tuple | list | None = None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql: str, params: tuple | list | None = None) -> List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

def ensure_schema():
    ddl = [
        # quizzes
        """
        CREATE TABLE IF NOT EXISTS quizzes(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          title TEXT NOT NULL,
          created_by BIGINT NOT NULL,
          created_at TEXT NOT NULL,
          is_archived INTEGER NOT NULL DEFAULT 0,
          grading_profile TEXT NOT NULL DEFAULT 'NONE'
        )""",
        # questions
        """
        CREATE TABLE IF NOT EXISTS questions(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          quiz_id INTEGER NOT NULL,
          text TEXT NOT NULL,
          created_at TEXT NOT NULL,
          media_bundle_id INTEGER,
          photo TEXT,
          audio TEXT,
          audio_is_voice INTEGER DEFAULT 0
        )""",
        # options
        """
        CREATE TABLE IF NOT EXISTS options(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          question_id INTEGER NOT NULL,
          option_index INTEGER NOT NULL,
          text TEXT NOT NULL,
          is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        # responses
        """
        CREATE TABLE IF NOT EXISTS responses(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          chat_id BIGINT NOT NULL,
          user_id BIGINT NOT NULL,
          question_id INTEGER NOT NULL,
          option_index INTEGER NOT NULL,
          is_correct INTEGER NOT NULL,
          answered_at TEXT NOT NULL,
          UNIQUE(chat_id, user_id, question_id)
        )""",
        # participant_names
        """
        CREATE TABLE IF NOT EXISTS participant_names(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          origin_chat_id BIGINT NOT NULL,
          user_id BIGINT NOT NULL,
          quiz_id INTEGER NOT NULL,
          name TEXT NOT NULL,
          UNIQUE(origin_chat_id, user_id, quiz_id)
        )""",
        # sent_polls
        """
        CREATE TABLE IF NOT EXISTS sent_polls(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          chat_id BIGINT NOT NULL,
          quiz_id INTEGER NOT NULL,
          question_id INTEGER NOT NULL,
          poll_id TEXT NOT NULL,
          message_id BIGINT,
          expires_at TEXT,
          is_closed INTEGER NOT NULL DEFAULT 0
        )""",
        # attachments
        """
        CREATE TABLE IF NOT EXISTS question_attachments(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          question_id INTEGER NOT NULL,
          kind TEXT NOT NULL,
          file_id TEXT NOT NULL,
          position INTEGER NOT NULL
        )""",
        """
        CREATE TABLE IF NOT EXISTS media_bundles(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          quiz_id INTEGER NOT NULL,
          created_at TEXT NOT NULL
        )""",
        """
        CREATE TABLE IF NOT EXISTS media_bundle_attachments(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          bundle_id INTEGER NOT NULL,
          kind TEXT NOT NULL,
          file_id TEXT NOT NULL,
          position INTEGER NOT NULL
        )""",
        # writing + HL
        """
        CREATE TABLE IF NOT EXISTS writing_submissions(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          origin_chat_id BIGINT NOT NULL,
          quiz_id INTEGER,
          user_id BIGINT NOT NULL,
          text TEXT NOT NULL,
          score INTEGER NOT NULL,
          level TEXT NOT NULL,
          evaluated_at TEXT NOT NULL,
          details_json TEXT
        )""",
        """
        CREATE TABLE IF NOT EXISTS hl_results(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          origin_chat_id BIGINT NOT NULL,
          quiz_id INTEGER NOT NULL,
          user_id BIGINT NOT NULL,
          correct_count INTEGER NOT NULL,
          total_count INTEGER NOT NULL,
          level TEXT NOT NULL,
          finished_at TEXT NOT NULL,
          UNIQUE(origin_chat_id, quiz_id, user_id)
        )""",
        # brief windows
        """
        CREATE TABLE IF NOT EXISTS brief_windows(
          id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          origin_chat_id BIGINT NOT NULL,
          opened_by BIGINT NOT NULL,
          opened_at TEXT NOT NULL,
          closes_at TEXT NOT NULL,
          is_open INTEGER NOT NULL DEFAULT 1
        )""",
    ]
    for stmt in ddl:
        q_exec(stmt)

ensure_schema()

# ---------- Utils ----------
def _now_utc() -> datetime: return datetime.now(timezone.utc)

def hlink_user(name: str, user_id: int) -> str:
    safe = name.replace("<", "&lt;").replace(">", "&gt;")
    return f'<a href="tg://user?id={user_id}">{safe}</a>'

def _slug(s: str) -> str:
    s = re.sub(r"\s+", "-", s.strip())
    s = re.sub(r"[^\w\-]+", "", s, flags=re.U)
    return s[:50] or "quiz"

def _display_name(u) -> str:
    parts = []
    if getattr(u, "first_name", None): parts.append(u.first_name)
    if getattr(u, "last_name", None): parts.append(u.last_name)
    nm = " ".join([p for p in parts if p]).strip()
    if not nm and getattr(u, "username", None): nm = f"@{u.username}"
    if not nm: nm = f"UID {u.id}"
    return nm

# Bands
SCHREIBEN_BANDS = [(0,6,"Unter A2"), (7,14,"A2"), (15,20,"B1")]
HL_BANDS        = [(0,19,"Unter A2"), (20,32,"A2"), (33,45,"B1")]

def map_level(score:int, bands) -> str:
    for lo, hi, name in bands:
        if lo <= score <= hi:
            return name
    return bands[-1][2]

# OpenAI client
client = None
if OPENAI_API_KEY and OpenAI:
    try:
        client = OpenAI(api_key=OPENAI_API_KEY)
    except Exception:
        client = None

async def ai_grade_schreiben(text: str) -> Tuple[int, str, Dict]:
    if not client:
        base = min(20, max(0, len(text)//35))
        lvl  = map_level(base, SCHREIBEN_BANDS)
        return base, lvl, {"note": "fallback heuristic (no OPENAI_API_KEY)"}
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            temperature=0.3,
            messages=[
                {"role":"system","content":"You are a certified Goethe/DTZ examiner. Grade B1 Schreiben (Brief/E-Mail) on a 0â€“20 scale (task fulfilment, coherence, range, accuracy, register). Return JSON: score(int), feedback(arabic short)."},
                {"role":"user","content": text},
            ],
            response_format={"type":"json_object"}
        )
        data = json.loads(resp.choices[0].message.content)
        score = int(max(0, min(20, int(data.get("score", 0)))))
        lvl   = map_level(score, SCHREIBEN_BANDS)
        return score, lvl, data
    except Exception as e:
        base = min(20, max(0, len(text)//40))
        lvl  = map_level(base, SCHREIBEN_BANDS)
        return base, lvl, {"error": str(e)}

# ---------- Brief window helpers ----------
def get_open_window(chat_id:int):
    now = _now_utc().isoformat()
    row = q_one(
        "SELECT id, closes_at FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",
        (chat_id,)
    )
    if not row:
        return None
    if row["closes_at"] <= now:
        q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s", (row["id"],))
        return None
    return row

def open_brief_window(chat_id:int, owner_id:int, minutes:int):
    opened_at = _now_utc()
    closes_at = opened_at + timedelta(minutes=minutes)
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1", (chat_id,))
    q_exec("INSERT INTO brief_windows(origin_chat_id,opened_by,opened_at,closes_at,is_open) VALUES (%s,%s,%s,%s,1)",
           (chat_id, owner_id, opened_at.isoformat(), closes_at.isoformat()))
    return closes_at

def close_brief_window(chat_id:int):
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1", (chat_id,))

# ---------- UI Text ----------
BTN_NEWQUIZ = "ğŸ†• Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±"
BTN_ADDQ    = "â• Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„"
BTN_LISTQUIZ= "ğŸ“š Ø¹Ø±Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_LISTQ   = "ğŸ“– Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©"
BTN_EDITQUIZ= "ğŸ› ï¸ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø±"
BTN_DELQUIZ = "ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ø®ØªØ¨Ø§Ø±"
BTN_BUNDLES = "ğŸ“ Ù…Ø±ÙÙ‚Ø§Øª Ù…Ø´ØªØ±ÙƒØ©"
BTN_MERGE   = "ğŸ”— Ø¯Ù…Ø¬ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_EXPORT  = "ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø±"
BTN_IMPORT  = "ğŸ“¥ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙØ¹Ø©"
BTN_PUBLISH = "ğŸš€ Ù†Ø´Ø± Ø§Ø®ØªØ¨Ø§Ø±"
BTN_WIPE_ALL= "ğŸ§¹ Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª"
BTN_SCORE   = "ğŸ† Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬"
BTN_BACK_HOME = "â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©"
BTN_BACK_STEP = "â¬…ï¸ Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø®Ù„Ù"
BTN_LEVEL   = "ğŸ¯ ØªÙ‚ÙŠÙŠÙ… Ù…Ø³ØªÙˆÙ‰"
BTN_HL_PROFILE = "ğŸ§  Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª HÃ¶ren & Lesen"
BTN_BRIEF_BUTTON = "âœ‰ï¸ Ø²Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ"

class ExportStates(StatesGroup):
    waiting_pick_quiz = State()

class HLProfileStates(StatesGroup):
    waiting_pick_quiz = State()

class SchreibenStates(StatesGroup):
    waiting_text = State()

class BriefAdminStates(StatesGroup):
    waiting_custom_minutes = State()

def owner_panel_reply_kb() -> ReplyKeyboardMarkup:
    rows = [
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ)],
        [KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ)],
        [KeyboardButton(text=BTN_LISTQ)],
        [KeyboardButton(text=BTN_EDITQUIZ)],
        [KeyboardButton(text=BTN_DELQUIZ)],
        [KeyboardButton(text=BTN_BUNDLES)],
        [KeyboardButton(text=BTN_IMPORT), KeyboardButton(text=BTN_EXPORT)],
        [KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_PUBLISH)],
        [KeyboardButton(text=BTN_LEVEL)],
        [KeyboardButton(text=BTN_HL_PROFILE)],
        [KeyboardButton(text=BTN_BRIEF_BUTTON)],
        [KeyboardButton(text=BTN_WIPE_ALL)],
        [KeyboardButton(text=BTN_SCORE)],
    ]
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)

def paged_quizzes_kb(page: int = 0, tag: str = "pickq", per:int=8) -> InlineKeyboardMarkup:
    rows = q_all("SELECT id,title FROM quizzes WHERE is_archived=0 ORDER BY id DESC")
    start = page * per; chunk = rows[start:start+per]
    kb = InlineKeyboardBuilder()
    for r in chunk:
        kb.button(text=f"âœ… ID {r['id']} â€” {r['title']}", callback_data=f"{tag}:{r['id']}")
    kb.adjust(1); kb.row()
    if start > 0: kb.button(text="â¬…ï¸", callback_data=f"{tag}_page:{page-1}")
    kb.button(text=f"ØµÙØ­Ø© {page+1}", callback_data="noop")
    if start + per < len(rows): kb.button(text="â¡ï¸", callback_data=f"{tag}_page:{page+1}")
    return kb.as_markup()

# ---------- Feature helpers ----------
def export_quiz_payload(quiz_id:int) -> Optional[Dict]:
    qz = q_one("SELECT id,title,created_by,created_at,grading_profile FROM quizzes WHERE id=%s", (quiz_id,))
    if not qz: return None
    qs = q_all("SELECT id,text,created_at,media_bundle_id FROM questions WHERE quiz_id=%s ORDER BY id", (quiz_id,))
    questions = []
    for r in qs:
        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(r["id"],))
        atts = q_all("SELECT kind,file_id,position FROM question_attachments WHERE question_id=%s ORDER BY position",(r["id"],))
        questions.append({
            "id": r["id"], "text": r["text"], "created_at": r["created_at"], "media_bundle_id": r["media_bundle_id"],
            "options": [dict(o) for o in opts], "attachments": [dict(a) for a in atts]
        })
    bundles = q_all("SELECT id,created_at FROM media_bundles WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    bundle_objs = []
    for b in bundles:
        batt = q_all("SELECT kind,file_id,position FROM media_bundle_attachments WHERE bundle_id=%s ORDER BY position",(b["id"],))
        bundle_objs.append({"id":b["id"], "created_at":b["created_at"], "attachments":[dict(x) for x in batt]})
    return {
        "quiz": dict(qz),
        "questions": questions,
        "bundles": bundle_objs,
        "exported_at": datetime.now(timezone.utc).isoformat(),
        "version": 1,
    }

async def maybe_finish_hl(chat_id:int, quiz_id:int, user_id:int):
    prof = q_one("SELECT grading_profile FROM quizzes WHERE id=%s", (quiz_id,))
    if not prof or prof["grading_profile"] != "HL_B1_DTZ":
        return
    qids = [r["id"] for r in q_all("SELECT id FROM questions WHERE quiz_id=%s ORDER BY id", (quiz_id,))]
    total = len(qids)
    if total == 0: return
    placeholders = ",".join(["%s"]*len(qids))
    row = q_one(
        f"SELECT COUNT(*) AS answered, COALESCE(SUM(is_correct),0) AS correct FROM responses WHERE chat_id=%s AND user_id=%s AND question_id IN ({placeholders})",
        (chat_id, user_id, *qids)
    )
    if (row["answered"] or 0) < total:
        return
    correct = int(row["correct"] or 0)
    level = map_level(correct, HL_BANDS)
    q_exec("""INSERT INTO hl_results(origin_chat_id,quiz_id,user_id,correct_count,total_count,level,finished_at)
              VALUES (%s,%s,%s,%s,%s,%s,%s)
              ON CONFLICT (origin_chat_id,quiz_id,user_id) DO UPDATE
              SET correct_count=EXCLUDED.correct_count,total_count=EXCLUDED.total_count,level=EXCLUDED.level,finished_at=EXCLUDED.finished_at""",
           (chat_id, quiz_id, user_id, correct, total, level, _now_utc().isoformat()))
    try:
        await bot.send_message(chat_id,
            f"ğŸ§  <b>HÃ¶ren & Lesen</b>\n"
            f"Ø§Ù„Ø§Ø³Ù…: {hlink_user(f'UID {user_id}', user_id)}\n"
            f"Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>{correct}/{total}</b> â€” <b>{level}</b>"
        )
    except Exception:
        pass

# ---------- Owner helpers ----------
def is_owner(uid:int) -> bool: return uid == OWNER_ID
async def ensure_owner(msg: Message) -> bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("ğŸš« Ù‡Ø°Ø§ Ø§Ù„Ø²Ø±/Ø§Ù„Ø£Ù…Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ.", reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø¯Ø§ÙŠØ©")]], resize_keyboard=True))
        return False
    return True

# ---------- Commands & Handlers ----------
@dp.message(Command("start"))
async def cmd_start(msg: Message):
    if is_owner(msg.from_user.id):
        await msg.answer("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¬Ø§Ù‡Ø²Ø© â€” Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±:", reply_markup=owner_panel_reply_kb())
    else:
        await msg.answer("Ø£Ù‡Ù„Ø§Ù‹! Ù‡Ø°Ø§ Ø¨ÙˆØª Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¹Ù„Ù….\nØ§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª ØªØªÙ… Ø¹Ø¨Ø± Ø§Ø³ØªÙØªØ§Ø¡Ø§Øª Quiz Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.")

@dp.message(Command("dbinfo"))
async def dbinfo(msg: Message):
    try:
        qz = q_one("SELECT COUNT(*) AS n FROM quizzes")["n"]
        qs = q_one("SELECT COUNT(*) AS n FROM questions")["n"]
        rs = q_one("SELECT COUNT(*) AS n FROM responses")["n"]
    except Exception as e:
        return await msg.answer(f"DB error: {e}")
    await msg.answer(f"ğŸ—„ï¸ DB: <code>PostgreSQL</code>\nğŸ§ª Quizzes: <b>{qz}</b> â€” Questions: <b>{qs}</b> â€” Responses: <b>{rs}</b>")

# Export
@dp.message(F.text == "ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø±")
async def btn_export(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(ExportStates.waiting_pick_quiz)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„ØªØµØ¯ÙŠØ±Ù‡ Ø¨ØµÙŠØºØ© JSON:", reply_markup=paged_quizzes_kb(tag="exportq"))

@dp.callback_query(F.data.startswith("exportq_page:"))
async def cb_export_page(cb: CallbackQuery, state: FSMContext):
    if not is_owner(cb.from_user.id): return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    _, page = cb.data.split(":")
    await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„ØªØµØ¯ÙŠØ±Ù‡:", reply_markup=paged_quizzes_kb(page=int(page), tag="exportq"))
    await cb.answer()

@dp.callback_query(F.data.startswith("exportq:"))
async def cb_export_pick(cb: CallbackQuery, state: FSMContext):
    if not is_owner(cb.from_user.id): return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    quiz_id = int(cb.data.split(":")[1])
    payload = export_quiz_payload(quiz_id)
    if not payload:
        return await cb.answer("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±", show_alert=True)
    title = payload["quiz"]["title"]
    fname = f"quiz_{quiz_id}_{_slug(title)}.json"
    path = f"/tmp/{fname}"
    with open(path, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    try:
        await cb.message.answer_document(FSInputFile(path), caption=f"ØªÙ… Ø§Ù„ØªØµØ¯ÙŠØ± âœ… â€” {title}")
    except Exception as e:
        await cb.message.answer(f"ØªØ¹Ø°Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù: {e}\nØ³Ø£Ø±Ø³Ù„ JSON Ù…Ø¨Ø§Ø´Ø±Ø©:")
        await cb.message.answer(f"<pre>{html.escape(json.dumps(payload, ensure_ascii=False, indent=2))}</pre>")
    await cb.answer(); await state.clear()

# HL profile
@dp.message(F.text == "ğŸ§  Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª HÃ¶ren & Lesen")
async def btn_hl_profile(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(HLProfileStates.waiting_pick_quiz)
    await msg.answer("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù„ØªØ¹ÙŠÙŠÙ†Ù‡ ÙƒÙ€ HÃ¶ren & Lesen:", reply_markup=paged_quizzes_kb(tag="sethl"))

@dp.callback_query(F.data.startswith("sethl_page:"))
async def cb_sethl_page(cb: CallbackQuery, state: FSMContext):
    if not is_owner(cb.from_user.id): return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    _, page = cb.data.split(":")
    await cb.message.edit_text("Ø§Ø®ØªØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:", reply_markup=paged_quizzes_kb(page=int(page), tag="sethl"))
    await cb.answer()

@dp.callback_query(F.data.startswith("sethl:"))
async def cb_sethl_pick(cb: CallbackQuery, state: FSMContext):
    if not is_owner(cb.from_user.id): return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    quiz_id = int(cb.data.split(":")[1])
    q_exec("UPDATE quizzes SET grading_profile='HL_B1_DTZ' WHERE id=%s", (quiz_id,))
    await cb.message.answer(f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± {quiz_id} ÙƒÙ€ HÃ¶ren & Lesen (B1 DTZ)")
    await cb.answer(); await state.clear()

# Brief (owner opens timed window)
@dp.message(F.text == "âœ‰ï¸ Ø²Ø± Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ")
async def btn_brief_button(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    kb = InlineKeyboardBuilder()
    kb.button(text="â±ï¸ 15 Ø¯Ù‚ÙŠÙ‚Ø©", callback_data="briefopen:15")
    kb.button(text="â±ï¸ 30 Ø¯Ù‚ÙŠÙ‚Ø©", callback_data="briefopen:30")
    kb.button(text="â±ï¸ 60 Ø¯Ù‚ÙŠÙ‚Ø©", callback_data="briefopen:60")
    kb.button(text="â±ï¸ Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ", callback_data="briefopen:custom")
    if get_open_window(msg.chat.id):
        kb.button(text="â›” Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„", callback_data="briefopen:stop")
    kb.adjust(2)
    await msg.answer("Ø§Ø®ØªØ± Ù…Ø¯Ø© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª (Ø§Ù„Ø²Ø± Ø³ÙŠÙ†Ø´Ø± Ù„Ù„Ø·Ù„Ø§Ø¨ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙØ¹ÙŠÙ„):", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("briefopen:"))
async def cb_brief_open(cb: CallbackQuery, state: FSMContext):
    if not is_owner(cb.from_user.id): return await cb.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
    action = cb.data.split(":")[1]
    if action == "stop":
        close_brief_window(cb.message.chat.id)
        await cb.message.answer("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª."); return await cb.answer()
    if action == "custom":
        await state.set_state(BriefAdminStates.waiting_custom_minutes)
        await cb.message.answer("Ø£Ø±Ø³Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚ (Ù…Ø«Ù„Ø§Ù‹: 45)"); return await cb.answer()
    minutes = int(action)
    open_brief_window(cb.message.chat.id, cb.from_user.id, minutes)
    kb = InlineKeyboardBuilder(); kb.button(text="âœ‰ï¸ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ Ù„Ù„ØªØµØ­ÙŠØ­", callback_data="brief:start")
    await cb.message.answer(f"ØªÙ… ÙØªØ­ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª Ù„Ù…Ø¯Ø© {minutes} Ø¯Ù‚ÙŠÙ‚Ø©.\nØ£Ø±Ø³Ù„ÙˆØ§ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ Ø¨Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚.", reply_markup=kb.as_markup())
    await cb.answer()

@dp.message(BriefAdminStates.waiting_custom_minutes, F.text.regexp(r"^\d{1,3}$"))
async def brief_custom_minutes(msg: Message, state: FSMContext):
    if not await ensure_owner(msg): return
    minutes = int(msg.text)
    open_brief_window(msg.chat.id, msg.from_user.id, minutes)
    kb = InlineKeyboardBuilder(); kb.button(text="âœ‰ï¸ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙ Ù„Ù„ØªØµØ­ÙŠØ­", callback_data="brief:start")
    await msg.answer(f"ØªÙ… ÙØªØ­ Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª Ù„Ù…Ø¯Ø© {minutes} Ø¯Ù‚ÙŠÙ‚Ø©.", reply_markup=kb.as_markup())
    await state.clear()

@dp.callback_query(F.data == "brief:start")
async def cb_brief_start(cb: CallbackQuery, state: FSMContext):
    if not get_open_window(cb.message.chat.id):
        return await cb.answer("Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹", show_alert=True)
    await state.set_state(SchreibenStates.waiting_text)
    await cb.message.answer("âœï¸ Ø£Ø±Ø³Ù„ Ù†Øµ Ø§Ù„Ø¨Ø±ÙŠÙ/Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙƒØ§Ù…Ù„Ø§Ù‹ ÙÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø© (B1 DTZ).")
    await cb.answer()

@dp.message(SchreibenStates.waiting_text, F.text)
async def brief_collect(msg: Message, state: FSMContext):
    if not get_open_window(msg.chat.id):
        await state.clear(); return await msg.answer("â›” Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª. Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠÙØ§Øª Ù…ØºÙ„Ù‚ Ø§Ù„Ø¢Ù†.")
    text = msg.text.strip(); await state.clear()
    score, level, details = await ai_grade_schreiben(text)
    q_exec("""INSERT INTO writing_submissions(origin_chat_id,quiz_id,user_id,text,score,level,evaluated_at,details_json)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s)""",
           (msg.chat.id, 0, msg.from_user.id, text, score, level, _now_utc().isoformat(), json.dumps(details, ensure_ascii=False)))
    fb = html.escape(details.get("feedback","")) if isinstance(details, dict) else ""
    await msg.answer(
        f"ğŸ“® <b>Schreiben (B1 DTZ)</b>\n"
        f"Ø§Ù„Ø§Ø³Ù…: {hlink_user(_display_name(msg.from_user), msg.from_user.id)}\n"
        f"Ø§Ù„Ù†ØªÙŠØ¬Ø©: <b>{score}/20</b> â€” <b>{level}</b>" + (f"\nÙ…Ù„Ø§Ø­Ø¸Ø§Øª: {fb}" if fb else "")
    )

# Poll answers (record + maybe finalize HL)
@dp.poll_answer()
async def on_poll_answer(pa: types.PollAnswer):
    poll_id = pa.poll_id; user_id = pa.user.id
    row = q_one("SELECT chat_id,quiz_id,question_id FROM sent_polls WHERE poll_id=%s", (poll_id,))
    if not row: return
    chat_id, quiz_id, question_id = row["chat_id"], row["quiz_id"], row["question_id"]
    chosen = pa.option_ids[0] if pa.option_ids else -1
    ok = q_one("SELECT is_correct FROM options WHERE question_id=%s AND option_index=%s", (question_id, chosen))
    is_correct = int(ok["is_correct"]) if ok else 0
    q_exec("""INSERT INTO responses(chat_id,user_id,question_id,option_index,is_correct,answered_at)
              VALUES(%s,%s,%s,%s,%s,%s)
              ON CONFLICT (chat_id,user_id,question_id) DO NOTHING""",
           (chat_id, user_id, question_id, chosen, is_correct, _now_utc().isoformat()))
    await maybe_finish_hl(chat_id, quiz_id, user_id)

# Scoreboard (Ø¢Ø®Ø± Ø§Ø®ØªØ¨Ø§Ø±)
@dp.message(F.text == "ğŸ† Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬")
async def btn_score(msg: Message):
    if not await ensure_owner(msg): return
    row = q_one("SELECT id,title,grading_profile FROM quizzes WHERE is_archived=0 ORDER BY id DESC LIMIT 1")
    if not row: return await msg.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª.")
    quiz_id, title, prof = row["id"], row["title"], row["grading_profile"]
    data = q_all("""
        SELECT r.user_id, COALESCE(SUM(r.is_correct),0) AS correct, COUNT(r.question_id) AS answered
        FROM responses r
        JOIN questions q ON q.id=r.question_id AND q.quiz_id=%s
        GROUP BY r.user_id
        ORDER BY correct DESC
    """, (quiz_id,))
    total = q_one("SELECT COUNT(*) AS n FROM questions WHERE quiz_id=%s", (quiz_id,))["n"]
    lines = [f"ğŸ† <b>Ù„ÙˆØ­Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ â€” {title}</b>"]
    for i, r in enumerate(data, 1):
        uid, correct, answered = r["user_id"], int(r["correct"] or 0), int(r["answered"] or 0)
        level_str = f" â€” <i>{map_level(correct, HL_BANDS)}</i>" if prof=='HL_B1_DTZ' else ""
        lines.append(f"{i}. UID {uid}: <b>{correct}</b>/{answered if answered else total}{level_str}")
    await msg.answer("\n".join(lines))

# ---------- Runner ----------
async def main():
    print("Bot is startingâ€¦")
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
