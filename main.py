#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re, traceback
from datetime import datetime, timezone, timedelta
from typing import Optional, List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter, CommandObject
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.exceptions import TelegramBadRequest, TelegramRetryAfter

try:
    from openai import OpenAI
except Exception:
    OpenAI = None  # type: ignore

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

# ---------- Schema ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0,
            grading_profile TEXT NOT NULL DEFAULT 'NONE'
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL, media_bundle_id INTEGER,
            photo TEXT, audio TEXT, audio_is_voice INTEGER DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS media_bundles(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS media_bundle_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            bundle_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, user_id BIGINT NOT NULL,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL, answered_at TEXT NOT NULL,
            UNIQUE(chat_id,user_id,question_id)
        )""",
        """CREATE TABLE IF NOT EXISTS participant_names(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, user_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL, name TEXT NOT NULL,
            UNIQUE(origin_chat_id,user_id,quiz_id)
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )"""
    ]
    for ddl in ddls: q_exec(ddl)
ensure_schema()

# ---------- UI ----------
BTN_NEWQUIZ="üÜï ÿ•ŸÜÿ¥ÿßÿ° ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_ADDQ="‚ûï ÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ"; BTN_LISTQUIZ="üìö ÿπÿ±ÿ∂ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™"
BTN_LISTQ="üìñ ÿπÿ±ÿ∂ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©"; BTN_EDITQUIZ="üõ†Ô∏è ÿ™ÿπÿØŸäŸÑ ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_DELQUIZ="üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿßÿÆÿ™ÿ®ÿßÿ±"
BTN_BUNDLES="üìé ŸÖÿ±ŸÅŸÇÿßÿ™ ŸÖÿ¥ÿ™ÿ±ŸÉÿ©"; BTN_MERGE="üîó ÿØŸÖÿ¨ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™"; BTN_EXPORT="üì§ ÿ™ÿµÿØŸäÿ± ÿßÿÆÿ™ÿ®ÿßÿ±"
BTN_IMPORT="üì• ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿØŸÅÿπÿ©"; BTN_PUBLISH="üöÄ ŸÜÿ¥ÿ± ÿßÿÆÿ™ÿ®ÿßÿ±"; BTN_WIPE_ALL="üßπ ÿ≠ÿ∞ŸÅ ŸÉŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™"
BTN_SCORE="üèÜ ŸÑŸàÿ≠ÿ© ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨"; BTN_BACK_HOME="‚Ü©Ô∏è ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ®ÿØÿßŸäÿ©"; BTN_BACK_STEP="‚¨ÖÔ∏è ÿ±ÿ¨Ÿàÿπ ŸÑŸÑÿÆŸÑŸÅ"
BTN_LEVEL="üéØ ÿ™ŸÇŸäŸäŸÖ ŸÖÿ≥ÿ™ŸàŸâ"; BTN_HL_PROFILE="üß† ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ H√∂ren & Lesen"; BTN_BRIEF="‚úâÔ∏è ÿ≤ÿ± ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ"

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID
async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("üö´ Ÿáÿ∞ÿß ÿßŸÑÿ≤ÿ±/ÿßŸÑÿ£ŸÖÿ± ÿÆÿßÿµ ÿ®ÿßŸÑŸÖÿßŸÑŸÉ.", reply_markup=owner_kb()); return False
    return True
def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"

# ---------- States ----------
class BuildStates(StatesGroup):
    waiting_pick_quiz_for_addq=State()
    waiting_q_block=State()
    waiting_q_attachments=State()
    waiting_correct_index=State()

class BriefStates(StatesGroup):
    waiting_prompt=State()
    waiting_duration=State()
    waiting_custom=State()

# ---------- KBs ----------
def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_LISTQ)],
        [KeyboardButton(text=BTN_EDITQUIZ), KeyboardButton(text=BTN_DELQUIZ)],
        [KeyboardButton(text=BTN_BUNDLES), KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_IMPORT), KeyboardButton(text=BTN_EXPORT)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_HL_PROFILE), KeyboardButton(text=BTN_LEVEL)],
        [KeyboardButton(text=BTN_BRIEF), KeyboardButton(text=BTN_WIPE_ALL)],
    ]; return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)

def done_button_kb(tag: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úîÔ∏è ÿ™ŸÖ", callback_data=f"done:{tag}")
    kb.button(text="‚ùå ÿ®ÿØŸàŸÜ ŸÖÿ±ŸÅŸÇÿßÿ™", callback_data=f"skip:{tag}")
    kb.adjust(2); return kb.as_markup()

# ---------- Parsers ----------
_option_line_re = re.compile(
    r"""^\s*(
        (\d+)[\)\.\-]\s*       # 1) or 1. or 1-
       |([A-Za-z])[)\.\-]\s*   # A) or a) etc.
       |[\-\*\‚Ä¢]\s*            # - bullet or * or ‚Ä¢
    )?(?P<txt>.+?)\s*(?P<mark>(‚úÖ|\(\*\)|\*\)|\*\s*$))?\s*$""",
    re.X | re.U
)

def parse_q_block(text:str)->Tuple[str, List[Tuple[str,bool]]]:
    lines=[l for l in (text.replace("\r","").split("\n")) if l.strip()]
    if not lines: raise ValueError("ŸÜÿµ ŸÅÿßÿ±ÿ∫.")
    qline=lines[0].strip()
    opts=[]
    for l in lines[1:]:
        m=_option_line_re.match(l)
        if not m: continue
        t=m.group("txt").strip()
        if not t: continue
        is_correct=bool(m.group("mark"))
        opts.append((t,is_correct))
    if len(opts)<2 or len(opts)>10:
        raise ValueError("ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ 2 ÿ•ŸÑŸâ 10 ÿÆŸäÿßÿ±ÿßÿ™ ÿ∂ŸÖŸÜ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.")
    # If no explicit mark, we'll ask later
    return qline, opts

# ---------- Attachments helpers ----------
def get_question_atts(question_id:int)->List[dict]:
    return q_all("SELECT kind,file_id,position FROM question_attachments WHERE question_id=%s ORDER BY position",(question_id,))

async def send_attachments(chat_id:int, atts:List[dict]):
    for a in atts:
        try:
            if a["kind"]=="photo":   await bot.send_photo(chat_id, a["file_id"])
            elif a["kind"]=="voice": await bot.send_voice(chat_id, a["file_id"])
            elif a["kind"]=="audio": await bot.send_audio(chat_id, a["file_id"])
        except Exception: pass
        await asyncio.sleep(0.2)

# ---------- /start ----------
@dp.message(Command("start"))
async def start(msg:Message):
    if is_owner(msg.from_user.id):
        await msg.answer("ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ¨ÿßŸáÿ≤ÿ© ‚Äî ÿßÿÆÿ™ÿ± ŸÖŸÜ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±:", reply_markup=owner_kb())
    else:
        await msg.answer("ÿ£ŸáŸÑŸãÿß! Ÿáÿ∞ÿß ÿ®Ÿàÿ™ ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™ ÿ®ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿπŸÑŸÖ.")

# ---------- Add Question (one-shot) ----------
@dp.message(F.text==BTN_ADDQ)
async def addq_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_pick_quiz_for_addq)
    rows=q_all("SELECT id,title FROM quizzes WHERE is_archived=0 ORDER BY id DESC")
    if not rows: return await msg.answer("ŸÑÿß ŸäŸàÿ¨ÿØ ÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™.\nÿ£ŸÜÿ¥ÿ¶ Ÿàÿßÿ≠ÿØŸãÿß ÿ£ŸàŸÑŸãÿß.")
    kb=InlineKeyboardBuilder()
    for r in rows[:30]:
        kb.button(text=f"‚úÖ {r['id']} ‚Äî {r['title']}", callback_data=f"addq:{r['id']}")
    kb.adjust(1)
    await msg.answer("ÿßÿÆÿ™ÿ± ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿ≥ÿ§ÿßŸÑ:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("addq:"))
async def addq_pick(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(quiz_id=qid)
    await state.set_state(BuildStates.waiting_q_block)
    await cb.message.answer(
        "ÿ£ÿ±ÿ≥ŸÑ <b>ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿßÿ≠ÿØÿ©</b> ÿ®ÿµŸäÿ∫ÿ©:\n"
        "ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÅŸä ÿßŸÑÿ≥ÿ∑ÿ± ÿßŸÑÿ£ŸàŸÑ ÿ´ŸÖ ŸÉŸÑ ÿÆŸäÿßÿ± ŸÅŸä ÿ≥ÿ∑ÿ± ŸÖŸÜŸÅÿµŸÑ.\n"
        "ÿ£ŸÖÿ´ŸÑÿ© ŸÑŸÑÿÆŸäÿßÿ±ÿßÿ™: \n"
        "1) ÿ®ÿ±ŸÑŸäŸÜ\n2) ŸáÿßŸÖÿ®Ÿàÿ±ÿ∫\n3) ŸÖŸäŸàŸÜÿÆ ‚úÖ\n\n"
        "ÿ£Ÿà:\n"
        "A) ÿÆŸäÿßÿ± ÿ£ŸàŸÑ\nB) ÿÆŸäÿßÿ± ÿ´ÿßŸÜŸç\n- ÿÆŸäÿßÿ± ÿ´ÿßŸÑÿ´\n\n"
        "ÿ∂ÿπ ‚úÖ ÿ£Ÿà (*) ÿπŸÑŸâ ÿßŸÑÿ≥ÿ∑ÿ± ÿßŸÑÿµÿ≠Ÿäÿ≠ ÿ•ŸÜ ÿ£ÿ±ÿØÿ™ ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ¢ŸÜ.\n"
        "ÿ®ÿπÿØŸáÿß ÿ≥ÿ£ÿ∑ŸÑÿ® ÿßŸÑŸÖÿ±ŸÅŸÇÿßÿ™ÿå ÿ´ŸÖ ÿ≥ÿ£ÿ§ŸÉÿØ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ÿ•ŸÜ ŸÑŸÖ ÿ™ÿ≠ÿØÿØŸáÿß."
    )
    await cb.answer()

@dp.message(BuildStates.waiting_q_block, F.text)
async def got_q_block(msg:Message, state:FSMContext):
    try:
        qid=(await state.get_data())["quiz_id"]
        qtext, opts = parse_q_block(msg.text)
        q_exec("INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",(qid,qtext,datetime.now(timezone.utc).isoformat()))
        new_q=q_one("SELECT id FROM questions WHERE quiz_id=%s ORDER BY id DESC LIMIT 1",(qid,))["id"]
        correct_idx=None
        for i,(t,is_ok) in enumerate(opts):
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(new_q,i,t,1 if is_ok else 0))
            if is_ok: correct_idx=i
        await state.update_data(question_id=new_q, next_att_pos=0, opt_count=len(opts))
        await state.set_state(BuildStates.waiting_q_attachments)
        await msg.answer("‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßŸÑÿÆŸäÿßÿ±ÿßÿ™.\nÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ¢ŸÜ ÿßŸÑŸÖÿ±ŸÅŸÇÿßÿ™ (ÿµŸàÿ±/ŸÅŸàŸäÿ≥/ÿ£ŸàÿØŸäŸà). ÿπŸÜÿØ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ÿßÿ∂ÿ∫ÿ∑: ‚úîÔ∏è ÿ™ŸÖ ÿ£Ÿà ‚ùå ÿ®ÿØŸàŸÜ ŸÖÿ±ŸÅŸÇÿßÿ™.", reply_markup=done_button_kb("qatt"))
        # If no correct mark, we'll ask later after attachments
        await state.update_data(needs_correct = (correct_idx is None))
        if correct_idx is not None:
            await state.update_data(preselected_correct = correct_idx)
    except Exception as e:
        await msg.answer(f"‚ö†Ô∏è ÿ™ÿπÿ∞ÿ± ŸÅŸáŸÖ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: <code>{html.escape(str(e))}</code>\n"
                         "ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ ÿßŸÑÿ≥ÿ∑ÿ± ÿßŸÑÿ£ŸàŸÑ ŸáŸà ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑÿå ŸàŸÉŸÑ ÿÆŸäÿßÿ± ÿ®ÿ≥ÿ∑ÿ± ÿ¨ÿØŸäÿØ.")

@dp.message(BuildStates.waiting_q_attachments, F.photo)
async def qatt_photo(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("next_att_pos",0))
    file_id = msg.photo[-1].file_id
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(qid,"photo",file_id,pos))
    await state.update_data(next_att_pos=pos+1)

@dp.message(BuildStates.waiting_q_attachments, F.voice)
async def qatt_voice(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("next_att_pos",0))
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(qid,"voice",msg.voice.file_id,pos))
    await state.update_data(next_att_pos=pos+1)

@dp.message(BuildStates.waiting_q_attachments, F.audio)
async def qatt_audio(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=d["question_id"]; pos=int(d.get("next_att_pos",0))
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",(qid,"audio",msg.audio.file_id,pos))
    await state.update_data(next_att_pos=pos+1)

@dp.callback_query(F.data.in_({"done:qatt","skip:qatt"}))
async def after_atts(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    needs_correct = bool(d.get("needs_correct", True))
    opt_count = int(d.get("opt_count", 0))
    if not needs_correct:
        # already had a marked correct option
        await state.clear()
        await cb.message.answer("üéØ ÿ™ŸÖ ÿßŸÑÿ≠ŸÅÿ∏ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ (ÿßŸÑÿ≥ÿ§ÿßŸÑ + ÿßŸÑÿÆŸäÿßÿ±ÿßÿ™ + ÿßŸÑŸÖÿ±ŸÅŸÇÿßÿ™ + ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©).")
        return await cb.answer()
    await state.set_state(BuildStates.waiting_correct_index)
    await cb.message.answer(f"ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿÆŸäÿßÿ± ÿßŸÑÿµÿ≠Ÿäÿ≠ (1..{opt_count}):")
    await cb.answer()

@dp.message(BuildStates.waiting_correct_index, F.text.regexp(r"^\d+$"))
async def set_correct(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d["question_id"]); cnt=int(d.get("opt_count",0))
    i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜÿ∑ÿßŸÇ.")
    q_exec("UPDATE options SET is_correct=0 WHERE question_id=%s",(qid,))
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear()
    await msg.answer("‚úÖ ÿ™ŸÖ ÿßŸÑÿ≠ŸÅÿ∏ ÿßŸÑŸÜŸáÿßÿ¶Ÿä.", reply_markup=owner_kb())

# ---------- Brief (kept from v4) ----------
def get_open_window(chat_id:int):
    row=q_one("SELECT id,closes_at,prompt_text,ann_message_id FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(chat_id,))
    if not row: return None
    if row["closes_at"]<=datetime.now(timezone.utc).isoformat():
        q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s",(row["id"],)); return None
    return row

def open_window(chat_id:int, owner:int, minutes:int, prompt:str)->Tuple[int,datetime]:
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))
    opened=datetime.now(timezone.utc); closes=opened+timedelta(minutes=minutes)
    q_exec("""INSERT INTO brief_windows(origin_chat_id,opened_by,opened_at,closes_at,is_open,prompt_text)
              VALUES (%s,%s,%s,%s,1,%s)""",(chat_id,owner,opened.isoformat(),closes.isoformat(),prompt))
    bid=q_one("SELECT id FROM brief_windows WHERE origin_chat_id=%s ORDER BY id DESC LIMIT 1",(chat_id,))["id"]
    return bid, closes

def close_window(chat_id:int): q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))

@dp.message(Command("brief"))
@dp.message(F.text.in_({"ÿ≤ÿ± ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ","ÿ≤ÿ± ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ",BTN_BRIEF}))
async def brief_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await state.set_state(BriefStates.waiting_prompt)
    await msg.answer("‚úçÔ∏è ÿ£ÿ±ÿ≥ŸÑ ŸÜÿµ ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ/ÿßŸÑÿ•ŸäŸÖŸäŸÑ (B1 DTZ):")

def dur_buttons_for_brief(has_open: bool):
    kb=InlineKeyboardBuilder()
    for m in (15,30,60):
        kb.button(text=f"‚è±Ô∏è {m} ÿØŸÇŸäŸÇÿ©", callback_data=f"briefdur:{m}")
    kb.button(text="‚è±Ô∏è ÿ•ÿØÿÆÿßŸÑ ŸäÿØŸàŸä", callback_data="briefdur:custom")
    if has_open: kb.button(text="‚õî ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ", callback_data="briefdur:stop")
    kb.adjust(2); return kb.as_markup()

@dp.message(BriefStates.waiting_prompt, F.text)
async def brief_got_prompt(msg:Message, state:FSMContext):
    prompt=msg.text.strip()
    await state.update_data(prompt=prompt)
    await msg.answer("‚úÖ ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑÿ≥ÿ§ÿßŸÑ.")
    await state.set_state(BriefStates.waiting_duration)
    await msg.answer("ÿßÿÆÿ™ÿ± ŸÖÿØÿ© ÿßŸÑÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ:", reply_markup=dur_buttons_for_brief(has_open=bool(get_open_window(msg.chat.id))))

@dp.callback_query(F.data.startswith("briefdur:"))
async def brief_set_duration(cb:CallbackQuery, state:FSMContext):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("ŸÑŸÑŸÖÿßŸÑŸÉ ŸÅŸÇÿ∑", show_alert=True)
    act=cb.data.split(":")[1]
    data=await state.get_data(); prompt=data.get("prompt","")
    if act=="stop":
        close_window(cb.message.chat.id); await cb.message.answer("‚õî ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅÿßÿ™."); return await cb.answer()
    if act=="custom":
        await state.set_state(BriefStates.waiting_custom); await cb.message.answer("ÿ£ÿ±ÿ≥ŸÑ ÿπÿØÿØ ÿßŸÑÿØŸÇÿßÿ¶ŸÇ (ŸÖÿ´ÿßŸÑ: 45)"); return await cb.answer()
    minutes=int(act); bid, closes = open_window(cb.message.chat.id, cb.from_user.id, minutes, prompt)
    txt=(f"üì£ <b>ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
         f"‚è±Ô∏è ŸäŸÜÿ™ŸáŸä ÿÆŸÑÿßŸÑ: <b>{(closes - datetime.now(timezone.utc)).seconds//60}ÿØ</b>\n"
         f"ÿ£ÿ±ÿ≥ŸÑŸàÿß ŸÜÿµ ÿßŸÑÿ®ÿ±ŸäŸÅ ŸáŸÜÿß ÿ®ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿßÿ≠ÿØÿ©.")
    m=await cb.message.answer(txt)
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear(); await cb.answer()

@dp.message(BriefStates.waiting_custom, F.text.regexp(r"^\d{1,3}$"))
async def brief_custom_duration(msg:Message, state:FSMContext):
    minutes=int(msg.text); prompt=(await state.get_data()).get("prompt","")
    bid,closes=open_window(msg.chat.id,msg.from_user.id,minutes,prompt)
    m=await msg.answer(
        f"üì£ <b>ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ®ÿ±ŸäŸÅ (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
        f"‚è±Ô∏è ŸäŸÜÿ™ŸáŸä ÿÆŸÑÿßŸÑ: <b>{(closes - datetime.now(timezone.utc)).seconds//60}ÿØ</b>\n"
        f"ÿ£ÿ±ÿ≥ŸÑŸàÿß ŸÜÿµ ÿßŸÑÿ®ÿ±ŸäŸÅ ŸáŸÜÿß ÿ®ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿßÿ≠ÿØÿ©."
    )
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear()

# ---------- Collect brief submissions ----------
client=None
if OPENAI_API_KEY and OpenAI:
    try: client=OpenAI(api_key=OPENAI_API_KEY)
    except Exception: client=None

async def ai_grade(text: str) -> Tuple[int, str, Dict]:
    if not client:
        base = min(20, max(0, len(text) // 35))
        lvl = "Unter A2" if base<=6 else ("A2" if base<=14 else "B1")
        return base, lvl, {"note": "fallback heuristic (no OPENAI_API_KEY)"}
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            temperature=0.3,
            messages=[
                {"role":"system","content":"You are a certified Goethe/DTZ examiner. Grade B1 Schreiben (Brief/E-Mail) on a 0‚Äì20 scale and return JSON {\"score\":<int>,\"feedback\":\"<Arabic short>\"}."},
                {"role":"user","content":text},
            ],
            response_format={"type":"json_object"},
        )
        raw = resp.choices[0].message.content or "{}"
        data={}
        try: data=json.loads(raw)
        except Exception: pass
        score = int(max(0, min(20, int(data.get("score", 0)))))
        lvl = "Unter A2" if score<=6 else ("A2" if score<=14 else "B1")
        return score, lvl, data
    except Exception as e:
        base = min(20, max(0, len(text) // 40))
        lvl = "Unter A2" if base<=6 else ("A2" if base<=14 else "B1")
        return base, lvl, {"error": str(e)}

@dp.message(StateFilter(None), F.text)
async def collect_briefs(msg:Message):
    # accept any student's text while window open
    row=q_one("SELECT id,closes_at FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(msg.chat.id,))
    if not row: return
    text=msg.text.strip()
    score, lvl, details = await ai_grade(text)
    fb=html.escape(details.get("feedback","")) if isinstance(details,dict) else ""
    q_exec("""INSERT INTO writing_submissions(origin_chat_id,quiz_id,user_id,text,score,level,evaluated_at,details_json)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s)""",
           (msg.chat.id,0,msg.from_user.id,text,score,lvl,datetime.now(timezone.utc).isoformat(),json.dumps(details,ensure_ascii=False)))
    await msg.reply(
        f"üìÆ <b>Schreiben (B1 DTZ)</b>\n"
        f"üë§ {html.escape(hname(msg.from_user))}\n"
        f"üìä <b>{score}/20</b>\n"
        f"üéØ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: <b>{lvl}</b>" + (f"\nüìù ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™: {fb}" if fb else "")
    )

# ---------- Runner ----------
async def main():
    await dp.start_polling(bot)

if __name__=="__main__":
    try: asyncio.run(main())
    except (KeyboardInterrupt,SystemExit): pass
