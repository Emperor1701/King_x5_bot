#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, os, json, html, re, tempfile
from datetime import datetime, timezone, timedelta
from typing import Optional, List, Dict, Tuple

from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, PollType
from aiogram.types import (
    Message, CallbackQuery, PollAnswer,
    ReplyKeyboardMarkup, KeyboardButton, FSInputFile, File,
    ReactionTypeEmoji
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

try:
    from openai import OpenAI
except Exception:
    OpenAI = None  # type: ignore

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
OWNER_ID = int(os.getenv("OWNER_ID", "0"))
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()
if not BOT_TOKEN or not OWNER_ID or not DATABASE_URL:
    raise SystemExit("Set BOT_TOKEN, OWNER_ID, DATABASE_URL")

bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# ---------- Postgres ----------
import psycopg
from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool
pool = ConnectionPool(conninfo=DATABASE_URL, kwargs={"row_factory": dict_row})

def q_exec(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
        conn.commit()

def q_one(sql:str, params:tuple|list|None=None):
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchone()

def q_all(sql:str, params:tuple|list|None=None)->List[dict]:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params or ())
            return cur.fetchall()

def insert_returning_id(sql:str, params:tuple|list|None=None)->int:
    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql + " RETURNING id", params or ())
            row = cur.fetchone()
        conn.commit()
    return int(row["id"] if isinstance(row, dict) else row[0])

# ---------- Schema ----------
def ensure_schema():
    ddls = [
        """CREATE TABLE IF NOT EXISTS quizzes(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            title TEXT NOT NULL,
            created_by BIGINT NOT NULL,
            created_at TEXT NOT NULL,
            is_archived INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS questions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            quiz_id INTEGER NOT NULL, text TEXT NOT NULL,
            created_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS options(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, option_index INTEGER NOT NULL,
            text TEXT NOT NULL, is_correct INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS question_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            question_id INTEGER NOT NULL, kind TEXT NOT NULL, file_id TEXT NOT NULL, position INTEGER NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS sent_polls(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL, quiz_id INTEGER NOT NULL, question_id INTEGER NOT NULL,
            poll_id TEXT NOT NULL, message_id BIGINT NOT NULL,
            expires_at TEXT, is_closed INTEGER NOT NULL DEFAULT 0
        )""",
        """CREATE TABLE IF NOT EXISTS brief_windows(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, opened_by BIGINT NOT NULL,
            opened_at TEXT NOT NULL, closes_at TEXT NOT NULL,
            is_open INTEGER NOT NULL DEFAULT 1,
            prompt_text TEXT, ann_message_id BIGINT
        )""",
        """CREATE TABLE IF NOT EXISTS writing_submissions(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            origin_chat_id BIGINT NOT NULL, quiz_id INTEGER,
            user_id BIGINT NOT NULL, text TEXT NOT NULL,
            score INTEGER NOT NULL, level TEXT NOT NULL,
            evaluated_at TEXT NOT NULL, details_json TEXT
        )""",
        """CREATE TABLE IF NOT EXISTS quiz_responses(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            chat_id BIGINT NOT NULL,
            quiz_id INTEGER NOT NULL,
            question_id INTEGER NOT NULL,
            user_id BIGINT NOT NULL,
            username TEXT,
            option_index INTEGER NOT NULL,
            is_correct INTEGER NOT NULL,
            answered_at TEXT NOT NULL
        )""",
        """CREATE TABLE IF NOT EXISTS shared_attachments(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            kind TEXT NOT NULL,
            file_id TEXT NOT NULL,
            title TEXT,
            created_at TEXT NOT NULL
        )"""
    ]
    for ddl in ddls: q_exec(ddl)
ensure_schema()

# ---------- UI ----------
BTN_NEWQUIZ="🆕 إنشاء اختبار"; BTN_ADDQ="➕ إضافة سؤال"; BTN_LISTQUIZ="📚 عرض الاختبارات"
BTN_EDITQUIZ="🛠️ تعديل اختبار"; BTN_DELQUIZ="🗑️ حذف اختبار"
BTN_BUNDLES="📎 مرفقات مشتركة"; BTN_MERGE="🔗 دمج الاختبارات"
BTN_EXPORT="📤 تصدير اختبار"; BTN_IMPORT="📥 استيراد دفعة"
BTN_PUBLISH="🚀 نشر اختبار"; BTN_WIPE_ALL="🧹 حذف كل الاختبارات"
BTN_SCORE="🏆 لوحة النتائج"; BTN_BACK_HOME="↩️ العودة للبداية"; BTN_BACK_STEP="⬅️ رجوع للخلف"
BTN_BRIEF="✉️ زر إرسال البريف"
BTN_LISTQUESTIONS="📝 عرض الأسئلة"
BTN_EDITQUESTION="✏️ تعديل سؤال"

def owner_kb()->ReplyKeyboardMarkup:
    rows=[
        [KeyboardButton(text=BTN_BACK_HOME), KeyboardButton(text=BTN_BACK_STEP)],
        [KeyboardButton(text=BTN_NEWQUIZ), KeyboardButton(text=BTN_ADDQ)],
        [KeyboardButton(text=BTN_LISTQUIZ), KeyboardButton(text=BTN_EDITQUIZ)],
        [KeyboardButton(text=BTN_LISTQUESTIONS), KeyboardButton(text=BTN_EDITQUESTION)],
        [KeyboardButton(text=BTN_DELQUIZ), KeyboardButton(text=BTN_BRIEF)],
        [KeyboardButton(text=BTN_PUBLISH), KeyboardButton(text=BTN_SCORE)],
        [KeyboardButton(text=BTN_EXPORT), KeyboardButton(text=BTN_IMPORT)],
        [KeyboardButton(text=BTN_BUNDLES), KeyboardButton(text=BTN_MERGE)],
        [KeyboardButton(text=BTN_WIPE_ALL)],
    ]
    return ReplyKeyboardMarkup(
        keyboard=rows,
        resize_keyboard=True,
        is_persistent=True,
        input_field_placeholder="اختر أمرًا من الأزرار 👇"
    )

ALL_BTN_TEXTS = {
    BTN_BACK_HOME, BTN_BACK_STEP, BTN_NEWQUIZ, BTN_ADDQ, BTN_LISTQUIZ, BTN_EDITQUIZ,
    BTN_DELQUIZ, BTN_BRIEF, BTN_WIPE_ALL, BTN_SCORE, BTN_PUBLISH, BTN_BUNDLES,
    BTN_MERGE, BTN_EXPORT, BTN_IMPORT, BTN_LISTQUESTIONS, BTN_EDITQUESTION
}

def done_button_kb(tag: str):
    kb = InlineKeyboardBuilder()
    kb.button(text="✔️ تم", callback_data=f"done:{tag}")
    kb.button(text="❌ بدون مرفقات", callback_data=f"skip:{tag}")
    kb.adjust(2); return kb.as_markup()

def inline_confirm_kb(tag:str):
    kb=InlineKeyboardBuilder()
    kb.button(text="✅ تأكيد", callback_data=f"{tag}:yes")
    kb.button(text="❌ إلغاء", callback_data=f"{tag}:no")
    kb.adjust(2); return kb.as_markup()

def attach_choice_kb():
    kb=InlineKeyboardBuilder()
    kb.button(text="📎 مرفقات خاصة", callback_data="att:upload")
    kb.button(text="📎 من المشتركة", callback_data="att:shared")
    kb.button(text="❌ بدون مرفقات", callback_data="att:none")
    kb.adjust(2,1); return kb.as_markup()

def shared_list_kb(question_id:int):
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    kb=InlineKeyboardBuilder()
    for r in rows:
        label=f"{r['id']} — {r['kind']} — {(r['title'] or '')[:20]}"
        kb.button(text=label, callback_data=f"attadd:{question_id}:{r['id']}")
    kb.button(text="✔️ تم", callback_data=f"attdone:{question_id}")
    kb.adjust(1)
    return kb.as_markup()

def publish_hours_kb(quiz_id:int):
    kb=InlineKeyboardBuilder()
    for h in (1,2,4,8,24):
        kb.button(text=f"⏳ {h} ساعة", callback_data=f"pubdur:{quiz_id}:{h}")
    kb.button(text="⌨️ رقم مخصص", callback_data=f"pubdur:{quiz_id}:custom")
    kb.button(text="♾️ بدون مؤقّت", callback_data=f"pubdur:{quiz_id}:0")
    kb.adjust(2,2,1)
    return kb.as_markup()

# ---------- Helpers ----------
def _now()->datetime: return datetime.now(timezone.utc)
def is_owner(uid:int)->bool: return uid==OWNER_ID
async def ensure_owner(msg:Message)->bool:
    if not is_owner(msg.from_user.id):
        await msg.reply("🚫 هذا الزر/الأمر خاص بالمالك.", reply_markup=owner_kb()); return False
    return True
def hname(u)->str:
    nm=" ".join([x for x in [getattr(u,"first_name",None),getattr(u,"last_name",None)] if x]).strip()
    if not nm and getattr(u,"username",None): nm=f"@{u.username}"
    return nm or f"UID {u.id}"

async def send_long(chat_id:int, text:str):
    MAX=3800
    buf=""
    for para in text.split("\n\n"):
        if len(buf)+len(para)+2>MAX and buf:
            await bot.send_message(chat_id, buf)
            buf=""
        buf += (("\n\n" if buf else "") + para)
    if buf:
        await bot.send_message(chat_id, buf)

async def attach_file_to_question(question_id:int, kind:str, file_id:str):
    pos_row = q_one("SELECT COALESCE(MAX(position),-1) AS p FROM question_attachments WHERE question_id=%s",(question_id,))
    pos = int(pos_row["p"]) + 1
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
           (question_id, kind, file_id, pos))

# --- Callback guard for NON-owner only ---
@dp.callback_query(
    F.from_user.id != OWNER_ID,
    F.data.regexp(r"^(addq|editq|delq|delqconfirm|briefdur|done:|skip:|wipe:|listq:|pickq:|editqs:|pickqs:|pub:|pubdur:|scoreq:|export:|bund:|merge:|att:|attadd:|attdone:|editm:)")
)
async def admin_cb_guard(cb: CallbackQuery):
    await cb.answer("🚫 هذا الزر خاص بالمالك.", show_alert=True)

# ---------- States ----------
class BuildStates(StatesGroup):
    waiting_title=State()
    waiting_pick_quiz_for_addq=State()
    waiting_q_block=State()
    waiting_correct_index=State()
    waiting_pick_for_edit=State()
    waiting_new_title=State()
    waiting_pick_for_delete=State()
    waiting_attach_mode=State()
    waiting_q_attachments_upload=State()
    waiting_q_attachments_shared=State()

class WipeStates(StatesGroup):
    waiting_confirm=State()

class BriefStates(StatesGroup):
    waiting_prompt=State()
    waiting_duration=State()
    waiting_custom=State()

class EditQStates(StatesGroup):
    pick_quiz=State()
    edit_menu=State()
    edit_text=State()
    edit_options=State()
    correct_index=State()
    attach_mode=State()
    attach_upload=State()
    attach_shared=State()
    current_qid=State()

class ImportStates(StatesGroup):
    waiting_json=State()

class BundleStates(StatesGroup):
    idle=State()
    add_wait_file=State()
    attach_pick_quiz=State()
    attach_pick_question=State()
    attach_pick_bundle=State()

class MergeStates(StatesGroup):
    pick_dest=State()
    pick_source=State()

class PublishStates(StatesGroup):
    waiting_hours_custom=State()

# ---------- Parsers ----------
_option_line_re = re.compile(
    r"""^\s*(
        (\d+)[\)\.\-]\s*       # 1) or 1. or 1-
       |([A-Za-z])[)\.\-]\s*   # A) or a) etc.
       |[\-\*\•]\s*            # - bullet or * or •
    )?(?P<txt>.+?)\s*(?P<mark>(✅|\(\*\)|\*\)|\*\s*$))?\s*$""",
    re.X | re.U
)

def parse_q_block(text:str)->Tuple[str, List[Tuple[str,bool]]]:
    lines=[l for l in (text.replace("\r","").split("\n")) if l.strip()]
    if not lines: raise ValueError("نص فارغ.")
    qline=lines[0].strip()
    opts=[]
    for l in lines[1:]:
        m=_option_line_re.match(l)
        if not m: continue
        t=m.group("txt").strip()
        if not t: continue
        is_correct=bool(m.group("mark"))
        opts.append((t,is_correct))
    if len(opts)<2 or len(opts)>10:
        raise ValueError("الرجاء إدخال 2 إلى 10 خيارات ضمن الرسالة.")
    return qline, opts

def parse_options_only(text:str)->List[Tuple[str,bool]]:
    lines=[l for l in (text.replace("\r","").split("\n")) if l.strip()]
    opts=[]
    for l in lines:
        m=_option_line_re.match(l)
        if not m: continue
        t=m.group("txt").strip()
        if not t: continue
        is_correct=bool(m.group("mark"))
        opts.append((t,is_correct))
    if len(opts)<2 or len(opts)>10:
        raise ValueError("أدخل 2 إلى 10 خيارات.")
    return opts

# ---------- /start & back ----------
@dp.message(Command("start"))
async def start(msg:Message):
    if is_owner(msg.from_user.id):
        await msg.answer("لوحة التحكم جاهزة — اختر من الأزرار:", reply_markup=owner_kb())
    else:
        await msg.answer("أهلاً! هذا بوت اختبارات بإدارة المعلم.")

@dp.message(F.text==BTN_BACK_HOME)
async def back_home(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("تم الرجوع للبداية.", reply_markup=owner_kb())

@dp.message(F.text==BTN_BACK_STEP)
async def back_step(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await msg.answer("رجعنا خطوة (تمت إعادة الضبط).", reply_markup=owner_kb())

# ---------- Create quiz ----------
@dp.message(F.text==BTN_NEWQUIZ)
async def new_quiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(BuildStates.waiting_title)
    await msg.answer("أرسل عنوان الاختبار:")

@dp.message(BuildStates.waiting_title, F.text)
async def save_quiz_title(msg:Message, state:FSMContext):
    title = msg.text.strip()
    qid = insert_returning_id(
        "INSERT INTO quizzes(title,created_by,created_at) VALUES (%s,%s,%s)",
        (title, msg.from_user.id, _now().isoformat())
    )
    await state.clear()
    await msg.answer(f"✅ تم إنشاء الاختبار (ID {qid}).", reply_markup=owner_kb())

# ---------- List quizzes ----------
@dp.message(F.text==BTN_LISTQUIZ)
async def list_quizzes(msg:Message):
    if not await ensure_owner(msg): return
    rows = q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.\nأنشئ واحدًا أولاً.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"{r['id']} — {r['title']}", callback_data=f"listq:{r['id']}")
    kb.adjust(1)
    await msg.answer("اختر اختبارًا لعرض تفاصيله:", reply_markup=kb.as_markup())

# ---------- List Questions (full) ----------
@dp.message(F.text==BTN_LISTQUESTIONS)
async def list_questions_entry(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"📝 {r['id']} — {r['title']}", callback_data=f"listq:{r['id']}")
    kb.adjust(1)
    await msg.answer("اختر اختبارًا لعرض أسئلته كاملة:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("listq:"))
async def show_quiz_details(cb:CallbackQuery):
    qid=int(cb.data.split(":")[1])
    title_row = q_one("SELECT title FROM quizzes WHERE id=%s",(qid,))
    title = title_row["title"] if title_row else f"ID {qid}"
    qs=q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id ASC",(qid,))
    if not qs:
        await cb.message.answer(f"📚 \"{html.escape(title)}\" بلا أسئلة بعد.", reply_markup=owner_kb()); return await cb.answer()
    chunks=[]
    current=f"📝 <b>أسئلة الاختبار:</b> {html.escape(title)}\n"
    for q in qs:
        opts=q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        block=f"\n<b>Q{q['id']}:</b> {html.escape(q['text'])}\n" + "\n".join([f"{o['option_index']+1}) {html.escape(o['text'])} {'✅' if o['is_correct'] else ''}" for o in opts])
        if len(current)+len(block) > 3500:
            chunks.append(current); current=""
        current += block
    if current: chunks.append(current)
    for part in chunks:
        await cb.message.answer(part)
    await cb.answer()

# ---------- Edit quiz title ----------
@dp.message(F.text==BTN_EDITQUIZ)
async def editquiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"✏️ {r['id']} — {r['title'][:30]}", callback_data=f"editq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_for_edit)
    await msg.answer("اختر اختبارًا لتعديل العنوان:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_for_edit, F.data.startswith("editq:"))
async def pick_for_edit(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(edit_id=qid)
    await state.set_state(BuildStates.waiting_new_title)
    await cb.message.answer("أرسل العنوان الجديد:")
    await cb.answer()

@dp.message(BuildStates.waiting_new_title, F.text)
async def apply_edit(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_id")
    q_exec("UPDATE quizzes SET title=%s WHERE id=%s", (msg.text.strip(), qid))
    await state.clear()
    await msg.answer("✅ تم تعديل العنوان.", reply_markup=owner_kb())

# ---------- Delete quiz ----------
@dp.message(F.text==BTN_DELQUIZ)
async def delquiz(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"🗑️ {r['id']} — {r['title'][:30]}", callback_data=f"delq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_for_delete)
    await msg.answer("اختر اختبارًا للحذف:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_for_delete, F.data.startswith("delq:"))
async def delq_confirm(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    kb=inline_confirm_kb(f"delqconfirm:{qid}")
    await cb.message.answer(f"⚠️ تأكيد حذف الاختبار ID {qid}؟", reply_markup=kb)
    await cb.answer()

@dp.callback_query(F.data.regexp(r"^delqconfirm:(\d+):(yes|no)$"))
async def delq_apply(cb:CallbackQuery):
    _, rest = cb.data.split("delqconfirm:")
    qid, decision = rest.split(":")
    qid=int(qid)
    if decision=="no":
        await cb.message.answer("تم الإلغاء ✅", reply_markup=owner_kb()); return await cb.answer()
    q_exec("DELETE FROM options WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)", (qid,))
    q_exec("DELETE FROM question_attachments WHERE question_id IN (SELECT id FROM questions WHERE quiz_id=%s)", (qid,))
    q_exec("DELETE FROM questions WHERE quiz_id=%s", (qid,))
    q_exec("DELETE FROM sent_polls WHERE quiz_id=%s", (qid,))
    q_exec("DELETE FROM quizzes WHERE id=%s", (qid,))
    await cb.message.answer("🗑️ تم حذف الاختبار.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Add Question (with attachment choice) ----------
@dp.message(F.text==BTN_ADDQ)
async def addq_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.\nأنشئ واحدًا أولاً.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:30]:
        kb.button(text=f"✅ {r['id']} — {r['title']}", callback_data=f"addq:{r['id']}")
    kb.adjust(1)
    await state.set_state(BuildStates.waiting_pick_quiz_for_addq)
    await msg.answer("اختر الاختبار لإضافة سؤال:", reply_markup=kb.as_markup())

@dp.callback_query(BuildStates.waiting_pick_quiz_for_addq, F.data.startswith("addq:"))
async def addq_pick(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(quiz_id=qid)
    await state.set_state(BuildStates.waiting_q_block)
    await cb.message.answer(
        "أرسل <b>رسالة واحدة</b>:\n"
        "السطر الأول السؤال، ثم كل خيار بسطر جديد (2..10).\n"
        "مثال:\n"
        "ما عاصمة ألمانيا؟\n1) هامبورغ\n2) برلين ✅\n3) ميونخ\n\n"
        "يمكنك وضع ✅ أو (*) على الخيار الصحيح."
    )
    await cb.answer()

@dp.message(BuildStates.waiting_q_block, F.text)
async def got_q_block(msg:Message, state:FSMContext):
    try:
        sel=(await state.get_data()); quiz_id=sel["quiz_id"]
        qtext, opts = parse_q_block(msg.text)
        new_q = insert_returning_id(
            "INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
            (quiz_id, qtext, _now().isoformat())
        )
        correct=None
        for i,(t,is_ok) in enumerate(opts):
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (new_q,i,t,1 if is_ok else 0))
            if is_ok: correct=i
        await state.update_data(question_id=new_q, opt_count=len(opts), needs_correct=(correct is None))
        await state.set_state(BuildStates.waiting_attach_mode)
        await msg.answer("اختر نوع المرفقات للسؤال:", reply_markup=attach_choice_kb())
    except Exception as e:
        await msg.answer(f"⚠️ لم أفهم الرسالة: <code>{html.escape(str(e))}</code>")

@dp.callback_query(BuildStates.waiting_attach_mode, F.data.startswith("att:"))
async def addq_attach_mode(cb:CallbackQuery, state:FSMContext):
    mode = cb.data.split(":")[1]
    d=await state.get_data()
    qid = int(d["question_id"])
    if mode=="upload":
        await state.set_state(BuildStates.waiting_q_attachments_upload)
        await cb.message.answer("أرسل صور/فويس/أوديو كمرفقات خاصة. ثم اضغط ✔️ تم.", reply_markup=done_button_kb("qatt"))
    elif mode=="shared":
        rows = q_all("SELECT id FROM shared_attachments ORDER BY id DESC LIMIT 1")
        if not rows:
            await cb.message.answer("لا توجد مرفقات مشتركة بعد. أضف من زر 📎 مرفقات مشتركة.", reply_markup=owner_kb())
            await cb.message.answer("اختر نوع المرفقات:", reply_markup=attach_choice_kb())
            await cb.answer(); return
        await state.set_state(BuildStates.waiting_q_attachments_shared)
        await cb.message.answer("اختر من المرفقات المشتركة (يمكن اختيار أكثر من واحد) ثم اضغط ✔️ تم.", reply_markup=shared_list_kb(qid))
    elif mode=="none":
        if d.get("needs_correct", True):
            await state.set_state(BuildStates.waiting_correct_index)
            await cb.message.answer(f"أرسل رقم الخيار الصحيح (1..{int(d['opt_count'])}):")
        else:
            await state.clear(); await cb.message.answer("✅ تم الحفظ النهائي.", reply_markup=owner_kb())
    await cb.answer()

@dp.message(BuildStates.waiting_q_attachments_upload, F.photo | F.voice | F.audio)
async def addq_attach_upload(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d["question_id"])
    if msg.photo:
        await attach_file_to_question(qid, "photo", msg.photo[-1].file_id)
    elif msg.voice:
        await attach_file_to_question(qid, "voice", msg.voice.file_id)
    elif msg.audio:
        await attach_file_to_question(qid, "audio", msg.audio.file_id)

@dp.callback_query(F.data=="done:qatt")
async def addq_attach_done(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    if d.get("needs_correct", True):
        await state.set_state(BuildStates.waiting_correct_index)
        await cb.message.answer(f"أرسل رقم الخيار الصحيح (1..{int(d['opt_count'])}):")
    else:
        await state.clear(); await cb.message.answer("✅ تم الحفظ النهائي.", reply_markup=owner_kb())
    await cb.answer()

@dp.callback_query(BuildStates.waiting_q_attachments_shared, F.data.startswith("attadd:"))
async def addq_attach_shared_add(cb:CallbackQuery):
    _, qid_str, bid_str = cb.data.split(":")
    question_id = int(qid_str); bundle_id = int(bid_str)
    b = q_one("SELECT kind,file_id FROM shared_attachments WHERE id=%s",(bundle_id,))
    if not b:
        await cb.answer("غير موجود.", show_alert=True); return
    await attach_file_to_question(question_id, b["kind"], b["file_id"])
    await cb.answer("تم ربط مرفق.", show_alert=False)

@dp.callback_query(BuildStates.waiting_q_attachments_shared, F.data.startswith("attdone:"))
async def addq_attach_shared_done(cb:CallbackQuery, state:FSMContext):
    d=await state.get_data()
    if d.get("needs_correct", True):
        await state.set_state(BuildStates.waiting_correct_index)
        await cb.message.answer(f"أرسل رقم الخيار الصحيح (1..{int(d['opt_count'])}):")
    else:
        await state.clear(); await cb.message.answer("✅ تم الحفظ النهائي.", reply_markup=owner_kb())
    await cb.answer()

@dp.message(BuildStates.waiting_correct_index, F.text.regexp(r"^\d+$"))
async def set_correct(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d["question_id"]); cnt=int(d.get("opt_count",0))
    i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("خارج النطاق.")
    q_exec("UPDATE options SET is_correct=0 WHERE question_id=%s",(qid,))
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear(); await msg.answer("✅ تم الحفظ النهائي.", reply_markup=owner_kb())

# ---------- Edit single question (menu) ----------
@dp.message(F.text==BTN_EDITQUESTION)
async def edit_question_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"{r['id']} — {r['title']}", callback_data=f"editqs:{r['id']}")
    kb.adjust(1)
    await state.set_state(EditQStates.pick_quiz)
    await msg.answer("اختر الاختبار لاختيار سؤال:", reply_markup=kb.as_markup())

@dp.callback_query(EditQStates.pick_quiz, F.data.startswith("editqs:"))
async def pick_quiz_for_question(cb:CallbackQuery, state:FSMContext):
    qz=int(cb.data.split(":")[1])
    qs=q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id ASC",(qz,))
    if not qs:
        await cb.message.answer("لا يوجد أسئلة.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for q in qs[:80]:
        preview = (q['text'][:40] + "…") if len(q['text'])>40 else q['text']
        kb.button(text=f"Q{q['id']} — {preview}", callback_data=f"pickqs:{q['id']}")
    kb.adjust(1)
    await cb.message.answer("اختر سؤالًا للتعديل:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(F.data.startswith("pickqs:"))
async def picked_question(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[1])
    await state.update_data(edit_question_id=qid)
    row=q_one("SELECT text FROM questions WHERE id=%s",(qid,))
    opts=q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(qid,))
    txt="السؤال الحالي:\n" + html.escape(row['text']) + "\n" + "\n".join([f"{o['option_index']+1}) {html.escape(o['text'])} {'✅' if o['is_correct'] else ''}" for o in opts])
    kb=InlineKeyboardBuilder()
    kb.button(text="✏️ تعديل السؤال + الخيارات (معًا)", callback_data="editm:text")
    kb.button(text="🧩 تعديل الخيارات فقط", callback_data="editm:opts")
    kb.button(text="📎 إضافة/تبديل مرفقات", callback_data="editm:att_add")
    kb.button(text="🗑️ إزالة كل المرفقات", callback_data="editm:att_clear")
    kb.adjust(1)
    await state.set_state(EditQStates.edit_menu)
    await cb.message.answer(txt + "\n\nاختر العملية:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(EditQStates.edit_menu, F.data=="editm:text")
async def editm_text(cb:CallbackQuery, state:FSMContext):
    await state.set_state(EditQStates.edit_text)
    await cb.message.answer("أرسل الصيغة الجديدة كاملة (سطر سؤال + خيارات).")
    await cb.answer()

@dp.callback_query(EditQStates.edit_menu, F.data=="editm:opts")
async def editm_opts(cb:CallbackQuery, state:FSMContext):
    await state.set_state(EditQStates.edit_options)
    await cb.message.answer("أرسل الخيارات فقط، كل خيار بسطر، ضع ✅ على الصحيح.")
    await cb.answer()

@dp.callback_query(EditQStates.edit_menu, F.data=="editm:att_add")
async def editm_att_add(cb:CallbackQuery, state:FSMContext):
    await state.set_state(EditQStates.attach_mode)
    kb=InlineKeyboardBuilder()
    kb.button(text="📎 مرفقات خاصة (أرسل ملفات)", callback_data="att:upload")
    kb.button(text="📎 من المشتركة", callback_data="att:shared")
    kb.adjust(1)
    await cb.message.answer("اختر طريقة إضافة المرفقات:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(EditQStates.edit_menu, F.data=="editm:att_clear")
async def editm_att_clear(cb:CallbackQuery, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    q_exec("DELETE FROM question_attachments WHERE question_id=%s",(qid,))
    await state.clear()
    await cb.message.answer("🗑️ تم إزالة جميع المرفقات.", reply_markup=owner_kb())
    await cb.answer()

@dp.message(EditQStates.edit_text, F.text)
async def apply_question_edit_full(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    if not qid: return
    qtext, opts = parse_q_block(msg.text)
    q_exec("UPDATE questions SET text=%s WHERE id=%s",(qtext,qid))
    q_exec("DELETE FROM options WHERE question_id=%s",(qid,))
    for i,(t,is_ok) in enumerate(opts):
        q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(qid,i,t,1 if is_ok else 0))
    await state.clear()
    await msg.answer("✅ تم تحديث السؤال وخياراته.", reply_markup=owner_kb())

@dp.message(EditQStates.edit_options, F.text)
async def apply_options_only(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    if not qid: return
    opts=parse_options_only(msg.text)
    correct = next((i for i,(_,ok) in enumerate(opts) if ok), None)
    q_exec("DELETE FROM options WHERE question_id=%s",(qid,))
    for i,(t,is_ok) in enumerate(opts):
        q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",(qid,i,t,1 if is_ok else 0))
    if correct is None:
        await state.update_data(opt_count=len(opts))
        await state.set_state(EditQStates.correct_index)
        await msg.answer(f"أرسل رقم الخيار الصحيح (1..{len(opts)}):")
    else:
        await state.clear(); await msg.answer("✅ تم تحديث الخيارات.", reply_markup=owner_kb())

@dp.message(EditQStates.correct_index, F.text.regexp(r"^\d+$"))
async def apply_options_correct_index(msg:Message, state:FSMContext):
    d=await state.get_data(); qid=int(d.get("edit_question_id")); cnt=int(d.get("opt_count",0))
    i=int(msg.text)-1
    if not (0<=i<cnt): return await msg.answer("خارج النطاق.")
    q_exec("UPDATE options SET is_correct=0 WHERE question_id=%s",(qid,))
    q_exec("UPDATE options SET is_correct=1 WHERE question_id=%s AND option_index=%s",(qid,i))
    await state.clear(); await msg.answer("✅ تم تحديد الإجابة الصحيحة.", reply_markup=owner_kb())

@dp.callback_query(EditQStates.attach_mode, F.data.startswith("att:"))
async def edit_attach_mode(cb:CallbackQuery, state:FSMContext):
    mode=cb.data.split(":")[1]
    if mode=="upload":
        await state.set_state(EditQStates.attach_upload)
        await cb.message.answer("أرسل صور/فويس/أوديو لإرفاقها، ثم اضغط ✔️ تم.", reply_markup=done_button_kb("qatt"))
    elif mode=="shared":
        qid=(await state.get_data()).get("edit_question_id")
        await state.set_state(EditQStates.attach_shared)
        await cb.message.answer("اختر من المرفقات المشتركة ثم اضغط ✔️ تم.", reply_markup=shared_list_kb(qid))
    await cb.answer()

@dp.message(EditQStates.attach_upload, F.photo | F.voice | F.audio)
async def edit_attach_upload(msg:Message, state:FSMContext):
    qid=(await state.get_data()).get("edit_question_id")
    if msg.photo:
        await attach_file_to_question(qid, "photo", msg.photo[-1].file_id)
    elif msg.voice:
        await attach_file_to_question(qid, "voice", msg.voice.file_id)
    elif msg.audio:
        await attach_file_to_question(qid, "audio", msg.audio.file_id)

@dp.callback_query(EditQStates.attach_upload, F.data=="done:qatt")
async def edit_attach_upload_done(cb:CallbackQuery, state:FSMContext):
    await state.clear()
    await cb.message.answer("✅ تم إضافة المرفقات.", reply_markup=owner_kb())
    await cb.answer()

@dp.callback_query(EditQStates.attach_shared, F.data.startswith("attadd:"))
async def edit_attach_shared_add(cb:CallbackQuery, state:FSMContext):
    _, qid_str, bid_str = cb.data.split(":")
    question_id = int(qid_str); bundle_id = int(bid_str)
    b = q_one("SELECT kind,file_id FROM shared_attachments WHERE id=%s",(bundle_id,))
    if not b:
        await cb.answer("غير موجود.", show_alert=True); return
    await attach_file_to_question(question_id, b["kind"], b["file_id"])
    await cb.answer("تم ربط مرفق.", show_alert=False)

@dp.callback_query(EditQStates.attach_shared, F.data.startswith("attdone:"))
async def edit_attach_shared_done(cb:CallbackQuery, state:FSMContext):
    await state.clear()
    await cb.message.answer("✅ تم إضافة المرفقات من المشتركة.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Brief (prompt -> duration -> announce) ----------
def open_window(chat_id:int, owner:int, minutes:int, prompt:str)->Tuple[int,datetime]:
    q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))
    opened=_now(); closes=opened+timedelta(minutes=minutes)
    bid = insert_returning_id(
        """INSERT INTO brief_windows(origin_chat_id,opened_by,opened_at,closes_at,is_open,prompt_text)
              VALUES (%s,%s,%s,%s,1,%s)""",
        (chat_id,owner,opened.isoformat(),closes.isoformat(),prompt)
    )
    return bid, closes

def close_window(chat_id:int): q_exec("UPDATE brief_windows SET is_open=0 WHERE origin_chat_id=%s AND is_open=1",(chat_id,))

def dur_buttons_for_brief(has_open: bool):
    kb=InlineKeyboardBuilder()
    for m in (15,30,60): kb.button(text=f"⏱️ {m} دقيقة", callback_data=f"briefdur:{m}")
    kb.button(text="⏱️ إدخال يدوي", callback_data="briefdur:custom")
    if has_open: kb.button(text="⛔ إيقاف الاستقبال", callback_data="briefdur:stop")
    kb.adjust(2); return kb.as_markup()

def chat_has_open_window(chat_id:int)->bool:
    row=q_one("SELECT 1 FROM brief_windows WHERE origin_chat_id=%s AND is_open=1",(chat_id,))
    return bool(row)

@dp.message(Command("brief"))
@dp.message(F.text==BTN_BRIEF)
async def brief_start(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.clear()
    await state.set_state(BriefStates.waiting_prompt)
    await msg.answer("✍️ أرسل نص سؤال البريف/الإيميل (B1 DTZ):", reply_markup=owner_kb())

@dp.message(BriefStates.waiting_prompt, F.text)
async def brief_got_prompt(msg:Message, state:FSMContext):
    prompt=msg.text.strip()
    await state.update_data(prompt=prompt)
    await state.set_state(BriefStates.waiting_duration)
    await msg.answer("✅ تم استلام السؤال.\nاختر مدة الاستقبال:", reply_markup=dur_buttons_for_brief(has_open=chat_has_open_window(msg.chat.id)))

@dp.callback_query(F.data.startswith("briefdur:"))
async def brief_set_duration(cb:CallbackQuery, state:FSMContext):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("للمالك فقط", show_alert=True)
    act=cb.data.split(":")[1]
    data=await state.get_data(); prompt=data.get("prompt","")
    if act=="stop":
        close_window(cb.message.chat.id); await cb.message.answer("⛔ تم إيقاف استقبال البريفات.", reply_markup=owner_kb()); return await cb.answer()
    if act=="custom":
        await state.set_state(BriefStates.waiting_custom); await cb.message.answer("اكتب المدة بالدقائق (مثال: 45 أو ٤٥)."); return await cb.answer()
    minutes=int(act); bid, closes = open_window(cb.message.chat.id, cb.from_user.id, minutes, prompt)
    mins_left = max(0, int((closes - _now()).total_seconds() // 60))
    txt=(f"📣 <b>سؤال البريف (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
         f"⏱️ ينتهي خلال: <b>{mins_left}د</b>\n"
         f"أرسلوا نص البريف هنا برسالة واحدة.")
    m=await cb.message.answer(txt, reply_markup=owner_kb())
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear(); await cb.answer()

DIGITS_AR = "٠١٢٣٤٥٦٧٨٩"
_AR_DIGIT_MAP = {ord(a): str(i) for i,a in enumerate(DIGITS_AR)}
def normalize_digits(s:str)->str:
    return s.translate(_AR_DIGIT_MAP)

@dp.message(BriefStates.waiting_custom, F.text)
async def brief_custom_duration(msg:Message, state:FSMContext):
    raw = normalize_digits(msg.text)
    m = re.search(r"(\d{1,3})", raw)
    if not m:
        return await msg.answer("❗ اكتب رقم بالدقائق فقط، مثل: 45 أو ٤٥")
    minutes=int(m.group(1))
    minutes=max(1, min(720, minutes))
    prompt=(await state.get_data()).get("prompt","")
    bid,closes=open_window(msg.chat.id,msg.from_user.id,minutes,prompt)
    mins_left = max(0, int((closes - _now()).total_seconds() // 60))
    m=await msg.answer(
        f"📣 <b>سؤال البريف (B1 DTZ)</b>\n{html.escape(prompt)}\n\n"
        f"⏱️ ينتهي خلال: <b>{mins_left}د</b>\n"
        f"أرسلوا نص البريف هنا برسالة واحدة.", reply_markup=owner_kb()
    )
    q_exec("UPDATE brief_windows SET ann_message_id=%s WHERE id=%s",(m.message_id,bid))
    await state.clear()

# ---------- Collect brief submissions ----------
client=None
if OPENAI_API_KEY and OpenAI:
    try: client=OpenAI(api_key=OPENAI_API_KEY)
    except Exception: client=None

async def ai_grade(text: str) -> Tuple[int, str, Dict]:
    if not client:
        base = min(20, max(0, len(text) // 35))
        lvl = "Unter A2" if base<=6 else ("A2" if base<=14 else "B1")
        return base, lvl, {"note": "fallback heuristic (no OPENAI_API_KEY)"}
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            temperature=0.3,
            messages=[
                {"role":"system","content":"You are a certified Goethe/DTZ examiner. Grade B1 Schreiben (Brief/E-Mail) on a 0–20 scale and return JSON {\"score\":<int>,\"feedback\":\"<Arabic short>\"}."},
                {"role":"user","content":text},
            ],
            response_format={"type":"json_object"},
        )
        raw = resp.choices[0].message.content or "{}"
        data={}
        try: data=json.loads(raw)
        except Exception: pass
        score = int(max(0, min(20, int(data.get("score", 0)))))
        lvl = "Unter A2" if score<=6 else ("A2" if score<=14 else "B1")
        return score, lvl, data
    except Exception as e:
        base = min(20, max(0, len(text) // 40))
        lvl = "Unter A2" if base<=6 else ("A2" if base<=14 else "B1")
        return base, lvl, {"error": str(e)}

@dp.message(
    StateFilter(None),
    F.text,
    ~F.text.in_(ALL_BTN_TEXTS),
    ~F.text.startswith("/"),
    F.from_user.as_('u')
)
async def collect_briefs(msg:Message, u):
    if getattr(u, "is_bot", False):
        return
    row = q_one("SELECT id,closes_at FROM brief_windows WHERE origin_chat_id=%s AND is_open=1 ORDER BY id DESC LIMIT 1",(msg.chat.id,))
    if not row:
        return
    if row["closes_at"] <= _now().isoformat():
        q_exec("UPDATE brief_windows SET is_open=0 WHERE id=%s",(row["id"],))
        return
    text=msg.text.strip()
    score, lvl, details = await ai_grade(text)
    fb=html.escape(details.get("feedback","")) if isinstance(details,dict) else ""
    q_exec("""INSERT INTO writing_submissions(origin_chat_id,quiz_id,user_id,text,score,level,evaluated_at,details_json)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s)""",
           (msg.chat.id,0,msg.from_user.id,text,score,lvl,_now().isoformat(),json.dumps(details,ensure_ascii=False)))
    await msg.reply(
        f"📮 <b>Schreiben (B1 DTZ)</b>\n"
        f"👤 {html.escape(hname(msg.from_user))}\n"
        f"📊 <b>{score}/20</b>\n"
        f"🎯 المستوى: <b>{lvl}</b>" + (f"\n📝 ملاحظات: {fb}" if fb else ""),
        reply_markup=owner_kb()
    )

# ---------- Publish quiz with HOURS timer ----------
async def send_question_attachments(chat_id:int, question_id:int):
    atts = q_all("SELECT kind,file_id FROM question_attachments WHERE question_id=%s ORDER BY position",(question_id,))
    for a in atts:
        kind=a["kind"]; fid=a["file_id"]
        try:
            if kind=="photo":
                await bot.send_photo(chat_id, fid)
            elif kind=="voice":
                await bot.send_voice(chat_id, fid)
            elif kind=="audio":
                await bot.send_audio(chat_id, fid)
        except Exception:
            pass

@dp.message(F.text==BTN_PUBLISH)
async def publish_entry(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات لنشرها.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"🚀 نشر {r['id']} — {r['title']}", callback_data=f"pub:{r['id']}")
    kb.adjust(1)
    await msg.answer("اختر اختبارًا للنشر كـ Quiz Polls:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("pub:"))
async def publish_pick_hours(cb:CallbackQuery, state:FSMContext):
    if cb.from_user.id != OWNER_ID:
        return await cb.answer("للمالك فقط", show_alert=True)
    quiz_id = int(cb.data.split(":")[1])
    await state.update_data(pub_quiz_id=quiz_id)
    await cb.message.answer("اختر مؤقّت النشر (بالساعات):", reply_markup=publish_hours_kb(quiz_id))
    await cb.answer()

# Arabic numerals normalize
def normalize_arabic_digits(s:str)->str:
    DIGITS_AR = "٠١٢٣٤٥٦٧٨٩"
    return s.translate({ord(a): str(i) for i,a in enumerate(DIGITS_AR)})

@dp.callback_query(F.data.startswith("pubdur:"))
async def publish_with_hours_decide(cb:CallbackQuery, state:FSMContext):
    _, qid_str, token = cb.data.split(":")
    quiz_id = int(qid_str)
    if token == "custom":
        await state.set_state(PublishStates.waiting_hours_custom)
        await state.update_data(pub_quiz_id=quiz_id)
        await cb.message.answer("اكتب عدد الساعات (مثال: 2 أو ٢).")
        return await cb.answer()
    hours = int(token)
    await _publish_quiz_now(cb, quiz_id, hours)
    await cb.answer()

@dp.message(PublishStates.waiting_hours_custom, F.text)
async def publish_hours_custom(msg:Message, state:FSMContext):
    raw = normalize_arabic_digits(msg.text)
    m = re.search(r"(\d{1,3})", raw)
    if not m:
        return await msg.reply("اكتب رقم الساعات فقط (1..240).")
    hours = int(m.group(1)); hours = max(1, min(240, hours))
    quiz_id = int((await state.get_data()).get("pub_quiz_id"))
    await state.clear()
    # simulate callback-like flow
    class Dummy: pass
    dummy = Dummy(); dummy.message = msg
    await _publish_quiz_now(dummy, quiz_id, hours)

async def _publish_quiz_now(cb_or_dummy, quiz_id:int, hours:int):
    chat_id = cb_or_dummy.message.chat.id
    qs = q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id ASC",(quiz_id,))
    if not qs:
        await cb_or_dummy.message.answer("❌ الاختبار لا يحتوي أسئلة.", reply_markup=owner_kb()); return
    expiry_iso = None
    if hours > 0:
        expiry_iso = (_now() + timedelta(hours=hours)).isoformat()

    sent = 0
    for q in qs:
        await send_question_attachments(chat_id, q["id"])
        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        if len(opts) < 2: 
            continue
        options_text = [o["text"] for o in opts]
        correct_index = next((o["option_index"] for o in opts if o["is_correct"]), 0)
        m = await bot.send_poll(
            chat_id=chat_id,
            question=q["text"][:295],
            options=options_text[:10],
            type=PollType.QUIZ,
            correct_option_id=correct_index,
            is_anonymous=False
        )
        q_exec("INSERT INTO sent_polls(chat_id,quiz_id,question_id,poll_id,message_id,expires_at,is_closed) VALUES (%s,%s,%s,%s,%s,%s,0)",
               (chat_id, quiz_id, q["id"], m.poll.id, m.message_id, expiry_iso))
        sent += 1

    await cb_or_dummy.message.answer(
        f"🚀 تم نشر {sent} سؤالًا من الاختبار {quiz_id}"
        + (f" — المؤقّت: {hours} ساعة" if hours>0 else " — بدون مؤقّت"),
        reply_markup=owner_kb()
    )

# ---------- Auto closer loop for expired polls ----------
async def close_expired_polls_loop():
    while True:
        try:
            rows = q_all("""
                SELECT chat_id, message_id, id
                FROM sent_polls
                WHERE is_closed=0 AND expires_at IS NOT NULL AND expires_at <= %s
                ORDER BY id ASC
                LIMIT 20
            """, (_now().isoformat(),))
            for r in rows:
                try:
                    await bot.stop_poll(chat_id=r["chat_id"], message_id=r["message_id"])
                except Exception:
                    pass
                q_exec("UPDATE sent_polls SET is_closed=1 WHERE id=%s",(r["id"],))
        except Exception:
            # keep loop alive
            pass
        await asyncio.sleep(30)  # check every 30s

# ---------- Handle Poll answers (confetti/X reaction, no text) ----------
@dp.poll_answer()
async def on_poll_answer(pa: PollAnswer):
    poll_id = pa.poll_id
    chosen = pa.option_ids[0] if pa.option_ids else -1
    u = pa.user
    sp = q_one("SELECT chat_id, quiz_id, question_id, message_id, expires_at, is_closed FROM sent_polls WHERE poll_id=%s",(poll_id,))
    if not sp:
        return
    # ignore late answers if manually closed
    if sp["is_closed"]:
        return
    # ignore after expiry
    if sp["expires_at"] and sp["expires_at"] <= _now().isoformat():
        return
    chat_id = sp["chat_id"]; quiz_id=sp["quiz_id"]; qid=sp["question_id"]; message_id=sp["message_id"]
    opt = q_one("SELECT is_correct FROM options WHERE question_id=%s AND option_index=%s",(qid,chosen))
    is_ok = int(opt["is_correct"]) if opt else 0

    q_exec("""INSERT INTO quiz_responses(chat_id,quiz_id,question_id,user_id,username,option_index,is_correct,answered_at)
              VALUES (%s,%s,%s,%s,%s,%s,%s,%s)""",
           (chat_id,quiz_id,qid,u.id, u.username or (u.full_name or ""), chosen, is_ok, _now().isoformat()))

    try:
        emoji = "🎉" if is_ok else "❌"
        await bot.set_message_reaction(
            chat_id=chat_id,
            message_id=message_id,
            reaction=[ReactionTypeEmoji(emoji=emoji)],
            is_big=True
        )
    except Exception:
        pass

# ---------- Leaderboard ----------
@dp.message(F.text==BTN_SCORE)
async def score_entry(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"🏆 نتائج {r['id']} — {r['title']}", callback_data=f"scoreq:{r['id']}")
    kb.adjust(1)
    await msg.answer("اختر اختبارًا لعرض لوحة النتائج:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("scoreq:"))
async def show_score(cb:CallbackQuery):
    quiz_id=int(cb.data.split(":")[1])
    total_q = q_one("SELECT COUNT(*) AS c FROM sent_polls WHERE chat_id=%s AND quiz_id=%s",(cb.message.chat.id,quiz_id))["c"]
    if total_q == 0:
        await cb.message.answer("لا توجد أسئلة منشورة لهذا الاختبار في هذه المحادثة.", reply_markup=owner_kb()); return await cb.answer()

    rows = q_all("""
        SELECT user_id, COALESCE(NULLIF(username,''),'مجهول') AS uname, SUM(is_correct)::int AS correct
        FROM quiz_responses
        WHERE chat_id=%s AND quiz_id=%s
        GROUP BY user_id, uname
        ORDER BY correct DESC, user_id ASC
        LIMIT 20
    """, (cb.message.chat.id, quiz_id))

    lines = [f"{i+1:>2}. {html.escape(r['uname'])} — {r['correct']}/{total_q}" for i,r in enumerate(rows)]
    text = "🏆 <b>لوحة النتائج</b>\n" + ("\n".join(lines) if lines else "لا يوجد مشاركات بعد.")
    await cb.message.answer(text, reply_markup=owner_kb())
    await cb.answer()

# ---------- Export / Import (files + text) ----------
@dp.message(F.text==BTN_EXPORT)
async def export_entry(msg:Message):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات للتصدير.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"📤 تصدير {r['id']} — {r['title']}", callback_data=f"export:{r['id']}")
    kb.adjust(1)
    await msg.answer("اختر اختبارًا لتصديره كملف JSON:", reply_markup=kb.as_markup())

@dp.callback_query(F.data.startswith("export:"))
async def do_export(cb:CallbackQuery):
    quiz_id = int(cb.data.split(":")[1])
    qrow = q_one("SELECT id,title FROM quizzes WHERE id=%s",(quiz_id,))
    if not qrow:
        await cb.message.answer("❌ لم يتم العثور على الاختبار."); return await cb.answer()
    qs = q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id",(quiz_id,))
    payload = {
        "title": qrow["title"],
        "questions": []
    }
    for q in qs:
        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        payload["questions"].append({
            "text": q["text"],
            "options": [{"text": o["text"], "is_correct": int(o["is_correct"])==1} for o in opts]
        })
    with tempfile.NamedTemporaryFile("w", delete=False, suffix=f"_quiz_{quiz_id}.json", encoding="utf-8") as tf:
        json.dump(payload, tf, ensure_ascii=False, indent=2)
        temp_path = tf.name
    await bot.send_document(cb.message.chat.id, FSInputFile(temp_path, filename=f"quiz_{quiz_id}.json"), caption=f"📤 تم تصدير الاختبار {quiz_id}")
    await cb.answer()

@dp.message(F.text==BTN_IMPORT)
async def import_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    await state.set_state(ImportStates.waiting_json)
    await msg.answer("📥 ارفع ملف <b>.json</b> بنفس صيغة التصدير، أو ألصق JSON كنص.")

@dp.message(ImportStates.waiting_json, F.document)
async def import_from_file(msg:Message, state:FSMContext):
    try:
        doc = msg.document
        if not (doc.file_name.lower().endswith(".json") or (doc.mime_type and "json" in doc.mime_type)):
            return await msg.reply("❌ رجاءً ارفع ملف JSON بامتداد .json")
        with tempfile.NamedTemporaryFile("wb", delete=False, suffix=".json") as tf:
            temp_path = tf.name
        try:
            await bot.download(doc, destination=temp_path)
        except Exception:
            f: File = await bot.get_file(doc.file_id)
            await bot.download(f, destination=temp_path)
        with open(temp_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        quiz_id = await _import_payload_create_quiz(data, msg.from_user.id)
        await state.clear()
        await msg.answer(f"✅ تم الاستيراد من الملف وإنشاء الاختبار ID {quiz_id}.", reply_markup=owner_kb())
    except Exception as e:
        await msg.answer(f"❌ فشل الاستيراد من الملف: <code>{html.escape(str(e))}</code>")

@dp.message(ImportStates.waiting_json, F.text)
async def import_from_text(msg:Message, state:FSMContext):
    try:
        data = json.loads(msg.text)
        quiz_id = await _import_payload_create_quiz(data, msg.from_user.id)
        await state.clear()
        await msg.answer(f"✅ تم الاستيراد كنص وإنشاء الاختبار ID {quiz_id}.", reply_markup=owner_kb())
    except Exception as e:
        await msg.answer(f"❌ JSON غير صالح: <code>{html.escape(str(e))}</code>")

async def _import_payload_create_quiz(data:dict, creator_id:int)->int:
    title = str(data.get("title") or "").strip()
    if not title: raise ValueError("title مطلوب")
    questions = data.get("questions") or []
    if not isinstance(questions, list) or not questions: raise ValueError("questions يجب أن تكون قائمة غير فارغة")

    quiz_id = insert_returning_id("INSERT INTO quizzes(title,created_by,created_at) VALUES (%s,%s,%s)",
                                  (title, creator_id, _now().isoformat()))
    for q in questions:
        qtext = str(q.get("text") or "").strip()
        opts = q.get("options") or []
        if not qtext or len(opts) < 2: continue
        qid = insert_returning_id("INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
                                  (quiz_id, qtext, _now().isoformat()))
        for i, o in enumerate(opts[:10]):
            t = str(o.get("text") or "").strip()
            ok = 1 if bool(o.get("is_correct")) else 0
            if not t: continue
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (qid, i, t, ok))
    return quiz_id

# ---------- Shared Attachments (Bundles) ----------
@dp.message(F.text==BTN_BUNDLES)
async def bundles_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    kb=InlineKeyboardBuilder()
    kb.button(text="➕ إضافة مرفق", callback_data="bund:add")
    kb.button(text="📜 قائمة المرفقات", callback_data="bund:list")
    kb.button(text="🔗 ربط بسؤال", callback_data="bund:attach")
    kb.adjust(2,1)
    await state.set_state(BundleStates.idle)
    await msg.answer("📎 إدارة المرفقات المشتركة:", reply_markup=kb.as_markup())

@dp.callback_query(BundleStates.idle, F.data=="bund:add")
async def bundles_add(cb:CallbackQuery, state:FSMContext):
    await state.set_state(BundleStates.add_wait_file)
    await cb.message.answer("أرسل <b>صورة/صوت/فويس</b> كمرفق مشترك (ضع عنوانًا في الكابتشن اختياري).")
    await cb.answer()

@dp.message(BundleStates.add_wait_file, F.photo | F.audio | F.voice)
async def bundles_add_file(msg:Message, state:FSMContext):
    title = (msg.caption or "").strip()
    if msg.photo:
        kind="photo"; file_id = msg.photo[-1].file_id
    elif msg.audio:
        kind="audio"; file_id = msg.audio.file_id
    else:
        kind="voice"; file_id = msg.voice.file_id
    insert_returning_id("INSERT INTO shared_attachments(kind,file_id,title,created_at) VALUES (%s,%s,%s,%s)",
                        (kind,file_id,title,_now().isoformat()))
    await state.set_state(BundleStates.idle)
    await msg.answer("✅ تم حفظ المرفق المشترك.", reply_markup=owner_kb())

@dp.callback_query(BundleStates.idle, F.data=="bund:list")
async def bundles_list(cb:CallbackQuery):
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    if not rows:
        await cb.message.answer("لا توجد مرفقات مشتركة بعد.", reply_markup=owner_kb()); return await cb.answer()
    text = "📜 <b>المرفقات المشتركة</b>:\n" + "\n".join([f"• {r['id']} — {r['kind']} — {html.escape(r['title'] or '')}" for r in rows])
    await cb.message.answer(text, reply_markup=owner_kb())
    await cb.answer()

@dp.callback_query(BundleStates.idle, F.data=="bund:attach")
async def bundles_attach_start(cb:CallbackQuery, state:FSMContext):
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows:
        await cb.message.answer("لا يوجد اختبارات.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"{r['id']} — {r['title']}", callback_data=f"bund:q:{r['id']}")
    kb.adjust(1)
    await state.set_state(BundleStates.attach_pick_quiz)
    await cb.message.answer("اختر الاختبار:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(BundleStates.attach_pick_quiz, F.data.startswith("bund:q:"))
async def bundles_attach_pick_quiz(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[2])
    qs=q_all("SELECT id,text FROM questions WHERE quiz_id=%s ORDER BY id",(qid,))
    if not qs:
        await cb.message.answer("هذا الاختبار بلا أسئلة.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for q in qs[:100]:
        preview = (q['text'][:40] + "…") if len(q['text'])>40 else q['text']
        kb.button(text=f"Q{q['id']} — {preview}", callback_data=f"bund:qq:{q['id']}")
    kb.adjust(1)
    await state.update_data(bundle_target_quiz=qid)
    await state.set_state(BundleStates.attach_pick_question)
    await cb.message.answer("اختر السؤال:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(BundleStates.attach_pick_question, F.data.startswith("bund:qq:"))
async def bundles_attach_pick_question(cb:CallbackQuery, state:FSMContext):
    qid=int(cb.data.split(":")[2])
    rows = q_all("SELECT id,kind,title FROM shared_attachments ORDER BY id DESC LIMIT 100")
    if not rows:
        await cb.message.answer("لا يوجد مرفقات مشتركة لإرفاقها.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for r in rows:
        label = f"{r['id']} — {r['kind']} — {(r['title'] or '')[:20]}"
        kb.button(text=label, callback_data=f"bund:pick:{qid}:{r['id']}")
    kb.adjust(1)
    await state.set_state(BundleStates.attach_pick_bundle)
    await cb.message.answer("اختر المرفق:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(BundleStates.attach_pick_bundle, F.data.startswith("bund:pick:"))
async def bundles_attach_apply(cb:CallbackQuery, state:FSMContext):
    _,_, qid_str, bid_str = cb.data.split(":")
    question_id = int(qid_str); bundle_id = int(bid_str)
    b = q_one("SELECT kind,file_id FROM shared_attachments WHERE id=%s",(bundle_id,))
    if not b:
        await cb.message.answer("المرفق غير موجود.", reply_markup=owner_kb()); return await cb.answer()
    pos_row = q_one("SELECT COALESCE(MAX(position),-1) AS p FROM question_attachments WHERE question_id=%s",(question_id,))
    pos = int(pos_row["p"]) + 1
    q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
           (question_id, b["kind"], b["file_id"], pos))
    await state.clear()
    await cb.message.answer("✅ تم ربط المرفق بالسؤال.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Merge Quizzes ----------
@dp.message(F.text==BTN_MERGE)
async def merge_entry(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    rows=q_all("SELECT id,title FROM quizzes ORDER BY id DESC")
    if not rows: return await msg.answer("لا يوجد اختبارات.", reply_markup=owner_kb())
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"وجهة ← {r['id']} — {r['title']}", callback_data=f"merge:dest:{r['id']}")
    kb.adjust(1)
    await state.set_state(MergeStates.pick_dest)
    await msg.answer("اختر <b>الاختبار الوجهة</b> الذي سيتم الدمج إليه:", reply_markup=kb.as_markup())

@dp.callback_query(MergeStates.pick_dest, F.data.startswith("merge:dest:"))
async def merge_pick_dest(cb:CallbackQuery, state:FSMContext):
    dest=int(cb.data.split(":")[2])
    await state.update_data(merge_dest=dest)
    rows=q_all("SELECT id,title FROM quizzes WHERE id<>%s ORDER BY id DESC",(dest,))
    if not rows: 
        await cb.message.answer("لا يوجد مصدر للدمج.", reply_markup=owner_kb()); return await cb.answer()
    kb=InlineKeyboardBuilder()
    for r in rows[:50]:
        kb.button(text=f"مصدر → {r['id']} — {r['title']}", callback_data=f"merge:src:{r['id']}")
    kb.adjust(1)
    await state.set_state(MergeStates.pick_source)
    await cb.message.answer("اختر <b>الاختبار المصدر</b> لنسخ أسئلته:", reply_markup=kb.as_markup())
    await cb.answer()

@dp.callback_query(MergeStates.pick_source, F.data.startswith("merge:src:"))
async def merge_apply(cb:CallbackQuery, state:FSMContext):
    src=int(cb.data.split(":")[2])
    dest=(await state.get_data()).get("merge_dest")
    if not dest:
        await cb.message.answer("خطأ في اختيار الوجهة.", reply_markup=owner_kb()); return await cb.answer()
    qs = q_all("SELECT id,text,created_at FROM questions WHERE quiz_id=%s ORDER BY id",(src,))
    copied=0
    for q in qs:
        new_qid = insert_returning_id("INSERT INTO questions(quiz_id,text,created_at) VALUES (%s,%s,%s)",
                                      (dest,q["text"],_now().isoformat()))
        opts = q_all("SELECT option_index,text,is_correct FROM options WHERE question_id=%s ORDER BY option_index",(q["id"],))
        for o in opts:
            q_exec("INSERT INTO options(question_id,option_index,text,is_correct) VALUES (%s,%s,%s,%s)",
                   (new_qid, o["option_index"], o["text"], o["is_correct"]))
        atts = q_all("SELECT kind,file_id,position FROM question_attachments WHERE question_id=%s ORDER BY position",(q["id"],))
        for a in atts:
            q_exec("INSERT INTO question_attachments(question_id,kind,file_id,position) VALUES (%s,%s,%s,%s)",
                   (new_qid, a["kind"], a["file_id"], a["position"]))
        copied += 1
    await state.clear()
    await cb.message.answer(f"🔗 تم الدمج: نُسخ {copied} سؤالًا من {src} إلى {dest}.", reply_markup=owner_kb())
    await cb.answer()

# ---------- Wipe All ----------
@dp.message(F.text==BTN_WIPE_ALL)
async def wipe_all_confirm(msg:Message, state:FSMContext):
    if not await ensure_owner(msg): return
    kb=InlineKeyboardBuilder()
    kb.button(text="✅ تأكيد", callback_data="wipe:yes")
    kb.button(text="❌ إلغاء", callback_data="wipe:no")
    kb.adjust(2)
    await state.set_state(WipeStates.waiting_confirm)
    await msg.answer("⚠️ هل تريد حذف كل البيانات؟ لا يمكن التراجع.", reply_markup=kb.as_markup())

@dp.callback_query(WipeStates.waiting_confirm, F.data.in_({"wipe:yes","wipe:no"}))
async def wipe_all_decide(cb:CallbackQuery, state:FSMContext):
    if cb.data=="wipe:no":
        await state.clear(); await cb.message.answer("تم الإلغاء ✅", reply_markup=owner_kb()); return await cb.answer()
    for tbl in ["options","question_attachments","questions","sent_polls","writing_submissions","quiz_responses","brief_windows","shared_attachments","quizzes"]:
        q_exec(f"DELETE FROM {tbl}")
    await state.clear(); await cb.message.answer("🧹 تم حذف كل شيء.", reply_markup=owner_kb()); await cb.answer()

# ---------- Runner ----------
async def main():
    # spawn closer loop
    asyncio.create_task(close_expired_polls_loop())
    await dp.start_polling(bot, allowed_updates=["message","callback_query","poll_answer"])

if __name__=="__main__":
    try: asyncio.run(main())
    except (KeyboardInterrupt,SystemExit): pass
